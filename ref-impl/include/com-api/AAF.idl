cpp_quote("//=---------------------------------------------------------------------=")
cpp_quote("//")
cpp_quote("// This file was GENERATED for the AAF SDK")
cpp_quote("//")
cpp_quote("// The contents of this file are subject to the AAF SDK Public")
cpp_quote("// Source License Agreement (the \"License\"); You may not use this file")
cpp_quote("// except in compliance with the License.  The License is available in")
cpp_quote("// AAFSDKPSL.TXT, or you may obtain a copy of the License from the AAF")
cpp_quote("// Association or its successor.")
cpp_quote("//")
cpp_quote("// Software distributed under the License is distributed on an \"AS IS\"")
cpp_quote("// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See")
cpp_quote("// the License for the specific language governing rights and limitations")
cpp_quote("// under the License.")
cpp_quote("//")
cpp_quote("// The Original Code of this file is Copyright 1998-2001, Licensor of the")
cpp_quote("// AAF Association.")
cpp_quote("//")
cpp_quote("// The Initial Developer of the Original Code of this file and the")
cpp_quote("// Licensor of the AAF Association is Avid Technology.")
cpp_quote("// All rights reserved.")
cpp_quote("//")
cpp_quote("//=---------------------------------------------------------------------=")

cpp_quote("//=--------------------------------------------------------------------------=")
cpp_quote("// AAF Interfaces.")
cpp_quote("//=--------------------------------------------------------------------------=")
cpp_quote("//")

#ifndef DO_NO_IMPORTS
import "unknwn.idl";
#endif

#ifndef DO_NO_IMPORTS
import "objidl.idl";
#endif

#ifndef DO_NO_IMPORTS
import "AAFTypes.idl";
#endif

interface IAAFAIFCDescriptor;
interface IAAFClassDef;
interface IAAFCodecDef;
interface IAAFCommentMarker;
interface IAAFComponent;
interface IAAFCompositionMob;
interface IAAFConstantValue;
interface IAAFContainerDef;
interface IAAFContentStorage;
interface IAAFControlPoint;
interface IAAFDataDef;
interface IAAFDefObject;
interface IAAFPluginDef;
interface IAAFDictionary;
interface IAAFEdgecode;
interface IAAFOperationDef;
interface IAAFEssenceAccess;
interface IAAFEssenceData;
interface IAAFEssenceDescriptor;
interface IAAFEvent;
interface IAAFEventMobSlot;
interface IAAFFile;
interface IAAFFileDescriptor;
interface IAAFFilmDescriptor;
interface IAAFDigitalImageDescriptor;
interface IAAFCDCIDescriptor;
interface IAAFEssenceFormat;
interface IAAFEssenceGroup;
interface IAAFFiller;
interface IAAFFindSourceInfo;
interface IAAFOperationGroup;
interface IAAFGPITrigger;
interface IAAFHeader;
interface IAAFIdentification;
interface IAAFInterpolationDef;
interface IAAFKLVData;
interface IAAFLocator;
interface IAAFMasterMob;
interface IAAFMetaDefinition;
interface IAAFMob;
interface IAAFMobSlot;
interface IAAFNestedScope;
interface IAAFNetworkLocator;
interface IAAFObject;
interface IAAFParameter;
interface IAAFParameterDef;
interface IAAFProperty;
interface IAAFPropertyDef;
interface IAAFPropertyValue;
interface IAAFPluginManager;
interface IAAFPulldown;
interface IAAFRGBADescriptor;
interface IAAFScopeReference;
interface IAAFSegment;
interface IAAFSelector;
interface IAAFSequence;
interface IAAFSourceClip;
interface IAAFSourceMob;
interface IAAFSourceReference;
interface IAAFStaticMobSlot;
interface IAAFTapeDescriptor;
interface IAAFTaggedValue;
interface IAAFTextLocator;
interface IAAFTimecode;
interface IAAFTimelineMobSlot;
interface IAAFTransition;
interface IAAFTIFFDescriptor;
interface IAAFTimecodeStream;
interface IAAFTimecodeStream12M;
interface IAAFTypeDef;
interface IAAFTypeDefCharacter;
interface IAAFTypeDefIndirect;
interface IAAFTypeDefInt;
interface IAAFTypeDefRename;
interface IAAFTypeDefEnum;
interface IAAFTypeDefExtEnum;
interface IAAFTypeDefFixedArray;
interface IAAFTypeDefRecord;
interface IAAFTypeDefSet;
interface IAAFTypeDefStream;
interface IAAFTypeDefString;
interface IAAFTypeDefStrongObjRef;
interface IAAFTypeDefWeakObjRef;
interface IAAFTypeDefObjectRef;
interface IAAFTypeDefOpaque;
interface IAAFTypeDefVariableArray;
interface IAAFVaryingValue;
interface IAAFWAVEDescriptor;
interface IEnumAAFClassDefs;
interface IEnumAAFCodecDefs;
interface IEnumAAFCodecFlavours;
interface IEnumAAFComponents;
interface IEnumAAFContainerDefs;
interface IEnumAAFControlPoints;
interface IEnumAAFDataDefs;
interface IEnumAAFIdentifications;
interface IEnumAAFInterpolationDefs;
interface IEnumAAFOperationDefs;
interface IEnumAAFEssenceData;
interface IEnumAAFKLVData;
interface IEnumAAFLoadedPlugins;
interface IEnumAAFLocators;
interface IEnumAAFMobSlots;
interface IEnumAAFMobs;
interface IEnumAAFParameterDefs;
interface IEnumAAFParameters;
interface IEnumAAFProperties;
interface IEnumAAFPropertyDefs;
interface IEnumAAFPropertyValues;
interface IEnumAAFPluginDefs;
interface IEnumAAFPluginLocators;
interface IEnumAAFSegments;
interface IEnumAAFTaggedValues;
interface IEnumAAFTypeDefs;
interface IAAFRawStorage;
interface IAAFRandomRawStorage;
interface IAAFGetFileBits;
interface IAAFSetFileBits;
interface IAAFRandomFile;
interface IAAFEndian;
interface IAAFSearchSource;
interface IAAFEssenceMultiAccess;
interface IAAFTypeDefVariableArrayEx;


// ************************
//
// Interface IAAFAIFCDescriptor
//
// ************************
//
// The IAAFAIFCDescriptor interface is implemented by objects which
// describe audio content data formatted according to the AIFC compressed
// Audio File Format.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFAIFCDescriptor also implement the following interfaces:
//  - IAAFFileDescriptor
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(e684d774-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFAIFCDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFAIFCDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFAIFCDescriptor-supporting object.  This method must be
  // called after allocation, and before any other method can be
  // called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetSummary()
  //
  // Gets a copy of the AIFC file information without the media.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer.
  // - The size of the buffer is large enough to hold the AIFC file information.
  // 
  // If this method fails pSummary will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - The buffer is too small to hold the AIFC file information.
  //
  // 
  HRESULT GetSummary (
    // Size of preallocated buffer
    [in] aafUInt32  size,

    // Preallocated buffer to hold the AIFC file information
    [out, size_is(size)] aafDataValue_t  pSummary);

  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  // Returns the size of the buffer required for the GetSummary()
  // method.  The value is placed into the location specified by pSize.
  //
  // Succeeds if all of the following are true:
  // - the pSize pointer is valid.
  //
  // If this method fails nothing will be written to *pSize.
  //
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  //
  // 
  HRESULT GetSummaryBufferSize (
    // required buffer size
    [out] aafUInt32 *  pSize);

  //***********************************************************
  //
  // SetSummary()
  //
  // Sets the AIFC file information.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer
  // 
  // If this method fails the summary property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  // 
  HRESULT SetSummary (
    // Size of preallocated buffer
    [in] aafUInt32  size,

    // buffer containing value
    [in, size_is(size)] aafDataValue_t  pSummary);


}



// ************************
//
// Interface IAAFClassDef
//
// ************************
//
// This interface is used with an object representing an AAF class
// definition.  The operations on a class definition include managing
// the position of the class within the class heirarchy, and
// accessing property definitions associated with the class.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFClassDef also implement the following interfaces:
//  - IAAFMetaDefinition

[
    object,
    uuid(dfbd6525-1d81-11d2-bf96-006097116212),
    helpstring("IAAFClassDef Interface"),
    pointer_default(unique)
]
interface IAAFClassDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this class definition object to inherit from the
  // given parent class.  If isConcrete is set to AAFTrue, objects of
  // this class can be instantiated; otherwise, it will be illegal to
  // instantiate such objects.
  // 
  // Succeeds if:
  // - The pID pointer is valid.
  // - The pParentClass pointer is valid.
  // - The pTypeName pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pID, pParentClass, or pTypeName arg is NULL.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  classID,

    // existing class from which this one inherits
    [in] IAAFClassDef * pParentClass,

    // friendly name of this type definition
    [in, string] aafCharacter_constptr  pClassName,

    // can objects of this class be instantiated
    [in] aafBoolean_t  isConcrete);


  //***********************************************************
  //
  // GetPropertyDefs()
  //
  // Returns an enumerator over all of the aaf property definitions
  // attached to the current class.
  // 
  // Succeeds if:
  // - The ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT GetPropertyDefs (
    // Property Definition enumeration
    [out, retval] IEnumAAFPropertyDefs ** ppEnum);


  //***********************************************************
  //
  // CountPropertyDefs()
  //
  // Returns number of property definitions in this class.
  // 
  // Succeeds if:
  // - The pCount pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  // 
  HRESULT CountPropertyDefs (
    // number of properties contained in this class definition
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // RegisterNewPropertyDef()
  //
  // Creates a new property definition and registers it in this class
  // definition.  If ppPropDef is non-NULL, will return the new
  // property definition in ppPropDef.
  // 
  // Note that it is illegal to add mandatory properties to an
  // existing (registered) class.  This method will allow adding
  // either optional or mandatory properties to a class, but they must
  // be added to a class which has not yet been registered in the
  // dictionary.  If this class has already been registered, it is
  // possible to add optional properties, but not through this
  // method.  Optional properties added to an existing (registered)
  // class may be added through the RegisterOptionalPropertyDef()
  // method.
  // 
  // Succeeds if:
  // - The pID pointer is valid.
  // - The pName pointer is valid.
  // - The pTypeDef pointer is valid.
  // - This class has not already been registered in the dictionary.
  // - The auid specified by pID has not already been registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pName or pTypeDef arg is NULL.
  //
  // AAFRESULT_OBJECT_ALREADY_ATTACHED
  //   - This class has already been registered.
  //
  // AAFRESULT_ALREADY_UNIQUELY_INDENTIFED
  //   - This class already has a unique indentifier property.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given ID has already been registered.
  // 
  HRESULT RegisterNewPropertyDef (
    // auid to be used to identify this property
    [in, ref] aafUID_constref  id,

    // name of the new property
    [in, string] aafCharacter_constptr  pName,

    // type of the new property
    [in] IAAFTypeDef * pTypeDef,

    // true if new property is to be optional
    [in] aafBoolean_t  isOptional,

    // true if new property is to be the unique identifier of the class
    [in] aafBoolean_t  isUniqueIdentifier,

    // return pointer to newly created property def
    [out] IAAFPropertyDef ** ppPropDef);


  //***********************************************************
  //
  // RegisterOptionalPropertyDef()
  //
  // Creates a new property definition and registers it in this class
  // definition.  If ppPropDef is non-NULL, will return the new
  // property definition in ppPropDef.
  //
  // Note that it is illegal to add mandatory properties to an already
  // existing (registered) class.  It is assumed that this property is
  // being added to a class which is already registered.  If so, it
  // must be optional and this method will declare it so.  If it is
  // wished to add a mandatory property, that may be done through the
  // RegisterNewPropertyDef() method, but that must be called on a class
  // which is not yet registered.
  // 
  // Succeeds if:
  // - The pID pointer is valid.
  // - The pName pointer is valid.
  // - The pTypeDef pointer is valid.
  // - The auid specified by pID has not already been registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pName or pTypeDef arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given ID has already been registered.
  // 
  HRESULT RegisterOptionalPropertyDef (
    // auid to be used to identify this property
    [in, ref] aafUID_constref  id,

    // name of the new property
    [in, string] aafCharacter_constptr  pName,

    // type of the new property
    [in] IAAFTypeDef * pTypeDef,

    // return pointer to newly created property def
    [out] IAAFPropertyDef ** ppPropDef);


  //***********************************************************
  //
  // LookupPropertyDef()
  //
  // Looks up the property definition corresponding to the named auid
  // and returns a pointer to that property definition in ppPropDef.
  // 
  // Succeeds if:
  // - The pPropID pointer is valid.
  // - The ppPropDef pointer is valid.
  // - the auid specified by pID has been registered as a property
  //   definition for this class definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropDef arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given ID has not been registered as a property
  //     definition.
  // 
  HRESULT LookupPropertyDef (
    // auid reprepresenting property to look up
    [in, ref] aafUID_constref  propID,

    // resulting property definition
    [out] IAAFPropertyDef ** ppPropDef);


  //***********************************************************
  //
  // GetName()
  //
  // Gets Accesses a human-readable name for the class.  This name is not
  // meant to be a way for programs to refer to the class, as it is
  // of undetermined length, and is not checked to guarantee
  // uniqueness.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  // 
  HRESULT GetName (
    // buffer into which Name is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pName,

    // size of *pName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetParent()
  //
  // Gets the Parent class for this object.  If there is no parent,
  // returns the result AAFRESULT_NO_PARENT.  The only class which has no parent will
  // be AAFObject.
  // 
  // Succeeds if:
  // - The ppClassDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pClassDef arg is NULL.
  // 
  HRESULT GetParent (
    // parent class definition
    [out, retval] IAAFClassDef ** ppClassDef);


  //***********************************************************
  //
  // IsConcrete()
  //
  // Returns true if this class can be instantiated; returns false
  // otherwise. 
  // 
  // Succeeds if:
  // - The ppClassDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT IsConcrete (
    // Can this class be instantiated
    [out, retval] aafBoolean_t*  pResult);


  //***********************************************************
  //
  // IsRoot()
  //
  // Returns true if this class is the base of the inheritance
  // hierarchy; returns false otherwise.
  // 
  // Succeeds if:
  // - The ppClassDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - isRoot arg is NULL.
  // 
  HRESULT IsRoot (
    // Is this a root (base) class
    [out, retval] aafBoolean_t*  isRoot);


  //***********************************************************
  //
  // IsUniquelyIdentified()
  //
  // Returns true if this class is uniquely identified.
  // 
  // Succeeds if:
  // - The pIsUniquelyIdentified pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsUniquelyIdentified arg is NULL.
  // 
  HRESULT IsUniquelyIdentified (
    // Is this a UniquelyIdentified class
    [out, retval] aafBoolean_t*  pIsUniquelyIdentified);


  //***********************************************************
  //
  // GetUniqueIdentifier()
  //
  // Returns the property definition corresponding to this class'
  // unique identifier.
  // 
  // Succeeds if:
  // - The ppUniqueIdentifier pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppUniqueIdentifier arg is NULL.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - If this class definition does not have a unique identifier
  //     property definition.
  // 
  HRESULT GetUniqueIdentifier (
    // The unique identifier
    [out, retval] IAAFPropertyDef ** ppUniqueIdentifier);


  //***********************************************************
  //
  // CreateInstance()
  //
  // Creates an object of this class, and returns it by reference in
  // the location specified by the ppObject argument.
  // 
  // Succeeds if:
  // - The ppObject pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppObject arg is NULL. 
  // 
  HRESULT CreateInstance(
    // Reference to the identifier of the interface
    [in, ref] REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    [out, iid_is(riid)] IUnknown ** ppvObject);

}



// ************************
//
// Interface IAAFCodecDef
//
// ************************
//
// This interface is used with an object representing a particular
// kind of essence codec, which may be implemented by one or more
// AAFPluginDescriptors.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFCodecDef also implement the following interfaces:
//  - IAAFDefObject
//  - IAAFObject

[
    object,
    uuid(AD1BB856-DBB2-11d2-809C-006008143E6F),
    helpstring("IAAFCodecDef Interface"),
    pointer_default(unique)
]
interface IAAFCodecDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new DefObject
    [in, string] aafCharacter_constptr  pName,

    // Description for new DefObject
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // IsEssenceKindSupported()
  //
  // Returns AAFTrue if the given codec support transfers to essence
  // of the given essence kind.
  // 
  // Succeeds if all of the following are true:
  // - the pEssenceKind pointer is valid.
  // - the pIsSupported pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsSupported.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceKind or pIsSupported is null.
  // 
  HRESULT IsEssenceKindSupported (
    // The essence kind
    [in] IAAFDataDef * pEssenceKind,

    // Is this type supported
    [out,retval] aafBoolean_t*  pIsSupported);

 
  //***********************************************************
  //
  // AddEssenceKind()
  //
  // Appends the given essence kind to those supported by the codec.
  // This is dependant upon the format, not an incomplete implementation.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceKind is null.
  //
  // AAFRESULT_DUPLICATE_ESSENCE_KIND
  //   - the given essenceKind is already contained.
  // 
  HRESULT AddEssenceKind (
    // The essence kind
    [in] IAAFDataDef * pEssenceKind);


  //***********************************************************
  //
  // RemoveEssenceKind()
  //
  // Removes the given essence kind from the list of those supported
  // by the codec.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceKind is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given essenceKind is not already contained.
  // 
  HRESULT RemoveEssenceKind (
    // The essence kind to remove
    [in] IAAFDataDef * pEssenceKind);


  //***********************************************************
  //
  // CountEssenceKinds()
  //
  // Places the number of supported essence kinds into *pResult.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is NULL.
  // 
  HRESULT CountEssenceKinds (
    // The number of essence kinds
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetEssenceKinds()
  //
  // Places an IEnumAAFDataDefs enumerator for the essence kinds
  // contained in the sequence into the *ppEnum argument.
  // 
  // The returned enumerator is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // E_FAIL
  //   - Failed to create the enumerator.
  // 
  HRESULT GetEssenceKinds (
    // Essence Kind Enumeration
    [out, retval] IEnumAAFDataDefs ** ppEnum);


  //***********************************************************
  //
  // AreThereFlavours()
  //
  // Find out whether its worth iterating over flavours.  Flavours are
  // used when a single codec can support multiple formats.  An
  // example would be a codec which would accept a "resolution ID"
  // for a particular manufacturer and set up all of the parameters.
  // When a new resolution ID is released, then a new codec plugin
  // would give users the ability to use the new resolutions without
  // upgrading the application.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - if Result is null.
  // 
  HRESULT AreThereFlavours (
    // True if there are flavours of this codec
    [out,retval] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // GetFileDescriptorClass()
  //
  // Places the file descriptor class object associated with this
  // codec into the *ppClass argument.  If none exists yet, NULL is
  // placed into the*ppClass argument.
  //
  // The returned class object, if it exists, is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppClass pointer is valid.
  // - A valid file descriptor class exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppClass is null.
  // 
  HRESULT GetFileDescriptorClass (
    // Returned file descriptor class object
    [out] IAAFClassDef ** ppClass);


  //***********************************************************
  //
  // SetFileDescriptorClass()
  //
  // Sets the file descriptor class associated with this codec to be
  // the given one. 
  //
  // Succeeds if all of the following are true:
  // - the pClass pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pClass is null.
  // 
  HRESULT SetFileDescriptorClass (
    // File descriptor class object
    [in] IAAFClassDef * pClass);


  //***********************************************************
  //
  // EnumCodecFlavours()
  //
  // Places an enumerator for codec flavour into the *ppEnum argument.
  // The returned enumerator is AddRef()ed before it is returned.
  // 
  // Flavours are used when a single codec can support multiple
  // formats.  An example would be a codec which would accept a
  // "resolution ID" for a particular manufacturer and set up all of
  // the parameters.  When a new resolution ID is released, then a
  // new codec plugin would give users the ability to use the new
  // resolutions without upgrading the application.
  //
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - if ppEnum is null.
  // 
  HRESULT EnumCodecFlavours (
    // Codec flavour Enumeration
    [out,retval] IEnumAAFCodecFlavours ** ppEnum);
  
}



// ************************
//
// Interface IAAFCommentMarker
//
// ************************

//
// The IAAFCommentMarker interface is implemented by objects which represent
// a user comment associated with a point in time. A CommentMarker may
// have a SourceReference that specifies a text or audio annotation.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFMobSlot is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
// 
//


//
// Objects that implement IAAFCommentMarker also implement the following interfaces:
//  - IAAFEvent
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(e684d78a-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFCommentMarker Interface"),
    pointer_default(unique)
]
interface IAAFCommentMarker : IUnknown
{


  //***********************************************************
  //
  // GetAnnotation()
  //
  // This method will get the annotation for this comment marker and place an
  // interface for it into the **ppResult argument. 
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT GetAnnotation (
    // Annotation property value
    [out,retval] IAAFSourceReference ** ppResult);

  //***********************************************************
  //
  // SetAnnotation()
  //
  // This method will set the Annotation for this comment marker.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetAnnotation (
    // Annotation property value
    [in] IAAFSourceReference * pAnnotation);

}



// ************************
//
// Interface IAAFComponent
//
// ************************
//
// The component class represents an essence element.  A Component is
// an abastract class with two subclasses: Segment and Transition.
// The GetLength and SetLength only aplies to time-varying media and
// it is an  optional property. Non time-varying objects DO NOT
// support this property.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFComponent is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFComponent also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(38e6f8a1-2a2c-11d2-8411-00600832acb8),
    helpstring("IAAFComponent Interface"),
    pointer_default(unique)
]
interface IAAFComponent : IUnknown
{

  //***********************************************************
  //
  // SetLength()
  //
  // Sets the length property value on this component object.
  // 
  // Succeeds if all of the following are true:
  // - the optional length property is present for this object.
  //
  // This method deals with an optional property, which will only be
  // present for time-varying media.
  // 
  // If this method fails the length property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_BAD_PROP
  //   - the optional length property is not present for this object.
  // 
  HRESULT SetLength (
    // The duration in edit units of this component
    [in] aafLength_constref  length);


  //***********************************************************
  //
  // GetLength()
  //
  // Gets the duration in edit units of this component.
  //	
  // Succeeds if all of the following are true:
  // - the pLength pointer is valid.
  // - the optional length property is present for this object.
  //
  // This method deals with an optional property, which will only be
  // present for time-varying media.
  // 
  // If this method fails nothing will be written to *pLength.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLength arg is NULL.
  //
  // AAFRESULT_BAD_PROP
  //   - the optional length property is not present for this object.
  // 
  HRESULT GetLength (
    // Length of this component
    [retval][out] aafLength_t *  pLength);
	

  //***********************************************************
  //
  // SetDataDef()
  //
  // sets the data definition property AUID on this component.
  // 
  // If this method fails the Data Definition property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef arg is NULL.
  // 
  HRESULT SetDataDef (
    // DataDef of this object
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // GetDataDef()
  //
  // returns data definition object.
  //
  // Succeeds if all of the following are true:
  // - the ppDatadef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppDatadef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDatadef arg is NULL.
  // 
  HRESULT GetDataDef (
    // DataDef of this object
    [out, retval] IAAFDataDef ** ppDatadef);

  //***********************************************************
  //
  // AppendKLVData()
  //
  // Appends a pre-existing KLV Data object to the specified
  // component.
  // 
  // Succeeds if all of the following are true:
  // - the pKLV pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pData arg is NULL.
  // 
  HRESULT AppendKLVData (
    // KLV object
    [in] IAAFKLVData * pData);


  //***********************************************************
  //
  // CountKLVData()
  //
  // return total number of KLV data objects attached to this component.
  //
  // Succeeds if all of the following are true:
  // - the pNumData pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumComments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumData arg is NULL.
  // 
  HRESULT CountKLVData (
    // Number  of KLV data objects
    [out] aafUInt32 *  pNumData);


  //***********************************************************
  //
  // GetKLVData()
  //
  // return the enumeration for all KLV data objects on this component.  The returned
  // enumerator is AddRef()ed before it is returned.  The enumerator
  // is implemented as a EnumAAFKLVData.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetKLVData (
    // KLV data objects
    [out] IEnumAAFKLVData ** ppEnum);


  //***********************************************************
  //
  // RemoveKLVData()
  //
  // // Removes the given KLV data object from this component.
  // 
  // Succeeds if all of the following are true:
  // - the pData pointer is valid.
  // - the given KLV data object is present in the component.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pData is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given KLV data object is not in this component.
  // 
  HRESULT RemoveKLVData (
    // KLV data object to remove
    [in] IAAFKLVData * pData);

}



// ************************
//
// Interface IAAFCompositionMob
//
// ************************
//
// The IAAFCompositionMob interface is implemented on objects which
// can specify how to combine content data elements into a sequence,
// how to modify content data elements, and how to synchronize content
// data elements.	   
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFCompositionMob also implement the following interfaces:
//  - IAAFMob
//  - IAAFObject

[
    object,
    uuid(91920d63-2a2e-11D2-bfA3-006097116212),
    helpstring("IAAFCompositionMob Interface"),
    pointer_default(unique)
]
interface IAAFCompositionMob : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this object with the given name.
  // 
  // Succeeds if all of the following are true:
  // - this object has not yet been initialized.
  // - the pName pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName argument is NULL.
  // 
  HRESULT Initialize (
    // Mob name [optional]
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetDefaultFade()
  //
  // Get the default fade for this composition.  If there is no
  // default fade, this function returns with no error, but the VALID
  // field of the structure is false.  This allows you to pass this
  // struct to SourceClip::GetFade() in all cases.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult argument is NULL.
  // 
  HRESULT GetDefaultFade (
    // a default fade struct
    [out] aafDefaultFade_t *  pResult);
	

  //***********************************************************
  //
  // SetDefaultFade()
  //
  // Adds the default crossfade properties to the Mob.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //   - invalid fadeType.
  //
  // AAFRESULT_BAD_LENGTH
  //   - invalid fadeLength.
  // 
  HRESULT SetDefaultFade (
    // Default fade length
    [in] aafLength_t  fadeLength,

    // default fade type
    [in] aafFadeType_t  fadeType,

    // default fade edit unit
    [in] aafRational_t  fadeEditUnit);
}



// ************************
//
// Interface IAAFConstantValue
//
// ************************
//
// The IAAFConstantValue interface is implemented by objects that
// specify a parameter whose value is constant for an entire operation
// group.  Use IAAFVaryingValue and one or more IAAFControlPoints for
// parameters which change in value during the operation group.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFConstantValue also implement the following interfaces:
//  - IAAFParameter
//  - IAAFObject

[
    object,
    uuid(b8ddc080-2afa-11D2-bfA5-006097116212),
    helpstring("IAAFConstantValue Interface"),
    pointer_default(unique)
]
interface IAAFConstantValue : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new constant value object to be identified with the
  // given the given type, and with the given human-legible name.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pParameterDef and pValue are a valid pointers.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pParameterDef or pValue arg is NULL.
  // 
  // 
  HRESULT Initialize (
    // Parameter definition for this object (this determines the type of the constant value)
    [in] IAAFParameterDef * pParameterDef,

    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // buffer containing value
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);


  //***********************************************************
  //
  // GetValue()
  //
  // Writes the value into the pValue buffer.  The buffer is allocated
  // by the caller, and the size of the buffer is given by
  // valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the
  //   name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the
  //     value.
  // 
  HRESULT GetValue (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // Preallocated buffer to hold value
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  pValue,

    // Number of actual bytes read
    [out] aafUInt32*  bytesRead);


  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the GetValue()
  // method.  The value is placed into the location specified by
  // pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  // 
  HRESULT GetValueBufLen (
    // Pointer to an variable used to return the length
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Places the type definition of the dataval inside this parameter into the
  // *ppTypeDef argument.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  // 
  HRESULT GetTypeDefinition (
    // Type Definition of the dataval inside of this object
    [out,retval] IAAFTypeDef ** ppTypeDef);

  //***********************************************************
  //
  // SetValue()
  //
  // The data value is set from a buffer of size valueSize and type.
  //
  // Succeeds if all of the following are true:
  // - pTypeDef is valid and registered with the object's dictionary.
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  // 
  HRESULT SetValue (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // buffer containing value
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

}



// ************************
//
// Interface IAAFContainerDef
//
// ************************
//
// This interface is used with an object representing a particular
// kind of essence stream factory object, which may be implemented by
// one or more AAFPluginDescriptors.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFContainerDef also implement the following interfaces:
//  - IAAFDefObject
//  - IAAFObject

[
    object,
    uuid(AD1BB858-DBB2-11d2-809C-006008143E6F),
    helpstring("IAAFContainerDef Interface"),
    pointer_default(unique)
]
interface IAAFContainerDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new DefObject
    [in, string] aafCharacter_constptr  pName,

    // Description for new DefObject
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // EssenceIsIdentified()
  //
  // Tells whether the given plugin is capable of supporting
  // authentication.  The methods for authenticating a plugin are
  // still <tbd>.
  // 
  // Succeeds if all of the following are true:
  // - the pEssenceIsIdentified pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pEssenceIsIdentified.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceIsIdentified arg is NULL.
  // 
  HRESULT EssenceIsIdentified (
    // The EssenceIsIdentified
    [out] aafBoolean_t *  pEssenceIsIdentified);


  //***********************************************************
  //
  // SetEssenceIsIdentified()
  //
  // Tells whether the given plugin is capable of supporting
  // authentication.  The methods for authenticating a plugin are
  // still <tbd>.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetEssenceIsIdentified (
    // The EssenceIsIdentified flag
    [in] aafBoolean_t  EssenceIsIdentified);
}



// ************************
//
// Interface IAAFContentStorage
//
// ************************


//
// Objects that implement IAAFContentStorage also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(54D4C482-5F8B-11d2-8073-006008143E6F),
    helpstring("IAAFContentStorage Interface"),
    pointer_default(unique)
]


interface IAAFContentStorage : IUnknown
{


  //***********************************************************
  //
  // LookupMob()
  //
  // Looks up the Mob that matches the given mob id and puts it into
  // the ppMob argument.  The returned mob interface is AddRef()ed
  // before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppMob pointer is valid.
  // 
  // If this method fails nothing will be written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob is null
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the requested mob wasn't found.
  // 
  HRESULT LookupMob (
    // The Mob ID
    [in, ref] aafMobID_constref  mobID,

    // Matching Mob
    [out,retval] IAAFMob ** ppMob);


  //***********************************************************
  //
  // CountMobs()
  //
  // Writes the number of matches for the given mob kind into the
  // *pNumMobs argument.
  // 
  // Succeeds if all of the following are true:
  // - the pNumMobs pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumMobs.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumMobs is null.
  // 
  HRESULT CountMobs (
    // The mob kind to count
    [in] aafMobKind_t  mobKind,

    // Total number of mobs of kind mobKind
    [out, retval] aafNumSlots_t *  pResult);


  //***********************************************************
  //
  // GetMobs()
  //
  // Places an enumerator for mobs that apply to the criteria into the
  // *ppEnum argument.  If pSearchCriteria is null, all mobs are
  // returned.   The searchTag field of pSearchCriteria, and exactly
  // ONE of the fields in the union (tags.mobID, tags.name, etc. )
  // must be set.  Only one search criterion may be specified.  The
  // returned enumerator is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetMobs (
    // Search Criteria for enumeration
    [in] aafSearchCrit_t *  pSearchCriteria,

    // Mob Enumeration
    [out, retval] IEnumAAFMobs ** ppEnum);


  //***********************************************************
  //
  // AddMob()
  //
  // Appends the given mob to the header.  If the given mob is already
  // contained this method will do nothing and will return success.
  // 
  // Succeeds if all of the following are true:
  // - the pMob pointer is valid.
  // - the given mob is not already part of this collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMob is null.
  //
  // AAFRESULT_DUPLICATE_MOBID
  //   - the given mob is already contained.
  // 
  HRESULT AddMob (
    // Mob to add
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // RemoveMob()
  //
  // // Removes the given mob from the header.
  //
  // Succeeds if all of the following are true:
  // - the pMob pointer is valid.
  // - the given mob is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMob is null.
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the given mob is not already contained.
  // 
  HRESULT RemoveMob (
    // Mob to remove
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // CountEssenceData()
  //
  // Writes the total number of essence data into the *pNumEssenceData
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pNumEssenceData pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pNumEssenceData.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumEssenceData is null.
  // 
  HRESULT CountEssenceData (
    // Total number of essence data
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  // // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT IsEssenceDataPresent (
    // A Unique File Mob ID
    [in, ref] aafMobID_constref  fileMobID,

    // The Essence File Format
    [in] aafFileFormat_t  fmt,

    // True if the essence is found
    [out,retval] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // EnumEssenceData()
  //
  // Places an enumerator for essence that applies to the criteria
  // into the *ppEnum argument.  The returned enumerator is
  // AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the pMediaCriteria pointer is valid.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pMediaCriteria or ppEnum is null.
  // 
  HRESULT EnumEssenceData (
    // Essence Enumeration
    [out,retval] IEnumAAFEssenceData ** ppEnum);


  //***********************************************************
  //
  // AddEssenceData()
  //
  // Appends the given essence data object to the header.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pEssenceData pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_MOBID
  //   - The given mob has already been added.  The validation is done by comparing
  //		mobIDs, which should be unique.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  // 
  HRESULT AddEssenceData (
    // Essence data object to append
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  // // Removes the given EssenceData from the header.
  //
  // Succeeds if all of the following are true:
  // - the pEssenceData pointer is valid.
  // - the given EssenceData is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  //
  // AAFRESULT_ESSENCE_NOT_FOUND
  //   - the given EssenceData is not already contained.
  // 
  HRESULT RemoveEssenceData (
    // EssenceData to remove
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // LookupEssenceData()
  //
  // Looks up the EssenceData that matches the given mob id and puts it into
  // the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  // before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEssenceData pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEssenceData.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEssenceData is null
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the requested EssenceData wasn't found.
  // 
  HRESULT LookupEssenceData (
    // The Mob ID
    [in, ref] aafMobID_constref  mobID,

    // Matching EssenceData
    [out,retval] IAAFEssenceData ** ppEssenceData);

}



// ************************
//
// Interface IAAFControlPoint
//
// ************************
//
// The IAAFControlPoint interface is implemented by objects that store an individual point value
// of a parameter whose value changes during the operation group.  IAAFControlPoints must be added to
// an object which implements IAAFVaryingValue, which is then added to the IAAFOperationGroup.
//
// For parameters which are constant in value during the operation group, use IAAFConstantValue.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFControlPoint also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(86192db1-2a23-11D2-BFa3-006097116212),
    helpstring("IAAFControlPoint Interface"),
    pointer_default(unique)
]
interface IAAFControlPoint : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new control point object to be 
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pVaryingValue is a valid pointer.
  // - time is a valid rational.
  // - pValue is a valid pointer
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName or pValue arg is NULL.
  // 
  // 
  HRESULT Initialize (
    // A varying value (this determines the type of this control point through the parameter definition)
    [in] IAAFVaryingValue * pVaryingValue,

    // Control Point time
    [in] aafRational_constref  time,

    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // buffer containing value
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

  //***********************************************************
  //
  // GetTime()
  //
  // Returns the position of the control point within an operation group, expressed as a rational
  // running from 0 to 1.
  // 
  // Succeeds if all of the following are true:
  // - the pTime pointer is valid.
  // 
  // If this method fails nothing will be written to *pTime.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTime arg is NULL.
  // 
  HRESULT GetTime (
    // Pointer to an aafRational_t
    [out,retval] aafRational_t *  pTime);

  //***********************************************************
  //
  // GetEditHint()
  //
  // Returns the edit hint of the control point, which describes how to alter the
  // position if the AAFOperationGroup is made longer or shorter.
  //
  // Succeeds if all of the following are true:
  // - the pEditHint pointer is valid.
  // 
  // If this method fails nothing will be written to *pEditHint.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditHint arg is NULL.
  // 
  HRESULT GetEditHint (
    // Pointer to an aafEditHint_t
    [out,retval] aafEditHint_t *  pEditHint);

  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the GetValue() method.
  // The value is placed into the location specified by pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  // 
  HRESULT GetValueBufLen (
    // Pointer to an variable used to return the length
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // GetValue()
  //
  // Writes the value into the pValue buffer.  The buffer is allocated by the caller,
  // and the size of the buffer is given by valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  // 
  HRESULT GetValue (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // Preallocated buffer to hold value
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  pValue,

    // Number of actual bytes read
    [out] aafUInt32*  bytesRead);

  //***********************************************************
  //
  // SetTime()
  //
  // Sets the position of the control point within an operation group, expressed as a rational
  // running from 0 to 1.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetTime (
    // Control Point time
    [in] aafRational_t  pTime);

  //***********************************************************
  //
  // SetEditHint()
  //
  // Sets the control point Edit hint value, which describes how to alter the
  // position if the AAFOperationGroup is made longer or shorter.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetEditHint (
    // Control Point Edit hint
    [in] aafEditHint_t  editHint);

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Places the type definition of the dataval inside this parameter into the
  // *ppTypeDef argument.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  // 
  HRESULT GetTypeDefinition (
    // Type Definition of the dataval inside of this object
    [out,retval] IAAFTypeDef ** ppTypeDef);

  //***********************************************************
  //
  // SetValue()
  //
  // The data value is set from a buffer of size valueSize and type.
  //
  // Succeeds if all of the following are true:
  // - pTypeDef is valid and registered with the object's dictionary.
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  // 
  HRESULT SetValue (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // buffer containing value
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

}




// ************************
//
// Interface IAAFDataDef
//
// ************************


//
// Objects that implement IAAFDataDef also implement the following interfaces:
//  - IAAFDefObject
//  - IAAFObject

[
    object,
    uuid(dfbd6529-1d81-11d2-bf96-006097116212),
    helpstring("IAAFDataDef Interface"),
    pointer_default(unique)
]
interface IAAFDataDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new DefObject
    [in, string] aafCharacter_constptr  pName,

    // Description for new DefObject
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // IsPictureKind()
  //
  // Sets return value to TRUE if DataDef is a picture.
  // 
  HRESULT IsPictureKind (
    // pointer to the return value
    [retval,out] aafBoolean_t *  bIsPictureKind);


  //***********************************************************
  //
  // IsMatteKind()
  //
  // Sets return value to TRUE if DataDef is a matte.
  // 
  HRESULT IsMatteKind (
    // pointer to the return value
    [retval,out] aafBoolean_t *  bIsMatteKind);


  //***********************************************************
  //
  // IsPictureWithMatteKind()
  //
  // Sets return value to TRUE if DataDef is a picture with matte.
  // 
  HRESULT IsPictureWithMatteKind (
    // pointer to the return value
    [retval,out] aafBoolean_t *  bIsPictureWithMatteKind);


  //***********************************************************
  //
  // IsSoundKind()
  //
  // Sets return value to TRUE if DataDef is a sound.
  // 
  HRESULT IsSoundKind (
    // pointer to the return value
    [retval,out] aafBoolean_t *  bIsSoundKind);


  //***********************************************************
  //
  // DoesDataDefConvertTo()
  //
  // Sets return value to TRUE if the DataDef of the given object
		   // can be converted to the DataDef specified in the IN 
		   // parameter with the DataDefName string.
  // 
  HRESULT DoesDataDefConvertTo (
    // data def to compare against
    [in] IAAFDataDef * id,

    // pointer to result
    [retval, out] aafBoolean_t *  bDoesConvertTo);
		   

  //***********************************************************
  //
  // IsDataDefOf()
  //
  // Sets the value to TRUE if the DataDef of the given object
  // matches the DataDef specified in the IN parameter with the
  // DataDefName string.
  // 
  HRESULT IsDataDefOf (
    // data def to compare against
    [in] IAAFDataDef * pDataDef,

    // pointer to result
    [retval, out] aafBoolean_t *  bIsDataDefOf);


  //***********************************************************
  //
  // DoesDataDefConvertFrom()
  //
  // Sets return value to TRUE if the DataDef of the given object
  // can be converted from the DataDef specified in the IN 
  // parameter specified with the DataDefName string.
  // 
  HRESULT DoesDataDefConvertFrom (
    // data def to compare against
    [in] IAAFDataDef * pDataDef,

    // pointer to result
    [retval, out] aafBoolean_t *  bDoesConvertFrom);
}



// ************************
//
// Interface IAAFDefObject
//
// ************************
//
// This interface is defines an item to be referenced in the AAF file.
// It specifies the AUID unique identifier used to define types used
// in AAF persistent objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFObject is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.


//
// Objects that implement IAAFDefObject also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(dfbd6527-1d81-11d2-bf96-006097116212),
    helpstring("IAAFDefObject Interface"),
    pointer_default(unique)
]
interface IAAFDefObject : IUnknown
{

  //***********************************************************
  //
  // SetName()
  //
  // Sets the Name of this definition.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  // 
  HRESULT SetName (
    // buffer from which Name is to be read
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Name of this definition.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  // 
  HRESULT GetName (
    // buffer into which Name is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pName,

    // size of *pName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetDescription()
  //
  // Sets the Description of this definition.
  //
  // Set the Description property to the value specified in
  // pDescription.  A copy is made of the data so the caller
  // retains ownership of the *pDescription buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pDescription pointer is valid.
  // 
  // If this method fails the Description property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  // 
  HRESULT SetDescription (
    // buffer from which Description is to be read
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetDescription()
  //
  // Gets the Description of this definition.
  // 
  // Writes the Description property, with a trailing null
  // character, into the pDescription buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Description property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetDescriptionBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pDescription.
  // 
  // Succeeds if:
  // - The pDescription pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Description.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Description.
  // 
  HRESULT GetDescription (
    // buffer into which Description is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pDescription,

    // size of *pDescription buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  // Returns size of buffer (in bytes) required for GetDescription().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetDescriptionBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new DefObject
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetAUID()
  //
  // Gets the AUID for this object.
  // 
  HRESULT GetAUID (
    // Pointer to an AUID reference
    [retval,out] aafUID_t *  pAuid);

}



// ************************
//
// Interface IAAFPluginDef
//
// ************************
//
// An object which describes a particular implementation of a plug-in
// interface.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFPluginDef also implement the following interfaces:
//  - IAAFDefObject
//  - IAAFObject

[
    object,
    uuid(AD1BB854-DBB2-11d2-809C-006008143E6F),
    helpstring("IAAFPluginDef Interface"),
    pointer_default(unique)
]
interface IAAFPluginDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new DefObject
    [in] aafCharacter_constptr  pName,

    // Description for new DefObject
    [in] aafCharacter_constptr  pDescription);

  //***********************************************************
  //
  // GetCategoryClass()
  //
  // Obtains the Category Class, which is identifies the stored
  // classID of the subclass of AAFPluggableDefinition which
  // references this plugin descriptor.  This ID is written into the
  // caller-allocated aafUID_t specified by the pCategoryClass
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pCategoryClass pointer is valid.
  // 
  // If this method fails nothing will be written to *pCategoryClass.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCategoryClass arg is NULL.
  // 
  HRESULT GetCategoryClass (
    // The CategoryClass
    [out] aafUID_t *  pCategoryClass);


  //***********************************************************
  //
  // SetCategoryClass()
  //
  // Sets the Category Class, which is identifies the stored classID
  // of the subclass of AAFPluggableDefinition which references this
  // plugin descriptor.
  // 
  // If this method fails the Category Class property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetCategoryClass (
    // The Category Class
    [in, ref] aafUID_constref  categoryClass);


  //***********************************************************
  //
  // GetPluginVersion()
  //
  // Gets the Plugin Version property associated with this plugin
  // descriptor and places it into *pVersion. 
  //
  // Succeeds if all of the following are true:
  // - the pVersion pointer is valid.
  // 
  // If this method fails, nothing will be written to *pVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion arg is NULL.
  // 
  HRESULT GetPluginVersion (
    // The Plugin Version
    [out] aafVersionType_t *  pVersion);


  //***********************************************************
  //
  // SetPluginVersion()
  //
  // Sets the plugin version property of this plugin descriptor.
  //
  // Succeeds if all of the following are true:
  // - pVersion pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion arg is NULL.
  // 
  HRESULT SetPluginVersion (
    // The plugin Version
    [in] aafVersionType_t *  pVersion);


  //***********************************************************
  //
  // SetPluginVersionString()
  //
  // Sets the Plugin Version String property.
  //
  // Set the PluginVersionString property to the value specified in
  // pPluginVersionString.  A copy is made of the data so the caller
  // retains ownership of the *pPluginVersionString buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pPluginVersionString pointer is valid.
  // 
  // If this method fails the PluginVersionString property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginVersionString arg is NULL.
  // 
  HRESULT SetPluginVersionString (
    // buffer from which PluginVersionString is to be read
    [in, string] aafCharacter_constptr  pPluginVersionString);


  //***********************************************************
  //
  // GetPluginVersionString()
  //
  // Gets the Plugin Version String property.
  // 
  // Writes the PluginVersionString property, with a trailing null
  // character, into the pPluginVersionString buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the PluginVersionString property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetPluginVersionStringBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pPluginVersionString.
  // 
  // Succeeds if:
  // - The pPluginVersionString pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   PluginVersionString.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginVersionString arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold PluginVersionString.
  // 
  HRESULT GetPluginVersionString (
    // buffer into which PluginVersionString is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pPluginVersionString,

    // size of *pPluginVersionString buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetPluginVersionStringBufLen()
  //
  // Returns size of buffer (in bytes) required for GetPluginVersionString().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetPluginVersionStringBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetPluginManufacturerName()
  //
  // Sets the Plugin Manufacturer Name string property.
  //
  // Set the PluginManufacturerName property to the value specified in
  // pPluginManufacturerName.  A copy is made of the data so the caller
  // retains ownership of the *pPluginManufacturerName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pPluginManufacturerName pointer is valid.
  // 
  // If this method fails the PluginManufacturerName property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginManufacturerName arg is NULL.
  // 
  HRESULT SetPluginManufacturerName (
    // buffer from which PluginManufacturerName is to be read
    [in, string] aafCharacter_constptr  pPluginManufacturerName);


  //***********************************************************
  //
  // GetPluginManufacturerName()
  //
  // Gets the Plugin Manufacturer Name string property.
  // 
  // Writes the PluginManufacturerName property, with a trailing null
  // character, into the pPluginManufacturerName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the PluginManufacturerName property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetPluginManufacturerNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pPluginManufacturerName.
  // 
  // Succeeds if:
  // - The pPluginManufacturerName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   PluginManufacturerName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginManufacturerName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold PluginManufacturerName.
  // 
  HRESULT GetPluginManufacturerName (
    // buffer into which PluginManufacturerName is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pPluginManufacturerName,

    // size of *pPluginManufacturerName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetPluginManufacturerNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetPluginManufacturerName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetPluginManufacturerNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetManufacturerInfo()
  //
  // This method will get an AAFNetworkLocator pointing to
  // ManufacturerInfo for this plugin and place an interface for the
  // locator into the **ppResult argument.  If a ManufacturerInfo
  // locator exists, the result will be AddRef()ed. If not, the
  // result will be NULL.
  //
  // Succeeds if all of the following are true:
  // - the ppResult pointer is valid.
  // 
  // If this method fails nothing will be written to *ppResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppResult arg is NULL.
  // 
  HRESULT GetManufacturerInfo (
    // ManufacturerInfo property value
    [out, retval] IAAFNetworkLocator ** ppResult);


  //***********************************************************
  //
  // SetManufacturerInfo()
  //
  // This method will set a locator pointing to the location of
  // ManufacturerInfo for this plugin.  If a ManufacturerInfo
  // already exists for this mob slot, it will be discarded.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetManufacturerInfo (
    // ManufacturerInfo property value
    [in] IAAFNetworkLocator * pManufacturerInfo);


  //***********************************************************
  //
  // GetManufacturerID()
  //
  // Obtains the manufacturer ID, which is identifies the manfacturer
  // of this plugin.  This ID is written into the caller-allocated
  // aafUID_t specified by the pManufacturerID argument.
  // 
  // Succeeds if all of the following are true:
  // - the pManufacturerID pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pManufacturerID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pManufacturerID arg is NULL.
  // 
  HRESULT GetManufacturerID (
    // The ManufacturerID
    [out] aafUID_t *  pManufacturerID);


  //***********************************************************
  //
  // SetManufacturerID()
  //
  // Sets the manufacturer ID, which is identifies the manufacturer
  // of this plugin.
  // 
  // If this method fails the ManufacturerID property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetManufacturerID (
    // The Category Class
    [in, ref] aafUID_constref  manufacturerID);


  //***********************************************************
  //
  // GetHardwarePlatform()
  //
  // Obtains the hardware platform ID, which identifies the hardware
  // platform which is required to use this plugin.  This ID is
  // written into the caller-allocated variable specified by the
  // pHardwarePlatform argument. The type aafHardwarePlatform_t is an
  // extensible enumerated type, and the value given must be either
  // standard or in the type dictionary.
  // 
  // Succeeds if all of the following are true:
  // - the pHardwarePlatform pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pHardwarePlatform.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pHardwarePlatform arg is NULL.
  // 
  HRESULT GetHardwarePlatform (
    // The HardwarePlatform
    [out] aafHardwarePlatform_t *  pHardwarePlatform);


  //***********************************************************
  //
  // SetHardwarePlatform()
  //
  // Sets the hardware platform ID, which identifies the hardware
  // platform which is required to use this plugin.  The type
  // aafHardwarePlatform_t is an extensible enumerated type, and the
  // value given must be either standard or in the type dictionary.
  // 
  // If this method fails the HardwarePlatform property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetHardwarePlatform (
    // The Category Class
    [in] aafHardwarePlatform_constref  hardwarePlatform);


  //***********************************************************
  //
  // GetPlatformVersionRange()
  //
  // Gets the minimum and maximum platform Version properties
  // associated with this plugin descriptor and places it into
  // *pMinVersion, and *pMaxVersion.  These are the minimum and
  // maximum versions of the platform for which this plugin will
  // function.
  //
  // Succeeds if all of the following are true:
  // - both pMinVersion and pMaxVersion pointers are valid.
  // 
  // If this method fails, nothing will be written to *pMinVersion or
  // *pMaxVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pMinVersion or pMaxVersion arg is NULL.
  // 
  HRESULT GetPlatformVersionRange (
    // The Minimum Platform Version
    [out] aafVersionType_t *  pMinVersion,

    // The Maximum Platform Version
    [out] aafVersionType_t *  pMaxVersion);


  //***********************************************************
  //
  // SetPlatformMinimumVersion()
  //
  // Sets the maximum platform Version property of this plugin
  // descriptor.  This is the minimum version of the platform for
  // which this plugin will function.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetPlatformMinimumVersion (
    // The Minimum Platform Version
    [in] aafVersionType_constref  minVersion);


  //***********************************************************
  //
  // SetPlatformMaximumVersion()
  //
  // Sets the maximum platform Version properties associated with this
  // plugin descriptor.  This is the maximum version of the platform
  // for which this plugin will function.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetPlatformMaximumVersion (
    // The Maximum Platform Version
    [in] aafVersionType_constref  maxVersion);


  //***********************************************************
  //
  // GetEngine()
  //
  // Obtains the software engine ID, which identifies the software
  // subsystem used for essence management and playback used by the
  // plugin.  This ID is written into the caller-allocated variable
  // specified by the pHardwarePlatform argument.  The type
  // aafEngine_t is an extensible, enumerated type, and the value
  // given must be either standard or in the type dictionary.
  // 
  // Succeeds if all of the following are true:
  // - the pHardwarePlatform pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pHardwarePlatform.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEngine arg is NULL.
  // 
  HRESULT GetEngine (
    // The software engine
    [out] aafEngine_t *  pEngine);


  //***********************************************************
  //
  // SetEngine()
  //
  // Sets the software engine ID, which identifies the software
  // subsystem used for essence management and playback used by the
  // plugin.  The type aafEngine_t is an extensible enumerated type,
  // and the value given must be either standard or in the type
  // dictionary.
  // 
  // If this method fails the engine property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetEngine (
    // The software engine
    [in] aafEngine_constref  engine);


  //***********************************************************
  //
  // GetEngineVersionRange()
  //
  // Gets the minimum and maximum engine Version properties of the
  // engine which is associated with this plugin and places it into
  // *pMinVersion, and *pMaxVersion.  These are the minimum and
  // maximum versions of the engine for which this plugin will
  // function.
  //
  // Succeeds if all of the following are true:
  // - both pMinVersion and pMaxVersion pointers are valid.
  // 
  // If this method fails, nothing will be written to *pMinVersion or
  // *pMaxVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pMinVersion or pMaxVersion arg is NULL.
  // 
  HRESULT GetEngineVersionRange (
    // The Minimum Engine Version
    [out] aafVersionType_t *  pMinVersion,

    // The Maximum Engine Version
    [out] aafVersionType_t *  pMaxVersion);


  //***********************************************************
  //
  // SetEngineMinimumVersion()
  //
  // Sets the minimum engine Version property to the minimum useful
  // version of the engine which is associated with this plugin.  This
  // is the minimum version of the engine for which this plugin will
  // function.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetEngineMinimumVersion (
    // The Minimum Engine Version
    [in] aafVersionType_constref  minVersion);


  //***********************************************************
  //
  // SetEngineMaximumVersion()
  //
  // Sets the minimum engine Version property to the maximum useful
  // version of the engine which is associated with this plugin.  This
  // is the maximum version of the engine for which this plugin will
  // function.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetEngineMaximumVersion (
    // The Minimum Engine Version
    [in] aafVersionType_constref  pMaxVersion);


  //***********************************************************
  //
  // GetPluginAPI()
  //
  // Obtains the manufacturer ID Class, which identifies the plugin
  // interface supported by the plugin.  This ID is written into the
  // caller-allocated variable specified by the pPluginAPI argument.
  // The type aafPluginAPI_t is an extensible enumerated type, and
  // the value given must be either standard or in the type
  // dictionary.
  // 
  // Succeeds if all of the following are true:
  // - the pPluginAPI pointer is valid.
  // 
  // If this method fails nothing will be written to *pPluginAPI.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginAPI arg is NULL.
  // 
  HRESULT GetPluginAPI (
    // The PluginAPI
    [out] aafPluginAPI_t *  pPluginAPI);


  //***********************************************************
  //
  // SetPluginAPI()
  //
  // Obtains the manufacturer ID, which identifies the plugin
  // interface supported by the plugin.
  // 
  // The type aafPluginAPI_t is an extensible enumerated type, and
  // the value given must be either standard or in the type dictionary.
  // 
  // If this method fails the PluginAPI property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetPluginAPI (
    // The Category Class
    [in] aafPluginAPI_constref  pluginAPI);


  //***********************************************************
  //
  // GetPluginAPIVersionRange()
  //
  // Gets the minimum and maximum plugin API Version properties of the
  // plugin API which is associated with this plugin descriptor and
  // places it into *pMinVersion, and *pMaxVersion.  These are the
  // minimum and maximum versions of the PluginAPI for which this
  // plugin will function.
  //
  // Succeeds if all of the following are true:
  // - both pMinVersion and pMaxVersion pointers are valid.
  // 
  // If this method fails, nothing will be written to *pMinVersion or
  // *pMaxVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pMinVersion or pMaxVersion arg is NULL.
  // 
  HRESULT GetPluginAPIVersionRange (
    // The Minimum Plugin API Version
    [out] aafVersionType_t *  pMinVersion,

    // The Maximum Plugin API Version
    [out] aafVersionType_t *  pMaxVersion);


  //***********************************************************
  //
  // SetPluginAPIMinimumVersion()
  //
  // Sets the minimum plugin API Version property to the minimum
  // useful version of the plugin API which is associated with this
  // plugin.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetPluginAPIMinimumVersion (
    // The Minimum Plugin API Version
    [out] aafVersionType_constref  minVersion);


  //***********************************************************
  //
  // SetPluginAPIMaximumVersion()
  //
  // Sets the maximum engine Version property to the maximum useful
  // version of the plugin API which is associated with this plugin.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetPluginAPIMaximumVersion (
    // The Maximum Plugin API Version
    [in] aafVersionType_constref  maxVersion);


  //***********************************************************
  //
  // IsSoftwareOnly()
  //
  // Tells whether the given plugin is capable of running in a
  // software-only environment.  A value of AAFTrue indicates that no
  // additional hardware is required.  If the result is AAFTrue, then
  // this plugin may also support hardware acceleration, as long as
  // it also contains a software method of processing the data.
  // 
  // Succeeds if all of the following are true:
  // - the pIsSoftwareOnly pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsSoftwareOnly.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsSoftwareOnly arg is NULL.
  // 
  HRESULT IsSoftwareOnly (
    // The IsSoftwareOnly
    [out] aafBoolean_t *  pIsSoftwareOnly);


  //***********************************************************
  //
  // SetIsSoftwareOnly()
  //
  // Sets whether the given plugin is capable of running in a
  // software-only environment, and returns AAFFalse if any hardware
  // is required.  If isSoftwareOnly is AAFTrue, then this plugin may
  // also support hardware acceleration, as long as it also contains
  // a software method of processing the data.  If this method fails
  // the isSoftwareOnly property will not be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetIsSoftwareOnly (
    // The isSoftwareOnly flag
    [in] aafBoolean_t  isSoftwareOnly);


  //***********************************************************
  //
  // IsAccelerated()
  //
  // Tells whether the given plugin is capable of running with a
  // hardware accelerator.  If the result is AAFTrue, then this
  // plugin may also support software decompression.
  // 
  // Succeeds if all of the following are true:
  // - the pIsAccelerated pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsAccelerated.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsAccelerated arg is NULL.
  // 
  HRESULT IsAccelerated (
    // The IsAccelerated
    [out] aafBoolean_t *  pIsAccelerated);


  //***********************************************************
  //
  // SetIsAccelerated()
  //
  // Tells whether the given plugin is capable of running with a
  // hardware accelerator.  If the result is AAFTrue, then this
  // plugin may also support software decompression.
  //
  // If this method fails the IsAccelerated property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetIsAccelerated (
    // The isAccelerated flag
    [in] aafBoolean_t  isAccelerated);


  //***********************************************************
  //
  // SupportsAuthentication()
  //
  // Tells whether the given plugin is capable of supporting
  // authentication.  The methods for authenticating a plugin are
  // still <tbd>.
  // 
  // Succeeds if all of the following are true:
  // - the pSupportsAuthentication pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pSupportsAuthentication.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSupportsAuthentication arg is NULL.
  // 
  HRESULT SupportsAuthentication (
    // The SupportsAuthentication
    [out] aafBoolean_t *  pSupportsAuthentication);


  //***********************************************************
  //
  // SetSupportsAuthentication()
  //
  // Tells whether the given plugin is capable of supporting
  // authentication.  The methods for authenticating a plugin are
  // still <tbd>.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetSupportsAuthentication (
    // The SupportsAuthentication flag
    [in] aafBoolean_t  SupportsAuthentication);


  //***********************************************************
  //
  // CountLocators()
  //
  // Return the number of locators attached to this plugin descriptor.
  // The number of locators may be zero if the plugin is in the
  // current file.
  // 
  // Succeeds if all of the following are true:
  // - the pCount pointer is valid.
  // 
  // If this method fails nothing is written to *pCount.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount is null.
  // 
  HRESULT CountLocators (
    // Returns the number of locators
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // AppendLocator()
  //
  // Append another locator to this plugin descriptor.  Use this
  // function to add a locator to be scanned last when searching for
  // the plugin (a secondary location for the plugin).
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  // 
  HRESULT AppendLocator (
    // Locator to append
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // PrependLocator()
  //
  // Append another locator to this plugin descriptor.  Use this
  // function to add a locator to be scanned first when searching for
  // the plugin (a new primary location for the plugin).
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  // 
  HRESULT PrependLocator (
    // Locator to append
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // InsertLocatorAt()
  //
  // Insert another locator to this plugin descriptor at the given
  // index.  Locators already existing at the named and higher indices
  // will be moved up to the next higher index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than or equal to the value returned by
  //   CountLocators().
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountLocators().
  // 
  HRESULT InsertLocatorAt (
    // index to insert locator
    [in] aafUInt32  index,

    // Locator to insert
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // GetLocatorAt()
  //
  // Gets the locator which exists in this plugin descriptor at the
  // given index.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the value returned by CountLocators().
  // - the ppLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountLocators().
  // 
  HRESULT GetLocatorAt (
    // index to insert locator
    [in] aafUInt32  index,

    // returned Locator
    [out] IAAFLocator ** ppLocator);


  //***********************************************************
  //
  // RemoveLocatorAt()
  //
  // Removes the locator which exists in this plugin descriptor at the
  // given index.  Locators already existing at indices higher than
  // the named index will be moved down to the next higher index to
  // accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the value returned by CountLocators().
  // - the ppLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountLocators().
  // 
  HRESULT RemoveLocatorAt (
    // index to insert locator
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetLocators()
  //
  // Places an IEnumAAFPluginLocators enumerator for the plugin
  // locators contained in the AAFPluginDescriptor into the *ppEnum
  // argument.
  // 
  // The returned enumerator is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // E_FAIL
  //   - Failed to create the enumerator.
  // 
  HRESULT GetLocators (
    // Plugin Locator Enumeration
    [out, retval] IEnumAAFPluginLocators ** ppEnum);

    //***********************************************************
  //
  // SetDefinitionObjectID()
  //
  // Sets the definition object handled by this plugin.
  // 
  HRESULT SetDefinitionObjectID (
    // AUID of an AAFDefinitionObject
    [in] aafUID_t  pDef);

    //***********************************************************
  //
  // GetDefinitionObjectID()
  //
  // Gets the definition object handled by this plugin.
  // 
  HRESULT GetDefinitionObjectID (
    // AUID of an AAFDefinitionObject
    [retval,out] aafUID_t*  ppDef);

}




// ************************
//
// Interface IAAFDictionary
//
// ************************
//
// This interface is used to access dictionary services in an AAF
// file.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFDictionary also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(B1A21398-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFDictionary Interface"),
    pointer_default(unique)
]
interface IAAFDictionary : IUnknown
{

  //***********************************************************
  //
  // CreateInstance()
  //
  // Creates a single uninitialized AAF object of the class associated 
  // with a specified stored object id. 
  // 
  HRESULT CreateInstance(
    // Class identifier (id) of the stored object. This is the
    // corresponding SMPTE identifier (as a GUID) for all predefined
    // built-in classes.
    [in, ref] aafUID_constref id,

    // Reference to the identifier of the interface
    [in, ref] REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    [out, iid_is(riid)] IUnknown ** ppvObject);


  //***********************************************************
  //
  // CreateMetaInstance()
  //
  // Creates a single uninitialized AAF meta class or type associated 
  // with a specified stored object id. 
  // 
  HRESULT CreateMetaInstance(
    // Identifier (id) of a class or type definition. This is the
    // corresponding SMPTE identifier (as a GUID) for all predefined
    // built-in definitions.
    [in, ref] aafUID_constref id,

    // Reference to the identifier of the interface
    [in, ref] REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    [out, iid_is(riid)] IUnknown ** ppMetaDefinition);


  //***********************************************************
  //
  // RegisterClassDef()
  //
  // Add the class definition object to the dictionary.
  // 
  // Succeeds if:
  // - The pClassDef pointer is valid.
  // - the ID contained in the class def is not already been
  //   registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pClassDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The class def ID has already been registered.
  // 
  HRESULT RegisterClassDef (
    // Class Definition
    [in] IAAFClassDef * pClassDef);


  //***********************************************************
  //
  // LookupClassDef()
  //
  // Return the class definition with the given id.
  // 
  // Succeeds if:
  // - The pClassID pointer is valid.
  // - The ppClassDef pointer is valid.
  // - the ID is a recognized id for a class definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pClassID or ppClassDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a class definition ID.
  // 
  HRESULT LookupClassDef (
    // Class Unique ID
    [in, ref] aafUID_constref  classId,

    // Class Definition
    [out,retval] IAAFClassDef ** ppClassDef);


  //***********************************************************
  //
  // GetClassDefs()
  //
  // Return an enumerator for all class definitions.
  //
  // Succeeds if:
  // - The ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT GetClassDefs (
    // Class Definition Enumeration
    [out,retval] IEnumAAFClassDefs ** ppEnum);


  //***********************************************************
  //
  // CountClassDefs()
  //
  // Writes the number of class definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountClassDefs (
    // Total number of class definition objects
    [out, retval] aafUInt32 *  pResult);

  //***********************************************************
  //
  // CreateForwardClassReference()
  //
  // Return the class definition with the given id.
  // 
  // Succeeds if:
  // - The classId does not represent an existing forward class reference
  //   or a class definition that has already been successfully registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a class definition ID.
  // 
  HRESULT CreateForwardClassReference (
    // Class Unique ID
    [in, ref] aafUID_constref  classId);

  //***********************************************************
  //
  // HasForwardClassReference()
  //
  // Return kAAFTrue if the given class identification is a forward reference.
  // 
  // Succeeds if:
  // - The pClassID pointer is valid.
  // - The ppClassDef pointer is valid.
  // - the ID is a recognized id for a class definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pClassID or ppClassDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a class definition ID.
  // 
  HRESULT HasForwardClassReference (
    // Class Unique ID
    [in, ref] aafUID_constref  classId,

    // true if forward class reference; false if not a forward class reference
    [out,retval] aafBoolean_t *  pResult);

  //***********************************************************
  //
  // RegisterTypeDef()
  //
  // Add the type definition object to the dictionary.
  // 
  // Succeeds if:
  // - The pTypeDef pointer is valid.
  // - the ID is not already been registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pClassDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given type has already been registered.
  // 
  HRESULT RegisterTypeDef (
    // Type Definition Object
    [in] IAAFTypeDef * pTypeDef);


  //***********************************************************
  //
  // LookupTypeDef()
  //
  // Return the type definition object with the given id.
  // 
  // Succeeds if:
  // - The pTypeID pointer is valid.
  // - The ppTypeDef pointer is valid.
  // - the ID is a recognized id for a type definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pTypeID or ppTypeDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a type definition ID.
  // 
  HRESULT LookupTypeDef (
    // Type Unique ID
    [in, ref] aafUID_constref  typeId,

    // Type Definition Object
    [out,retval] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetTypeDefs()
  //
  // Return an enumerator for all type definitions.
  //
  // Succeeds if:
  // - The ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT GetTypeDefs (
    // Type Def Enumeration
    [out,retval] IEnumAAFTypeDefs ** ppEnum);


  //***********************************************************
  //
  // CountTypeDefs()
  //
  // Writes the number of type definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountTypeDefs (
    // Total number of type definition objects
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterOpaqueTypeDef()
  //
  // Add the opaquetype definition object to the dictionary.
  // 
  // Succeeds if:
  // - The pTypeDef pointer is valid.
  // - the definition is not already been registered with RegisterTypeDef.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given type has already been registered.
  // 
  HRESULT RegisterOpaqueTypeDef (
    // Type Definition Object
    [in] IAAFTypeDef * pTypeDef);


  //***********************************************************
  //
  // LookupOpaqueTypeDef()
  //
  // Return the opaque type definition object with the given id.
  // 
  // Succeeds if:
  // - The pTypeID pointer is valid.
  // - The ppTypeDef pointer is valid.
  // - the ID is a recognized id for an opaque type definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either typeId or ppTypeDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a type definition ID.
  // 
  HRESULT LookupOpaqueTypeDef (
    // Type Unique ID
    [in, ref] aafUID_constref  typeId,

    // Type Definition Object
    [out,retval] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetOpaqueTypeDefs()
  //
  // Return an enumerator for all registered opaque type definitions.
  //
  // Succeeds if:
  // - The ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT GetOpaqueTypeDefs (
    // Type Def Enumeration
    [out,retval] IEnumAAFTypeDefs ** ppEnum);


  //***********************************************************
  //
  // CountOpaqueTypeDefs()
  //
  // Writes the number of opaque type definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountOpaqueTypeDefs (
    // Total number of opaque type definition objects
    [out, retval] aafUInt32 *  pResult);

  //***********************************************************
  //
  // RegisterKLVDataKey()
  //
  // Add the definition for the given KLV key to the runtime dictionary.
  // The pTypeDef will often be kAAFTypeID_UInt8Array,
  // but may be something else.  // 
  // Succeeds if:
  // - The pTypeDef pointer is valid.
  // - the definition is not already been registered with RegisterTypeDef.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given type has already been registered.
  // 
  HRESULT RegisterKLVDataKey (
    // Key to define
    [in] aafUID_t  pUID,

    // Type Definition Object
    [in] IAAFTypeDef * pTypeDef);

  //***********************************************************
  //
  // RegisterDataDef()
  //
  // Add the data definition object to the header's list of definitions.
  // 
  HRESULT RegisterDataDef (
    // Data Definition Object
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // LookupDataDef()
  //
  // Return the data definition object with the given id.
  // 
  HRESULT LookupDataDef (
    // Data Definition Unique ID
    [in, ref] aafUID_constref  dataDefinitionId,

    // Data Definition Object
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // GetDataDefs()
  //
  // Return an enumerator for aff data definitions.
  // 
  HRESULT GetDataDefs (
    // Definition Enumeration
    [out,retval] IEnumAAFDataDefs ** ppEnum);


  //***********************************************************
  //
  // CountDataDefs()
  //
  // Writes the number of data definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountDataDefs (
    // Total number of data definition objects
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterOperationDef()
  //
  // Add the operation definition object to the header's list of definitions.
  // 
  HRESULT RegisterOperationDef (
    // Operation Definition Object
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // LookupOperationDef()
  //
  // Return the operation definition object with the given id.
  // 
  HRESULT LookupOperationDef (
    // Operation Def Unique ID
    [in, ref] aafUID_constref  operationId,

    // Operation definition object
    [out,retval] IAAFOperationDef ** ppOperationDef);


  //***********************************************************
  //
  // GetOperationDefs()
  //
  // Return an enumerator for all operation definitions.
  // 
  HRESULT GetOperationDefs (
    // Definition Enumeration
    [out,retval] IEnumAAFOperationDefs ** ppEnum);


  //***********************************************************
  //
  // CountOperationDefs()
  //
  // Writes the number of operation definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountOperationDefs (
    // Total number of operation definition objects
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterParameterDef()
  //
  // Add the parameter definition object to the header's list of definitions.
  // 
  HRESULT RegisterParameterDef (
    // Parameter Definition Object
    [in] IAAFParameterDef * pParmDef);


  //***********************************************************
  //
  // LookupParameterDef()
  //
  // Return the parameter definition object with the given id.
  // 
  HRESULT LookupParameterDef (
    // Parameter Unique ID
    [in, ref] aafUID_constref  parameterId,

    // Parameter definition object
    [out,retval] IAAFParameterDef ** ppParmDef);


  //***********************************************************
  //
  // GetParameterDefs()
  //
  // Return an enumerator for all parameter definitions.
  // 
  HRESULT GetParameterDefs (
    // Definition Enumeration
    [out,retval] IEnumAAFParameterDefs ** ppEnum);


  //***********************************************************
  //
  // CountParameterDefs()
  //
  // Writes the number of parameter definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountParameterDefs (
    // Total number of parameter definition objects
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterCodecDef()
  //
  // Add the codec definition object to the header's list of definitions.
  // 
  HRESULT RegisterCodecDef (
    // Codec Definition Object
    [in] IAAFCodecDef * pParmDef);


  //***********************************************************
  //
  // LookupCodecDef()
  //
  // Return the codec definition object with the given id.
  // 
  HRESULT LookupCodecDef (
    // Parameter Unique ID
    [in, ref] aafUID_constref  parameterId,

    // Codec definition object
    [out,retval] IAAFCodecDef ** ppParmDef);


  //***********************************************************
  //
  // GetCodecDefs()
  //
  // Return an enumerator for all codec definitions.
  // 
  HRESULT GetCodecDefs (
    // Definition Enumeration
    [out,retval] IEnumAAFCodecDefs ** ppEnum);


  //***********************************************************
  //
  // CountCodecDefs()
  //
  // Writes the number of codec definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountCodecDefs (
    // Total number of codec definition objects
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterContainerDef()
  //
  // Add the container definition object to the header's list of definitions.
  // 
  HRESULT RegisterContainerDef (
    // Container Definition Object
    [in] IAAFContainerDef * pParmDef);


  //***********************************************************
  //
  // LookupContainerDef()
  //
  // Return the container definition object with the given id.
  // 
  HRESULT LookupContainerDef (
    // Parameter Unique ID
    [in, ref] aafUID_constref  parameterId,

    // Container definition object
    [out,retval] IAAFContainerDef ** ppParmDef);


  //***********************************************************
  //
  // GetContainerDefs()
  //
  // Return an enumerator for all container definitions.
  // 
  HRESULT GetContainerDefs (
    // Definition Enumeration
    [out,retval] IEnumAAFContainerDefs ** ppEnum);


  //***********************************************************
  //
  // CountContainerDefs()
  //
  // Writes the number of container definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountContainerDefs (
    // Total number of container definition objects
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterInterpolationDef()
  //
  // Add the Interpolation definition object to the header's list of definitions.
  // 
  HRESULT RegisterInterpolationDef (
    // Interpolation Definition Object
    [in] IAAFInterpolationDef * pInterpolationDef);


  //***********************************************************
  //
  // LookupInterpolationDef()
  //
  // Return the Interpolation definition object with the given id.
  // 
  HRESULT LookupInterpolationDef (
    // Parameter Unique ID
    [in, ref] aafUID_constref  parameterId,

    // Interpolation definition object
    [out,retval] IAAFInterpolationDef ** ppInterpolationDef);


  //***********************************************************
  //
  // GetInterpolationDefs()
  //
  // Return an enumerator for aff Interpolation definitions.
  // 
  HRESULT GetInterpolationDefs (
    // Definition Enumeration
    [out,retval] IEnumAAFInterpolationDefs ** ppEnum);


  //***********************************************************
  //
  // CountInterpolationDefs()
  //
  // Writes the number of interpolation definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountInterpolationDefs (
    // Total number of interpolation definition objects
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterPluginDef()
  //
  // Add the Interpolation definition object to the header's list of definitions.
  // 
  HRESULT RegisterPluginDef (
    // plugin definition Object
    [in] IAAFPluginDef * pPlugDef);


  //***********************************************************
  //
  // LookupPluginDef()
  //
  // Return the plugin descriptor object with the given id.
  // 
  HRESULT LookupPluginDef (
    // Parameter Unique ID
    [in, ref] aafUID_constref  parameterId,

    // plugin descriptor object
    [out,retval] IAAFPluginDef ** ppPlugDef);


  //***********************************************************
  //
  // GetPluginDefs()
  //
  // Return an enumerator for all plugin descriptors.
  // 
  HRESULT GetPluginDefs (
    // Definition Enumeration
    [out,retval] IEnumAAFPluginDefs ** ppEnum);


  //***********************************************************
  //
  // CountPluginDefs()
  //
  // Writes the number of plugin definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountPluginDefs (
    // Total number of plugin definition objects
    [out, retval] aafUInt32 *  pResult);
}



// ************************
//
// Interface IAAFEdgecode
//
// ************************
 


//
// Objects that implement IAAFEdgecode also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(38e6f8a4-2a2c-11d2-8411-00600832acb8),
    helpstring("IAAFEdgecode Interface"),
    pointer_default(unique)
]
interface IAAFEdgecode : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  // This function creates a new edgecode clip with the
  // given property values.  The edgecode value is represented with an
  // aafEdgecode_t struct consisting of startFrame, filmKind, and
  // codeFormat.
  // 
  HRESULT Initialize (
    // Length Property Value
    [in] aafLength_t    length  ,

    // Edgecode Value
    [in] aafEdgecode_t  edgecode);

  //***********************************************************
  //
  // GetEdgecode()
  //
  // This set of functions returns the required property values
  // for the object identified by XXX.
  // 
  HRESULT GetEdgecode (
    // Edgecode
    [out] aafEdgecode_t *  edgecode);

}



// ************************
//
// Interface IAAFOperationDef
//
// ************************
//
// The IAAFOperationDef interface is implemented by objects that
// specify an operation definition.  Operation definitions specify
// which parameters are possible on an operation, while an
// AAFOperationGroup specifies specific parameters and input segments
// for a particular operation invocation.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


 

//
// Objects that implement IAAFOperationDef also implement the following interfaces:
//  - IAAFDefObject
//  - IAAFObject

[
    object,
    uuid(14035d91-1ff5-11d2-bf97-006097116212),
    helpstring("IAAFOperationDef Interface"),
    pointer_default(unique)
]
interface IAAFOperationDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new DefObject
    [in, string] aafCharacter_constptr  pName,

    // Description for new DefObject
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetDataDef()
  //
  // Places the DataDefinition object attached to this
  // IAAFOperationDef into the *ppDataDef argument.  The data
  // definition will match one of the AUIDs in the file
  // AAFDataDefs.h, (which includes DDEF_PICTURE, and
  // DDEF_SOUND), and indicates what type of data the operation will
  // be performed upon.  For example, a video dissolve will have the
  // data def DEF_VIDEO.  If a data definition is used which is not
  // from AAFDataDefs.h, then the client is responsible for making
  // sure that a data definition object with that ID exists in the
  // dictionary.  The SDK will take care of creating the standard data
  // definitions.
  //
  // Succeeds if all of the following are true:
  // - the ppDataDefID pointer is valid.
  // - A valid DataDefinition exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDataDef is null.
  //
  // AAFRESULT_INVALID_DATA_DEF
  //   - There is no IAAFDataDefinition.  There has to be one of some
  //     kind for this to be a valid operation definition.
  // 
  HRESULT GetDataDef (
    // Returned DataDefinition object
    [out] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // SetDataDef()
  //
  // Sets the IAAFDataDefinition of this IAAFOperationDef to be the
  // given one.  The
  // data definition will match one of the AUIDs in the file
  // AAFDataDefs.h, (which includes DDEF_PICTURE, and
  // DDEF_SOUND), and indicates what type of data the operation will
  // be performed upon.  For example, a video dissolve will have the
  // data def DEF_VIDEO.  If a data definition is used which is not
  // from AAFDataDefs.h, then the client is responsible for making
  // sure that a data definition object with that ID exists in the
  // dictionary.  The SDK will take care of creating the standard data
  // definitions.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef is null.
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetDataDef (
    // Essence Descriptor object
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // IsTimeWarp()
  //
  // Returns the value of isTimeWarp.  IsTimeWarp is true if the
  // length of an IAAFOperationGroup is different from the lengths of
  // the input segments.  For example, a slow motion effect.
  //
  // Succeeds if all of the following are true:
  // - the bIsTimeWarp pointer is valid.
  // 
  // If this method fails nothing will be written to *bIsTimeWarp.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - bIsTimeWarp arg is NULL.
  // 
  HRESULT IsTimeWarp (
    // pointer to the return value
    [out, retval] aafBoolean_t *  bIsTimeWarp);


  //***********************************************************
  //
  // SetIsTimeWarp()
  //
  // Sets the IsTimeWarp boolean.  IsTimeWarp is true if the length of
  // an IAAFOperationGroup is different from the lengths of the input
  // segments.  For example, a slow motion effect.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetIsTimeWarp (
    // is timewarp value
    [in] aafBoolean_t  IsTimeWarp);


  //***********************************************************
  //
  // PrependDegradeToOperation()
  //
  // Prepend another operation definition to the DegradeTo list of
  // definitions.  Use this function to add an operation definition to
  // be scanned first when searching for the a replacement (a more
  // desirable alternate operation).
  // 
  // Succeeds if all of the following are true:
  // - the pOperationDef pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOperationDef is null.
  // 
  HRESULT PrependDegradeToOperation (
    // Degrade To Operation Definition Object
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // AppendDegradeToOperation()
  //
  // Append another operation definition to the DegradeTo list of
  // definitions.  Use this function to add an operation definition to
  // be scanned last when searching for the a replacement (a less
  // desirable alternate operation).
  // 
  // Succeeds if all of the following are true:
  // - the pOperationDef pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOperationDef is null.
  // 
  HRESULT AppendDegradeToOperation (
    // Degrade To operation Definition Object
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // InsertDegradeToOperationAt()
  //
  // Insert an operation definition into the DegradeTo list of
  // definitions at the given index.  Operation definitions already
  // existing at the given and higher indices will be moved up to the
  // next higher index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pOperationDef pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountDegradeToOperations().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOperationDef is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountDegradeToOperations().
  // 
  HRESULT InsertDegradeToOperationAt (
    // index where operation def is to be inserted
    [in] aafUInt32  index,

    // Degrade To operation Definition Object
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // RemoveDegradeToOperationAt()
  //
  // Removes the indexed operation definition from the DegradeTo list
  // of definitions.  Operation definitions already existing at
  // indices higher than the given index will be moved down to the
  // next lower index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the value returned by
  //   CountDegradeToOperations().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_BADINDEX
  //   - index is greater or equal to than the value returned by
  //     CountDegradeToOperations().
  // 
  HRESULT RemoveDegradeToOperationAt (
    // index where operation def is to be inserted
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetDegradeToOperations()
  //
  // Return an enumerator for aaf operation definitions, ordered from
  // the most desirable to the least desirable alternative.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetDegradeToOperations (
    // Operation Definition Enumeration
    [out, retval] IEnumAAFOperationDefs ** ppEnum);


  //***********************************************************
  //
  // CountDegradeToOperations()
  //
  // Retrieves the number of Degrade To operations currently present
  // and places that number in *pResult.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountDegradeToOperations (
    // resulting count of Degrade To operations
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetCategory()
  //
  // This method returns an AUID indicating the category of the given operation.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  // 
  HRESULT GetCategory (
    // The enumeration describing the current category
    [out] aafUID_t*  pValue);


  //***********************************************************
  //
  // SetCategory()
  //
  // This method sets an AUID indicating the category of the given operation.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetCategory (
    // The enumeration describing the current categor
    [in, ref] aafUID_constref  value);


  //***********************************************************
  //
  // GetNumberInputs()
  //
  // Gets the Number of input media segments.
  // 
  // Succeeds if all of the following are true:
  // - the pNumberInputs pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumberInputs.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberInputs arg is NULL.
  // 
  HRESULT GetNumberInputs (
    // Pointer to Number of Inputs
    [out, retval] aafInt32 *  pNumberInputs);


  //***********************************************************
  //
  // SetNumberInputs()
  //
  // Sets the Number of input media segments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetNumberInputs (
    // Number of Inputs
    [in] aafInt32  NumberInputs);


  //***********************************************************
  //
  // GetBypass()
  //
  // Gets the Bypass media segment index, which is a value from 0
  // to one less than that returned by GetNumberInputs().  This
  // value allows the client application to pick one of the inputs
  // (foreground, background, etc.) to stand in for the
  // effect if it is not available, and none of the degrade to
  // effects are available.
  // 
  // Succeeds if all of the following are true:
  // - the pBypass pointer is valid.
  // 
  // If this method fails nothing will be written to *pBypass.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pBypass arg is NULL.
  // 
  HRESULT GetBypass (
    // Pointer to a Bypass media segment index 
    [out,retval] aafUInt32 *  pBypass);


  //***********************************************************
  //
  // SetBypass()
  //
  // Sets the media segment index, which is a value from 0 to one
  // less than that returned by GetNumberInputs().  This value
  // allows the client application to pick one of the inputs
  // (foreground, background, etc.) to stand in for the
  // effect if it is not available, and none of the degrade to
  // effects are available.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetBypass (
    // Bypass media segment index
    [in] aafUInt32  bypass);


  //***********************************************************
  //
  // AddParameterDef()
  //
  // Add the Parameter Definition object to the unordered list of
  // parameter definitions. 
  // 
  // Succeeds if all of the following are true:
  // - the pAAFParameterDef pointer is valid. 
  // - the given Parameter Definition does not exists in this Operation
  //   Definition already
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pAAFParameterDef is null.
  //
  // AAFRESULT_OBJECT_ALREADY_ATTACHED
  //	- pAAFParameterDef is already in this OperationDef
  // 
  HRESULT AddParameterDef (
    // Parameter definition Object
    [in] IAAFParameterDef * pParameterDef);


  //***********************************************************
  //
  // GetParameterDefs()
  //
  // Return an enumerator for the unordered list of AAF Parameter
  // definitions.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetParameterDefs (
    // Parameter definition enumeration
    [out,retval] IEnumAAFParameterDefs ** ppEnum);


  //***********************************************************
  //
  // CountParameterDefs()
  //
  // This method returns the number of parameter defs.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT CountParameterDefs (
    // Number of parameter defs
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // LookupParameterDef()
  //
  // This method looks up the parameter def corresponding to the given
  // ID.
  //
  // Succeeds if all of the following are true:
  // - the given ID corresponds to a known parameter def
  // - the ppParameterDef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppParameterDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pParameterDef arg is NULL.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - given ID does not correspond to a known parameter def.
  // 
  HRESULT LookupParameterDef (
    // ID of parameter def to look up
    [in] aafUID_constref  parameterDefId,

    // resulting parameter def
    [out] IAAFParameterDef ** ppParameterDef);
}



// ************************
//
// Interface IAAFEssenceAccess
//
// ************************

//
// AAFEssenceAccess is an interace which provides streaming access
// over multiple channels of essence data.  This interface deals with
// essence data which is in an uncompressed form, and handles
// compression or decompression of the data if required.  You may need
// to QueryInterface for an AAFEssenceAccess interface in order to do
// non-read write operations such as seek.
//
// You should call the CreateMultiEssence or OpenMultiEssence calls on
// AAFMasterMob in order to get an interface pointer to
// AAFEssenceAccess, as there is no public create or open method in
// the interface.
//
// A number of errors can be returned from most method calls,  These
// are:
//		AAFRESULT_NOMEMORY   -- The system ran out of memory processing
//                              the method.
//		AAFRESULT_NULL_PARAM -- A NULL parameter was passed in which
//                              was required.


//
// Objects that implement IAAFEssenceAccess also implement the following interfaces:
//  - IAAFEssenceMultiAccess

[
    object,
    uuid(aed97eb0-2bc8-11D2-bfaa-006097116212),
    helpstring("IAAFEssenceAccess Interface"),
    pointer_default(unique)
]
interface IAAFEssenceAccess : IUnknown
{


  //***********************************************************
  //
  // SetEssenceCodecFlavour()
  //
  // Sets which flavour of the codec ID is to be used.
  //
  // An example of a flavour would be a number of standard starting
  // JPEG tables.
  // 
  HRESULT SetEssenceCodecFlavour (
    // The particular flavour
    [in, ref] aafUID_constref  flavour);


  //***********************************************************
  //
  // WriteSamples()
  //
  // Writes data to the given essence stream.
  //
  // A single video frame is ONE sample.
  //
  // Buflen must be large enough to hold the total sample size.
  //
  // Possible Errors:
  //   AAFRESULT_SINGLE_CHANNEL_OP -- Tried to write to an interleaved
  //                                  stream.
  //   AAFRESULT_BADDATAADDRESS    -- The buffer must not be a NULL
  //                                  pointer.
  // 
  HRESULT WriteSamples (
    // write this many samples
    [in] aafUInt32  nSamples,

    // from a buffer of this size
    [in] aafUInt32  buflen,

    // from a buffer
    [in,size_is(buflen)] aafDataBuffer_t  buffer,

    // The number of samples actually written
    [out, ref] aafUInt32 *  samplesWritten,

    // The number of bytes actually written
    [out, ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // GetLargestSampleSize()
  //
  // Returns the size in bytes of the largest sample for a given
  // essence type.
  //
  // For uncompressed data, or the output of the software codec, the
  // sample size will propably be a constant.
  //
  // The essence type parameter exists to support codecs with multiple
  // interleaved essence types.
  // 
  HRESULT GetLargestSampleSize (
    // for this essence type
    [in] IAAFDataDef * pDataDef,

    // the largest sample size
    [out] aafLength_t*  maxSize);


  //***********************************************************
  //
  // GetIndexedSampleSize()
  //
  // Returns the size in bytes of the given sample for a given essence
  // type.
  //
  // For uncompressed data, or the output of the software codec, the
  // sample size will propably be a constant.
  //
  // The essence type parameter exists to support codecs with multiple
  // interleaved essence types.
  // 
  // Possible Errors:
  //   AAFRESULT_NULL_PARAM      -- A return parameter was NULL.
  //   AAFRESULT_BADSAMPLEOFFSET -- The supplied sample offset is out
  //                                of range.
  // 
  HRESULT GetIndexedSampleSize (
    // and this essence type
    [in] IAAFDataDef * pDataDef,

    // for this [0-based] sample frame number
    [in] aafPosition_t  frameNum,

    // How big is the sample frame?
    [out] aafLength_t*  frameSize);


  //***********************************************************
  //
  // SetTransformParameters()
  //
  // Sets a series of format objects which will be used to describe
  // the in-memory format.
  //
  // This is the format expected on writes and produced on reads.
  //
  // On writes, the data will be written in this format, except
  // where a software codec may be used.  On reads, the data will be
  // translated to this format.
  //
  // The order of the parameters does matter, as transformations will
  // be applied in that order to get from the on-disk format to the
  // in-memory format.
  // 
  HRESULT SetTransformParameters (
    // A set of transforms to apply to the essence if required
    [in] IAAFEssenceFormat * op);
	 

  //***********************************************************
  //
  // CountSamples()
  //
  // Returns the number of samples of the given essence type on the
  // given essence stream.
  // 
  // A video sample is one frame.
  // 
  HRESULT CountSamples (
    // For this essence dataDef
    [in] IAAFDataDef * pDataDef,

    // find out how many samples are present
    [out] aafLength_t *  result);


  //***********************************************************
  //
  // ReadSamples()
  //
  // Read a given number of samples from an opened essence stream.
  //
  // This call will only return a single channel of essence from an
  // interleaved stream.
  //
  // A video sample is a frame.
  //
  // Buflen is in bytes, and should be large enough to hold the
  // samples after the requested transforms have been applied.
  //
  // Possible Errors:
  //   AAFRESULT_END_OF_DATA -- Hit the end of the essence (like
  //                            EOF) while reading.
  //   AAFRESULT_SMALLBUF    -- Buffer too small for samples.
  // 
  HRESULT ReadSamples (
    // Read this many samples
    [in] aafUInt32  nSamples,

    // into a buffer of this size
    [in] aafUInt32  buflen,

    // The transfer buffer
    [out, size_is(buflen),length_is(*bytesRead)] aafDataBuffer_t  buffer,

    // The number of samples actually read
    [out, ref] aafUInt32 *  samplesRead,

    // The number of bytes actually read
    [out, ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // Seek()
  //
  // The seek function for essence.
  //
  // Useful only on reading, you can't seek aound while writing
  // essence.
  //
  // An audio frame is one sample across all channels.
  //
  // Possible Errors:
  //   AAFRESULT_BADSAMPLEOFFSET -- Hit the end of the essence
  //                                (like EOF) while reading.
  // 
  HRESULT Seek (
    // A 0-based offset in units of the sample rate to seek to.
    [in] aafPosition_t  sampleFrameNum);


  //***********************************************************
  //
  // GetFileFormat()
  //
  // Given an AAFEssenceFormat, read the essence parameters inside
  // and set the values from the file format.
  // 
  HRESULT GetFileFormat (
    // An AAFEssenceFormat with parameter codes set but no values
    [in] IAAFEssenceFormat * opsTemplate,

    // Another AAFEssenceFormat with values set
    [out] IAAFEssenceFormat ** opsResult);


  //***********************************************************
  //
  // GetFileFormatParameterList()
  //
  // Returns an AAFEssenceFormat containing a list of all parameters
  // supported by the current codec.
  // 
  HRESULT GetFileFormatParameterList (
    // An ampty AAFEssenceFormat object
    [out] IAAFEssenceFormat ** ops);


  //***********************************************************
  //
  // GetEmptyFileFormat()
  //
  // Returns an empty AAFEssenceFormat object.  This is the factory
  // method for AAFEssenceFormat.
  // 
  HRESULT GetEmptyFileFormat (
    // An ampty AAFEssenceFormat object
    [out] IAAFEssenceFormat ** ops);


  //***********************************************************
  //
  // PutFileFormat()
  //
  // Given an AAFEssenceFormat, read the essence parameters inside
  // and change the file format.
  // 
  HRESULT PutFileFormat (
    // An AAFEssenceFormat with one or more parameter/value pairs
    [in] IAAFEssenceFormat * ops);


  //***********************************************************
  //
  // GetCodecName()
  //
  // Returns the full name of the given codec expanded for human
  // consumption.
  //
  // No other call uses this name, so it may be fully
  // descriptive, esp. of limitations.
  //
  // The name will be truncated to fit within "buflen" bytes.
  //
  // Possible Errors:
  //   AAFRESULT_CODEC_INVALID - The given codec ID is not loaded.
  //   AAFRESULT_SMALLBUF      - The buffer is not large enough to
  //                             hold the data.
  // 
  HRESULT GetCodecName (
    // The size of the name buffer to be filled
    [in] aafUInt32  namelen,

    // The buffer to fill
    [out,size_is(namelen)] aafCharacter *  name);


  //***********************************************************
  //
  // GetCodecID()
  //
  // Returns the codec ID being used to handle the specified essence.
  //
  // This will be required in order to send private data to the
  // codec.
  //
  // The name will be truncated to fit within "buflen" bytes.
  // 
  HRESULT GetCodecID (
    // Returns the current codec ID
    [out] aafCodecID_t *  codecID);


  //***********************************************************
  //
  // CompleteWrite()
  //
  // Handle any format related writing at the end and adjust mob
  // lengths.  Must be called before releasing a write essence
  // access.
  //
  // Possible Errors:
  //   AAFRESULT_STREAM_FULL
  //   - The essence can not be written because of a fault such as a
  //     disk full error in the underlying operating system.
  // 
  HRESULT CompleteWrite ();


}


// ************************
//
// Interface IAAFEssenceData
//
// ************************

//
// The IAAFEssenceData interface is used to modify AAFEssenceData
// objects, which contain the actual essence data (ex. WAVE) when
// it is contained within an AAF file.  Normally the client
// application would access the essence through the IAAFEssenceAccess
// interface, which handles the work of finding and (de)compressing
// the data.  However, in rare cases direct access to the data is
// required, so this interface is exposed.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
//
// AAFRESULT_NULL_PARAM
//   - One of the passed in pointers is NULL.
//
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFEssenceData also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(6a33f4e2-8ed6-11d2-bf9d-00104bc9156d),
    helpstring("IAAFEssenceData Interface"),
    pointer_default(unique)
]
interface IAAFEssenceData : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  // Associates a weak reference to the given file mob with the
  // essence data.
  //
  // Succeeds if all of the following are true:
  // - the pFileMob pointer is valid and points to 
  // a file mob (contains a file descriptor).
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFileMob is null.
  // 
  HRESULT Initialize (
    // reference to a file mob
    [in] IAAFSourceMob * pFileMob);

  //***********************************************************
  //
  // Write()
  //
  // Write pre-interleaved data to a essence stream.
  // 
  HRESULT Write (
    // write this many bytes
    [in] aafUInt32  bytes,

    // here is the buffer
    [out, size_is(bytes)] aafDataBuffer_t  buffer,

    // 
    [out,ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // Read()
  //
  // Read pre-interleaved data from a essence stream.
  // 
  HRESULT Read (
    // read this many bytes
    [in] aafUInt32  bytes,

    // here is the buffer
    [out, size_is(bytes), length_is(*bytesRead)] aafDataBuffer_t  buffer,

    // 
    [out,ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // SetPosition()
  //
  // Seek to absolute position within the essence data.
  // 
  HRESULT SetPosition (
    // offset from beginning of essence
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetPosition()
  //
  // Get the absolute position within the essence data.
  // 
  HRESULT GetPosition (
    // offset from beginning of essence
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetSize()
  //
  // Return the total size of the essence data.
  // 
  HRESULT GetSize (
    // size of essence data
    [out] aafLength_t *  pSize );


  //***********************************************************
  //
  // SetFileMob()
  //
  // Associates a weak reference to the given file mob with the
  // essence data.
  //
  // Succeeds if all of the following are true:
  // - the pFileMob pointer is valid and points to 
  // a file mob (contains a file descriptor).
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFileMob is null.
  // 
  HRESULT SetFileMob (
    // reference to a file mob
    [in] IAAFSourceMob * pFileMob);


  //***********************************************************
  //
  // GetFileMob()
  //
  // Associates a weak reference to the given file mob with the
  // essence data.
  //
  // Succeeds if all of the following are true:
  // - the ppFileMob pointer is valid and a weak
  // reference to the associated file mob can be
  // resolved.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppFileMob is null.
  // 
  HRESULT GetFileMob (
    // reference to a file mob
    [in] IAAFSourceMob ** ppFileMob);


  //***********************************************************
  //
  // GetFileMobID()
  //
  // Return the mob id used to find the file mob associated with this
  // essence.  The file mob must exist in the same file as this
  // essence data.
  // 
  HRESULT GetFileMobID (
    // the file mob id associated with essence
    [out] aafMobID_t *  pFileMobID);

}



// ************************
//
// Interface IAAFEssenceDescriptor
//
// ************************
//
// The IAAFEssenceDescriptor interface is implemented by objects which
// describe the format of the content data associated with a File
// Source mob or of the media associated with a Physical Source mob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that
//     IAAFEssenceDescriptor is a primary interface for an abstract
//     class, so it is not appropriate for the Initialize() method
//     to exist in this interface.  The Initialize() method is
//     available through the concrete object's primary interface.
//


//
// Objects that implement IAAFEssenceDescriptor also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(94659783-2a3c-11D2-bfA4-006097116212),
    helpstring("IAAFEssenceDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFEssenceDescriptor : IUnknown
{

  //***********************************************************
  //
  // CountLocators()
  //
  // Return the number of locators attached to this essence
  // descriptor.  The number of locators may be zero if the essence is
  // in the current file.
  // 
  // Succeeds if all of the following are true:
  // - the pCount pointer is valid.
  // 
  // If this method fails nothing is written to *pCount.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount is null.
  // 
  HRESULT CountLocators (
    // Returns the number of locators
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // AppendLocator()
  //
  // Append another locator to this essence descriptor.  Use this
  // function to add a locator to be scanned last when searching for
  // the essence (a secondary location for the essence).
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  // 
  HRESULT AppendLocator (
    // Locator to append
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // PrependLocator()
  //
  // Prepend another locator to this essence descriptor.  Use this
  // function to add a locator to be scanned first when searching for
  // the essence (a new primary location for the essence).
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  // 
  HRESULT PrependLocator (
    // Locator to append
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // InsertLocatorAt()
  //
  // Inserts the given locator at the given index.  Locators already
  // existing at the given and higher indices will be moved to the
  // next higher index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountLocators().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountLocators().
  // 
  HRESULT InsertLocatorAt (
    // index at which locator is to be inserted
    [in] aafUInt32  index,

    // Locator to append
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // GetLocatorAt()
  //
  // Retrieves the locator at the given index.
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // - index is less than the value returned by CountLocators().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountLocators().
  // 
  HRESULT GetLocatorAt (
    // index of locator to retrieve
    [in] aafUInt32  index,

    // returned locator
    [out, retval] IAAFLocator ** ppLocator);


  //***********************************************************
  //
  // RemoveLocatorAt()
  //
  // Removes the locator at the given index.  Locators already
  // existing at indices higher than the given index will be moved to
  // the next lower index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the value returned by CountLocators().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountLocators().
  // 
  HRESULT RemoveLocatorAt (
    // index of locator to remove
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetLocators()
  //
  // Returns an enumerator to the locators.  The number of locators
  // may be zero if the essence is in the current file.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetLocators (
    // An enumerator to the locators on this essence descriptor
    [out] IEnumAAFLocators ** ppEnum);
}



// ************************
//
// Interface IAAFEvent
//
// ************************

//
// The IAAFEvent interface is implemented by objects which represent
// a text comment, a trigger, or an area in the image that has an
// associated interactive action.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFMobSlot is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
// 
//


//
// Objects that implement IAAFEvent also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(e684d790-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFEvent Interface"),
    pointer_default(unique)
]
interface IAAFEvent : IUnknown
{


  //***********************************************************
  //
  // GetPosition()
  //
  // This method will return the Position of this event.
  // 
  // Succeeds if all of the following are true:
  // - the pPosition pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPosition arg is NULL.
  // 
  HRESULT GetPosition (
    // Position property value
    [out,retval] aafPosition_t *  pPosition);

  //***********************************************************
  //
  // SetPosition()
  //
  // This method will set the Position of this event.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.).
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetPosition (
    // Position property value
    [in] aafPosition_t  Position);


  //***********************************************************
  //
  // SetComment()
  //
  // Sets specifies the purpose of the event.
  //
  // Set the Comment property to the value specified in
  // pComment.  A copy is made of the data so the caller
  // retains ownership of the *pComment buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pComment pointer is valid.
  // 
  // If this method fails the Comment property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pComment arg is NULL.
  // 
  HRESULT SetComment (
    // buffer from which Comment is to be read
    [in, string] aafCharacter_constptr  pComment);


  //***********************************************************
  //
  // GetComment()
  //
  // Gets specifies the purpose of the event.
  // 
  // Writes the Comment property, with a trailing null
  // character, into the pComment buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Comment property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetCommentBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pComment.
  // 
  // Succeeds if:
  // - The pComment pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Comment.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pComment arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Comment.
  // 
  HRESULT GetComment (
    // buffer into which Comment is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pComment,

    // size of *pComment buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetCommentBufLen()
  //
  // Returns size of buffer (in bytes) required for GetComment().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetCommentBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);

}



// ************************
//
// Interface IAAFEventMobSlot
//
// ************************

//
// An EventMobSlot, as all MobSlots, has a concrete segment, which
// is a concrete Event or a Sequence of ordered Events. If it has a
// sequence of events, all events shall have the same concrete
// Event.
//


//
// Objects that implement IAAFEventMobSlot also implement the following interfaces:
//  - IAAFMobSlot
//  - IAAFObject

[
    object,
    uuid(e684d766-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFEventMobSlot Interface"),
    pointer_default(unique)
]
interface IAAFEventMobSlot : IUnknown
{

  //***********************************************************
  //
  // GetEditRate()
  //
  // This method will get the edit rate for this mob slot.
  // 
  // Succeeds if all of the following are true:
  // - the pEditRate pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditRate arg is NULL.
  // 
  HRESULT GetEditRate (
    // Edit rate property value
    [out,retval] aafRational_t *  pEditRate);


  //***********************************************************
  //
  // SetEditRate()
  //
  // This method will get set edit rate for this mob slot.
  // 
  // Succeeds if all of the following are true:
  // - the pEditRate pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditRate arg is NULL.
  // 
  HRESULT SetEditRate (
    // Edit rate property value
    [in] aafRational_t *  pEditRate);


}



// ************************
//
// Interface IAAFFile
//
// ************************
//
// This interface is used with an object representing an AAF file.
//
// Any filesystem file can be opened for reading by multiple
// IAAFFile-supporting objects.
//
// It is not recommended to Close an IAAFFile-implementing object
// which contains objects to which outstanding references are held in
// client code.  Nevertheless, even if that is done, the Close()
// method will succeed and all referenced objects will be put into a
// Detached state in which may cause any methods on such objects to
// fail with the error status of AAFRESULT_NOT_IN_FILE.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(9346ACD3-2713-11d2-8035-006008143E6F),
    helpstring("IAAFFile Interface"),
    pointer_default(unique)
]
interface IAAFFile : IUnknown
{

  //***********************************************************
  //
  // Open()
  //
  // Associates this IAAFFile-supporting object with the storage to
  // which it is to be associated.  It will then be possible to access
  // objects within this file.
  //
  // This method will succeed only if all of the following are true:
  // - This object has not already been opened.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_OPEN
  //   - This object has already been Open()ed.
  // 
  HRESULT Open ();


  //***********************************************************
  //
  // SaveCopyAs()
  //
  // Copies the contents of this file to *pDestFile.  Requires that
  // *pDestFile be open, writeable or modifiable, and not yet
  // contain any objects.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if:
  // - This object is currently open.
  // - The named filesystem file is writable.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_OPEN
  //   - This object is not open.
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - The named file cannot be written.
  // 
  HRESULT SaveCopyAs (
    // File to recieve contents
    [in] IAAFFile * pDestFile);


  //***********************************************************
  //
  // GetHeader()
  //
  // Returns the IAAFHeader-supporting object associated with this
  // file.  If this object has never been associated with a file, a
  // new empty IAAFHeader-supporting object will be created and
  // returned.  The returned header is AddRef()ed before it is
  // returned.  Note that the header is automatically created when the
  // file object is created.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - This file object is open.
  // - the given header pointer is valid.
  // - this object contains a header.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NOT_OPEN
  //   - This object is not open.
  //
  // AAFRESULT_NULL_PARAM
  //   - the header pointer arg is NULL.
  //
  // AAFRESULT_NO_HEADER
  //   - this object contains no header.
  // 
  HRESULT GetHeader (
    // Set to header of the current file
    [out, retval] IAAFHeader ** ppHeader);


  //***********************************************************
  //
  // GetRevision()
  //
  // Get the revision of the current AAF file, and returns it in pRev.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - the given revision pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - the revision pointer arg is NULL.
  // 
  HRESULT GetRevision (
    // Revision of the current file
    [out, retval] aafFileRev_t *  pRev);


  //***********************************************************
  //
  // Save()
  //
  // If this IAAFFile-supporting object is open, all unsaved changes
  // made to the contents of this object are saved.
  //
  // This method will succeed only if all of the following are true:
  // - This object is currently open.
  // - Sufficient space remains in the storage for the data to be
  //   written.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_OPEN
  //   - This object is not open.
  //
  // AAFRESULT_WRONG_OPENMODE
  //   - This object is not open for writing or modification.
  //
  // AAFRESULT_INSUFFICIENT_SPACE
  //   - There is insufficient space in the storage to save the
  //     contents of this object.
  // 
  HRESULT Save ();


  //***********************************************************
  //
  // Close()
  //
  // Dissociates this IAAFFile-supporting object from its
  // currently-associated storage.  Any AAF objects which were
  // contained within this object will then no longer be available to
  // the client.
  //
  // If the client is maintaining any references to any objects which
  // are contained in this object, those objects will be marked as
  // dissociated, and methods on them will fail.
  //
  // Any unsaved changes will be written to the file before the Close
  // operation is complete.
  //
  // This method will succeed only if all of the following are true:
  // - This object is currently open.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_OPEN
  //   - This object is not already open.
  // 
  HRESULT Close ();

  //***********************************************************
  //
  // GetDictionary()
  //
  // Places the dictionary that contains all types of aaf definition
  // objects into the *ppDictionary argument.  The returned dictionary
  // is AddRef()ed before it is returned.  Note that the dictionary
  // is automatically created when the header object is created.
  // 
  // Succeeds if all of the following are true:
  // - the ppDictionary pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDictionary is null.
  // 
  HRESULT GetDictionary (
    // The AAF Dictionary
    [out, retval] IAAFDictionary ** ppDictionary);

}



// ************************
//
// Interface IAAFFileDescriptor
//
// ************************
//
// The IAAFFileDescriptor interface is implemented by objects which
// describe the format of the content data associated with a File
// Source mob or the media associated with a Physical Source mob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFFileDescriptor
//     is a primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFFileDescriptor also implement the following interfaces:
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(e58a8561-2a3e-11D2-bfa4-006097116212),
    helpstring("IAAFFileDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFFileDescriptor : IUnknown
{

  //***********************************************************
  //
  // SetLength()
  //
  // // 
  // Sets the length of the essence in samples [not edit units].
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetLength (
    // length of the essence in samples
    [in] aafLength_t  length);


  //***********************************************************
  //
  // GetLength()
  //
  // // Gets the length of the essence in samples [not edit units].
  //
  // Succeeds if all of the following are true:
  // - the pLength pointer is valid.
  // 
  // If this method fails nothing will be written to *pLength.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLength arg is NULL.
  // 
  HRESULT GetLength (
    // returns length of the essence in samples
    [out] aafLength_t *  pLength);


  //***********************************************************
  //
  // SetCodecDef()
  //
  // // Set to the exact codec which was used as a hint.
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetCodecDef (
    // Which codec was used
    [in] IAAFCodecDef * codecDef);


  //***********************************************************
  //
  // GetCodecDef()
  //
  // // Get to the exact codec which was used as a hint.
  //
  // Succeeds if all of the following are true:
  // - the pCodecDef pointer is valid.
  // 
  // If this method fails nothing will be written to *pCodecDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCodecDef arg is NULL.
  // 
  HRESULT GetCodecDef (
    // Which codec was used
    [out] IAAFCodecDef ** pCodecDef);


  //***********************************************************
  //
  // SetSampleRate()
  //
  // Sets sample rate of the essence as opposed to the edit rate.
  // 
  // If this method fails the sample rate property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetSampleRate (
    // sample rate of the essence
    [in] aafRational_constref  rate);


  //***********************************************************
  //
  // GetSampleRate()
  //
  // Gets sample rate of the essence as opposed to the edit rate. and
  // writes it into the *pRate argument.
  //
  // Succeeds if all of the following are true:
  // - the pRate pointer is valid.
  // 
  // If this method fails nothing will be written to *pRate.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pRate arg is NULL.
  // 
  HRESULT GetSampleRate (
    // sample rate of the essence
    [out] aafRational_t*  pRate);


  //***********************************************************
  //
  // SetContainerFormat()
  //
  // Identifies the file format.  The container format is an optional
  // property.
  // 
  // If this method fails the container format property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetContainerFormat (
    // file format
    [in] IAAFContainerDef * format);


  //***********************************************************
  //
  // GetContainerFormat()
  //
  // // Optional. Identifies the file format.
  //
  // Succeeds if all of the following are true:
  // - the pFormat pointer is valid.
  // 
  // If this method fails nothing will be written to *pFormat.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFormat arg is NULL.
  // 
  HRESULT GetContainerFormat (
    // Identifies the file format
    [out] IAAFContainerDef ** pFormat);
}



// ************************
//
// Interface IAAFFilmDescriptor
//
// ************************
//
// The IAAFFilmDescriptor interface is implemented by objects which
// describe film essence.  A FilmDescriptor object shall be the
// EssenceDescription of a  physical Source Mob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFFilmDescriptor also implement the following interfaces:
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(e58a8563-2a3e-11D2-bfa4-006097116212),
    helpstring("IAAFFilmDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFFilmDescriptor : IUnknown
{

  //***********************************************************
  //
  // SetFilmManufacturer()
  //
  // Sets the Film Manufacturer string property.
  //
  // Set the FilmManufacturer property to the value specified in
  // pFilmManufacturer.  A copy is made of the data so the caller
  // retains ownership of the *pFilmManufacturer buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pFilmManufacturer pointer is valid.
  // 
  // If this method fails the FilmManufacturer property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmManufacturer arg is NULL.
  // 
  HRESULT SetFilmManufacturer (
    // buffer from which FilmManufacturer is to be read
    [in, string] aafCharacter_constptr  pFilmManufacturer);


  //***********************************************************
  //
  // GetFilmManufacturer()
  //
  // Gets the Film Manufacturer string property.
  // 
  // Writes the FilmManufacturer property, with a trailing null
  // character, into the pFilmManufacturer buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the FilmManufacturer property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetFilmManufacturerBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pFilmManufacturer.
  // 
  // Succeeds if:
  // - The pFilmManufacturer pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   FilmManufacturer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmManufacturer arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold FilmManufacturer.
  // 
  HRESULT GetFilmManufacturer (
    // buffer into which FilmManufacturer is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pFilmManufacturer,

    // size of *pFilmManufacturer buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetFilmManufacturerBufLen()
  //
  // Returns size of buffer (in bytes) required for GetFilmManufacturer().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetFilmManufacturerBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetFilmModel()
  //
  // Sets the Film Model string property.
  //
  // Set the FilmModel property to the value specified in
  // pFilmModel.  A copy is made of the data so the caller
  // retains ownership of the *pFilmModel buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pFilmModel pointer is valid.
  // 
  // If this method fails the FilmModel property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmModel arg is NULL.
  // 
  HRESULT SetFilmModel (
    // buffer from which FilmModel is to be read
    [in, string] aafCharacter_constptr  pFilmModel);


  //***********************************************************
  //
  // GetFilmModel()
  //
  // Gets the Film Model string property.
  // 
  // Writes the FilmModel property, with a trailing null
  // character, into the pFilmModel buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the FilmModel property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetFilmModelBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pFilmModel.
  // 
  // Succeeds if:
  // - The pFilmModel pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   FilmModel.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmModel arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold FilmModel.
  // 
  HRESULT GetFilmModel (
    // buffer into which FilmModel is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pFilmModel,

    // size of *pFilmModel buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetFilmModelBufLen()
  //
  // Returns size of buffer (in bytes) required for GetFilmModel().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetFilmModelBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetFilmFormat()
  //
  // Gets the film format.
  //
  // Valid values include:
  //  - kFt35MM
  //  - kFt16MM
  //  - kFt8MM
  //  - kFt65MM
  // 
  // This method succeeds if all of the following are true:
  // - the pFilmFormat pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmFormat arg is NULL.
  // 
  HRESULT GetFilmFormat (
    // pointer to the filmFormat
    [out] aafFilmType_t*  pFilmFormat);


  //***********************************************************
  //
  // GetFrameRate()
  //
  // Get the frame rate of the film.
  // 
  // This method succeeds if all of the following are true:
  // - the pRate pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pRate parameter is NULL.
  // 
  HRESULT GetFrameRate (
    // Frame Rate
    [out] aafUInt32*  pRate);


  //***********************************************************
  //
  // GetPerfPerFrame()
  //
  // Get the number of perforations per frame.
  // 
  // This method succeeds if all of the following are true:
  // - the pPerfPerFrame pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPerfPerFrame parameter is NULL.
  // 
  HRESULT GetPerfPerFrame (
    // Perforations per frame
    [out] aafUInt8*  pPerfPerFrame);


  //***********************************************************
  //
  // GetFilmAspectRatio()
  //
  // Get the image aspect ratio.
  // 
  // This method succeeds if all of the following are true:
  // - the pAspectRatio pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pAspectRatio arg is NULL.
  // 
  HRESULT GetFilmAspectRatio (
    // Film Aspect Ratio
    [out] aafRational_t*  pAspectRatio);


  //***********************************************************
  //
  // SetFilmFormat()
  //
  // Sets the film format of the film.
  // Valid values include:
  //  - kFt35MM
  //  - kFt16MM
  //  - kFt8MM
  //  - kFt65MM
  // 
  // This method succeeds if all of the following are true:
  // - formFactor represents a valid format.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //	- filmFormat is invalid.
  // 
  HRESULT SetFilmFormat (
    // Film Format
    [in] aafFilmType_t  filmFormat);


  //***********************************************************
  //
  // SetFrameRate()
  //
  // Set the frame rate of the film.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetFrameRate (
    // Frame Rate
    [in] aafUInt32  rate);


  //***********************************************************
  //
  // SetPerfPerFrame()
  //
  // Set the number of perforations per frame.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetPerfPerFrame (
    // Perforations per frame
    [in] aafUInt8  perfPerFrame);


  //***********************************************************
  //
  // SetFilmAspectRatio()
  //
  // Set the image aspect ratio.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetFilmAspectRatio (
    // Film Aspect Ratio
    [in] aafRational_t  aspectRatio);
}



// ************************
//
// Interface IAAFDigitalImageDescriptor
//
// ************************
//
// The IAAFDigitalImageDescriptor interface is implemented by objects
// which describe video content data formatted either using RGBA or
// luminance/chrominance formatting.
//
// The geometry properties accessed by Set/GetStoredView(),
// Set/GetSampledView(), and Set/GetDisplayView() describe the
// dimensions and meaning of the stored pixels in the image.  The
// geometry describes the pixels of an uncompressed image.
// Consequently, the geometry properties are independent of the
// compression and subsampling.
//
// Three separate geometries - stored, sampled, and display views -
// are used to define a set of different views on uncompressed digital
// data. All views are constrained to rectangular regions, which means
// that storage and sampling has to be rectangular.
// 
// The relationships among the views can be shown by the following
// rectangles, representing areas of a video image:
// 
// +------------------+
// |                  |
// |   Stored View    |
// |                  |           +--------------+
// +------------------+ <-------- |              |
// |                  |  Sample   | Analog Video |
// |   Sampled View   |  Process  |    Source    |
// |                  |           | Information  |
// | +--------------+ |           |              |
// | |              | |           |              |
// | | Display View | |           |              |
// | |              | |           |              |
// | +--------------+ |           |              |
// |                  |           |              |
// +------------------+ <-------- |              |
//                                +--------------+
//
// The stored view is the entire data region corresponding to a single
// uncompressed frame or field of the image, and is defined by its
// horizontal and vertical dimension properties. The stored view may
// include data that is not derived from, and would not usually be
// translated back to, analog data.
//
// The sampled view is defined to be the rectangular dimensions in
// pixels corresponding to the digital data derived from an analog or
// digital source. These pixels reside within the rectangle defined by
// the stored view. This would include the image and auxiliary
// information included in the analog or digital source. For the
// capture of video signals, the mapping of these views to the
// original signal is determined by the VideoLineMap property.
//
// The display view is the rectangular size in pixels corresponding to
// the viewable area. These pixels contain image data suitable for
// scaling, display, warping, and other image processing. The display
// view offsets are relative to the stored view, not to the sampled
// view.
//
// Although typically the display view is a subset of the sampled
// view, it is possible that the viewable area may not be a subset of
// the sampled data. It may overlap or even encapsulate the sampled
// data. For example, a subset of the input image might be centered in
// a computer-generated blue screen for use in a chroma key effect. In
// this case the viewable pixels on disk would contain more than the
// sampled image.
//
// Each of these data views will have a width and height value. Both
// the sampled view and the display view also have offsets relative to
// the top left corner of the stored view.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that
//     IAAFDigitalImageDescriptor is a primary interface for an
//     abstract class, so it is not appropriate for the
//     Initialize() method to exist in this interface.  The
//     Initialize() method is available through the concrete
//     object's primary interface.
//


//
// Objects that implement IAAFDigitalImageDescriptor also implement the following interfaces:
//  - IAAFFileDescriptor
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(44861701-8AEA-11d2-813C-006097310172),
    helpstring("IAAFDigitalImageDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFDigitalImageDescriptor : IUnknown
{

  //***********************************************************
  //
  // SetCompression()
  //
  // // Sets the kind of compression and format of compression
  // information of the video essence data.  This property is
  // optional.  If there is no compression, the property is omitted.
  // 
  // If this method fails the Data Definition property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetCompression (
    // Identifies a Codec definition for the desired compression and
	// format of compression information.
    [in] aafUID_constref  codecID);


  //***********************************************************
  //
  // GetCompression()
  //
  // Gets the kind of compression and format of compression
  // information of the video essence data.  This property is
  // optional.  If there is no compression, the null AUID is
  // returned.
  //
  // Succeeds if all of the following are true:
  // - the pCompression pointer is valid.
  // 
  // If this method fails nothing will be written to *pCompression.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pComporession arg is NULL.
  // 
  HRESULT GetCompression (
    // Identifies a Codec definition for the desired compression and
	// format of compression information.
    [out] aafUID_t *  pCompression);


  //***********************************************************
  //
  // SetStoredView()
  //
  // Sets the dimension of the stored view.  Typically this includes
  // leading blank video lines, any VITC lines, as well as the active
  // picture area.
  // 
  // If this method fails the Stored Height and Stored Width
  // properties will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetStoredView (
    // Number of pixels in vertical dimension of stored view.
    [in] aafUInt32  StoredHeight,

    // Number of pixels in horizontal dimension of stored view.
    [in] aafUInt32  StoredWidth);


  //***********************************************************
  //
  // GetStoredView()
  //
  // Gets the dimension of the stored view.  Typically this includes
  // leading blank video lines, any VITC lines, as well as the active
  // picture area.
  // 
  // Succeeds if all of the following are true:
  // - pStoredHieght and pStoredWidth are valid pointers.
  // 
  // If this method fails, the *pStoredHieght and *pStoredWidth will
  // not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStoredHeight or pStoredWidth is NULL.
  // 
  HRESULT GetStoredView (
    // Number of pixels in vertical dimension of stored view.
    [out] aafUInt32 *  pStoredHeight,

    // Number of pixels in horizontal dimension of stored view.
    [out] aafUInt32 *  pStoredWidth);


  //***********************************************************
  //
  // SetSampledView()
  //
  // Sets the dimensions of sampled view.  Typically this includes
  // any VITC lines as well as the active picture area, but excludes
  // leading blank video lines.  The offset is specified relative to
  // the rectangle specified by Set/GetStoredView().
  //
  // The following properties are optional:
  //
  //     SampledXOffset - The default value is 0.  Use a value of 0 to
  //                      select the default.
  //     SampledYOffset - The default value is 0.  Use a value of 0 to
  //                      select the default.
  //
  // Succeeds if all of the following are true:
  // - The given dimensions exist within the StoredView.
  // 
  // If this method fails, the SampledXOffset and SampledYOffset
  // properties will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The area specified by SampledHeight and SampledXOffset is
  //     outside the StoredView, or the area specified by SampledWidth
  //     and SampledYOffset is outside the StoredView.
  // 
  HRESULT SetSampledView (
    // Number of pixels in vertical dimension of sampled view.
    [in] aafUInt32  SampledHeight,

    // Number of pixels in horizontal dimension of sampled view.
    [in] aafUInt32  SampledWidth,

    // Number of pixels from top left corner of sampled view. Optional.
    [in] aafInt32  SampledXOffset,

    // Number of pixels from top left corner of sampled view. Optional.
    [in] aafInt32  SampledYOffset);


  //***********************************************************
  //
  // GetSampledView()
  //
  // Gets the dimensions of sampled view.  Typically this includes
  // any VITC lines as well as the active picture area, but excludes
  // leading blank video lines.  The offset is specified relative to
  // the rectangle specified by Set/GetStoredView().
  //
  // Succeeds if all of the following are true:
  // - pSampledHeight, pSampledWidth, pSampledXOffset and
  //   pSampledYOffset are valid pointers
  // 
  // If any of the input parameters are NULL, the property will not
  // be returned.
  //
  // If this method fails, *pSampledHeight, *pSampledWidth,
  // *pSampledXOffset, and *pSampledYOffset will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any of pSampledHeight, pSampledWidth, pSampledXOffset, or
  //     pSampledYOffset are NULL.
  // 
  HRESULT GetSampledView (
    // Number of pixels in vertical dimension of sampled view.
    [out] aafUInt32 *  pSampledHeight,

    // Number of pixels in horizontal dimension of sampled view.
    [out] aafUInt32 *  pSampledWidth,

    // Number of pixels from top left corner of sampled view. Optional.
    [out] aafInt32 *  pSampledXOffset,

    // Number of pixels from top left corner of sampled view. Optional.
    [out] aafInt32 *  pSampledYOffset);


  //***********************************************************
  //
  // SetDisplayView()
  //
  // Sets the dimension of display view.  Typically this includes
  // the active picture area, but excludes leading blank video lines
  // and any VITC lines.  The offset is specified relative to the
  // rectangle specified by Set/GetStoredView().
  // 
  // The following properties are optional:
  //
  //     DisplayHeight  - The default value is the storedHeight. Use
  //                      storedHeight to select the default.
  //     DisplayWidth   - The default value is the storedWidth. Use
  //                      storedWidth to select the default.
  //     DisplayXOffset - The default value is 0.  Use a value of 0 to
  //                      select the default.
  //     DisplayYOffset - The default value is 0.  Use a value of 0 to
  //                      select the default.
  //
  // Note that The specified display rectangle may exist outside the
  // SampledView or even the StoredView.
  //
  // If this method fails the DisplayHeight, DisplayWidth, DisplayXOffset and
  // DisplayYOffset properties will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The area specified by DisplayHeight and DisplayXOffset is
  //     outside the StoredView, or the area specified by DisplayWidth
  //     and DisplayYOffset is outside the StoredView.
  // 
  HRESULT SetDisplayView (
    // Number of pixels in vertical dimension of display view. Optional.
    [in] aafUInt32  DisplayHeight,

    // Number of pixels in horizontal dimension of display view. Optional.
    [in] aafUInt32  DisplayWidth,

    // Number of pixels from the top-left corner of the display view. Optional.
    [in] aafInt32  DisplayXOffset,

    // Number pixels from the top-left corner of the display view. Optional.
    [in] aafInt32  DisplayYOffset);


  //***********************************************************
  //
  // GetDisplayView()
  //
  // Gets the dimension of display view.  Typically this includes
  // the active picture area, but excludes leading blank video lines
  // and any VITC lines.  The offset is specified relative to the
  // rectangle specified by Set/GetStoredView().
  // 
  // Note that The specified display rectangle may exist outside the
  // SampledView or even the StoredView.
  //
  // Succeeds if all of the following are true:
  // - pDisplayHeight, pDisplayWidth, pDisplayXOffset and
  //   pDisplayYOffset are valid pointers.
  // 
  // If this method fails, *pDisplayHeight, *pDisplayWidth,
  // *pDisplayXOffset, and *pDisplayYOffset will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any of pDisplayHeight, pDisplayWidth, pDisplayXOffset, or
  //     pDisplayYOffset are NULL.
  // 
  HRESULT GetDisplayView (
    // Number of pixels in vertical dimension of display view. Optional.
    [out] aafUInt32 *  pDisplayHeight,

    // Number of pixels in horizontal dimension of display view. Optional.
    [out] aafUInt32 *  pDisplayWidth,

    // Number of pixels from the top-left corner of the display view. Optional.
    [out] aafInt32 *  pDisplayXOffset,

    // Number pixels from the top-left corner of the display view. Optional.
    [out] aafInt32 *  pDisplayYOffset);


  //***********************************************************
  //
  // SetFrameLayout()
  //
  // Sets the frame layout.  The frame layout describes whether all
  // data for a complete sample is in one frame or is split into more
  // than/ one field.
  //
  // Values are:
  //
  //    kNoLayout       - Default; not a valid value.
  //    kFullFrame      - Each frame contains a full sample in
  //                      progressive scan lines.
  //    kSeparateFields - Each sample consists of two fields, which
  //                      when interlaced produce a full sample.
  //    kOneField       - Each sample consists of two interlaced
  //                      fields, but only one field is stored in the
  //                      data stream.
  //    kMixedFields    - Similar to FullFrame, except the two fields
  //                      may have been sampled at different times.
  // 
  // Succeeds if all of the following are true:
  // - frameLayout is a valid value
  // 
  // If this method fails, the Frame Layout property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - FrameLayout is not a valid value.
  // 
  HRESULT SetFrameLayout (
    // layout of the frame
    [in] aafFrameLayout_t  FrameLayout);


  //***********************************************************
  //
  // GetFrameLayout()
  //
  // Gets the frame layout.  The frame layout describes whether all
  // data for a complete sample is in one frame or is split into more
  // than one field.
  // 
  // Values are:
  //
  //    kNoLayout       - Default; not a valid value.
  //    kFullFrame      - Each frame contains a full sample in
  //                      progressive scan lines.
  //    kSeparateFields - Each sample consists of two fields, which
  //                      when interlaced produce a full sample.
  //    kOneField       - Each sample consists of two interlaced
  //                      fields, but only one field is stored in the
  //                      data stream.
  //    kMixedFields    - Similar to FullFrame, except the two fields
  //                      may have been sampled at different times.
  // 
  // Succeeds if all of the following are true:
  // - pFrameLayout is a valid pointer
  // 
  // If this method fails, *pFrameLayout will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFrameLayout is NULL.
  // 
  HRESULT GetFrameLayout (
    // layout of the frame
    [out] aafFrameLayout_t *  pFrameLayout);


  //***********************************************************
  //
  // SetVideoLineMap()
  //
  // Sets the VideoLineMap property.  The video line map specifies the
  // scan line in the analog source that corresponds to the beginning
  // of each digitized field.  For single-field video, there is 1
  // value in the array.  For interleaved video, there are 2 values
  // in the array.
  // 
  // Succeeds if all of the following are true:
  // - pVideoLineMap is a valid pointer
  // 
  // If this method fails, the Video Line Map property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pVideoLineMap is NULL.
  // 
  HRESULT SetVideoLineMap (
    // The number of elements in the array
    [in] aafUInt32  numberElements,

    // Array to hold the Video Line Map information
    [in, size_is(numberElements)] aafInt32 *  pVideoLineMap);


  //***********************************************************
  //
  // GetVideoLineMap()
  //
  // Gets the VideoLineMap property.  The video line map specifies the
  // scan line in the analog source that corresponds to the beginning of each
  // digitized field.  For single-field video, there is 1 value in the array.
  // For interleaved video, there are 2 values in the array.
  //
  // The values are written to the array specified by pVideoLineMap,
  // which is of size numberElements.  The required size may be found
  // by calling GetVideoLineMapSize().
  // 
  // Succeeds if all of the following are true:
  // - pVideoLineMap is a valid pointer.
  // - numberElements indicates the array is large enough to hold the
  //   data.
  // 
  // If this method fails, videoLineMap will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - numberElements indicates that the array is too small to hold
  //     the data.
  // 
  HRESULT GetVideoLineMap (
    // The number of elements in the array
    [in] aafUInt32  numberElements,

    // Array to hold the Video Line Map information
    [out, size_is(numberElements)] aafInt32 *  pVideoLineMap);


  //***********************************************************
  //
  // GetVideoLineMapSize()
  //
  // Get the number of elements in the VideoLineMap property array.
  // 
  // Succeeds if all of the following are true:
  // - pNumberElements is a valid pointer
  // 
  // If this method fails, *pNumberElements will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements is NULL.
  // 
  HRESULT GetVideoLineMapSize (
    // The number of elements in the array
    [out] aafUInt32 *  pNumberElements);


  //***********************************************************
  //
  // SetImageAspectRatio()
  //
  // Sets the Image Aspect Ratio property.  This ratio describes the
  // ratio between the horizontal size and the vertical size in the
  // intended final image.
  //
  // Succeeds if all of the following are true:
  // - 
  // 
  // If this method fails, the Image Access Ratio property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetImageAspectRatio (
    // Ratio between horizontal and vertical size
    [in] aafRational_t  ImageAspectRatio);


  //***********************************************************
  //
  // GetImageAspectRatio()
  //
  // Gets the Image Aspect Ratio property.  This ratio describes the
  // ratio between the horizontal size and the vertical size in the
  // intended final image.
  //
  // Succeeds if all of the following are true:
  // - pImageAspectRatio is a valid pointer
  // 
  // If this method fails, *pImageAspectRatio will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pImageAspectRatio is NULL.
  // 
  HRESULT GetImageAspectRatio (
    // Ratio between horizontal and vertical size
    [out] aafRational_t *  pImageAspectRatio);


  //***********************************************************
  //
  // SetAlphaTransparency()
  //
  // Sets the AlphaTransparency property.  This property is optional.
  //
  // Valid values:
  //	kMaxValueTransparent - means the maximum Alpha value is
  //                           transparent
  //    kMinValueTransparent - means the minimum Alpha value is
  //                           transparent
  //
  // Succeeds if all of the following are true:
  // - AlphaTransparency is a valid value.
  // 
  // If this method fails, the AlphaTransparency property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - AlphaTransparency is not a valid value.
  // 
  HRESULT SetAlphaTransparency (
    // Alpha Transparency value.
    [in] aafAlphaTransparency_t  AlphaTransparency);


  //***********************************************************
  //
  // GetAlphaTransparency()
  //
  // Gets the AlphaTransparency property.  This property is optional.
  //
  // Valid values:
  //	kMaxValueTransparent - means the maximum Alpha value is transparent
  //    kMinValueTransparent - means the minimum Alpha value is transparent
  //
  // Succeeds if all of the following are true:
  // - pAlphaTransparency is a valid pointer
  // 
  // If this method fails, pAlphaTransparency not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pAlphaTransparency is NULL.
  // 
  HRESULT GetAlphaTransparency (
    // Alpha Transparency value.
    [out] aafAlphaTransparency_t *  pAlphaTransparency);


  //***********************************************************
  //
  // SetGamma()
  //
  // Sets the Gamma property.  Specifies the expected output gamma
  // setting on the video display device.
  //
  // Succeeds if all of the following are true:
  // - 
  // 
  // If this method fails, the Gamma property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetGamma (
    // Optional
    [in] aafUID_t  Gamma);


  //***********************************************************
  //
  // GetGamma()
  //
  // Gets the Gamma property.  Specifies the expected output gamma
  // setting on the video display device.
  //
  // Succeeds if all of the following are true:
  // - pGamma is a valid pointer
  // 
  // If this method fails, pGamma will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pGamma is NULL.
  // 
  HRESULT GetGamma (
    // Optional.
    [out] aafUID_t *  pGamma);


  //***********************************************************
  //
  // SetImageAlignmentFactor()
  //
  // Sets the ImageAlignmentFactor property.  Specifies the alignment
  // when storing the digital essence.  For example, a value of 16
  // means that the image is stored on 16-byte boundaries.  The
  // starting point for a field will always be a multiple of 16 bytes.
  // If the field does not end on a 16-byte boundary, it is padded
  // out to the next 16-byte boundary.
  //
  // Succeeds if all of the following are true:
  // 
  // If this method fails, the ImageAlignmentFactor property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetImageAlignmentFactor (
    // Optional.
    [in] aafUInt32  ImageAlignmentFactor);


  //***********************************************************
  //
  // GetImageAlignmentFactor()
  //
  // Gets the ImageAlignmentFactor property.  Specifies the alignment when
  // storing the digital essence.  For example, a value of 16 means that the image
  // is stored on 16-byte boundaries.  The starting point for a field will always
  // be a multiple of 16 bytes.  If the field does not end on a 16-byte boundary,
  // it is padded out to the next 16-byte boundary.
  //
  //
  // Succeeds if all of the following are true:
  // - pImageAlignmentFactor is a valid pointer
  // 
  // If this method fails, pImageAlignmentFactor will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pImageAlignmentFactor is NULL.
  // 
  HRESULT GetImageAlignmentFactor (
    // Optional.
    [out] aafUInt32 *  pImageAlignmentFactor);
}



// ************************
//
// Interface IAAFCDCIDescriptor
//
// ************************
//
// The IAAFCDCIDescriptor interface is implemented by objects which
// describe video essence formatted with one luminance component and 
// two color-difference components.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFCDCIDescriptor also implement the following interfaces:
//  - IAAFDigitalImageDescriptor
//  - IAAFFileDescriptor
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(44861703-8AEA-11d2-813C-006097310172),
    helpstring("IAAFCDCIDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFCDCIDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFCDCIDescriptor-supporting object.  This method must be called
  // after allocation, and before any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetComponentWidth()
  //
  // Sets the ComponentWidth property.  Specifies the number of bits
  // used to store each component.  Typical values can be 8, 10,
  // 12, 14, or 16, but others are permitted by the reference
  // implementation.  Each component in a sample is packed
  // contiguously; the sample is filled with the number of bits
  // specified by the optional PaddingBits property.  If  the
  // PaddingBits property is omitted, samples are packed
  // contiguously.
  //
  // If this method fails, the ComponentWidth property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetComponentWidth (
    // Number of bits.
    [in] aafInt32  ComponentWidth);


  //***********************************************************
  //
  // GetComponentWidth()
  //
  // Gets the ComponentWidth property.  Specifies the number of bits
  // used to store each component.  Typical values can be 8, 10,
  // 12, 14, or 16, but others are permitted by the reference
  // implementation.  Each component in a sample is packed
  // contiguously; the sample is filled with the number of bits
  // specified by the optional PaddingBits property.  If the
  // PaddingBits property is omitted, samples are packed
  // contiguously.
  //
  // Succeeds if all of the following are true:
  // - pComponentWidth is a valid pointer.
  // 
  // If this method fails, *pComponentWidth will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponentWidth arg is NULL.
  // 
  HRESULT GetComponentWidth (
    // Address to store the number of bits.
    [out] aafInt32 *  pComponentWidth);


  //***********************************************************
  //
  // SetHorizontalSubsampling()
  //
  // Sets the HorizontalSubsampling property.  Specifies the ratio of
  // luminance sampling to chrominance sampling in the horizontal direction.
  // For 4:2:2 video, the value is 2, which means that there are twice as
  // many luminance values as there are color-difference values.
  // Another typical value is 1; however other values are permitted by
  // the reference implementation.
  //
  // If this method fails, the HorizontalSubsampling property will
  // not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetHorizontalSubsampling (
    // Integer value.
    [in] aafUInt32  HorizontalSubsampling);


  //***********************************************************
  //
  // GetHorizontalSubsampling()
  //
  // Gets the HorizontalSubsampling property.  Specifies the ratio of
  // luminance sampling to chrominance sampling in the horizontal
  // direction.  For 4:2:2 video, the value is 2, which means that
  // there are twice as many luminance values as there are
  // color-difference values.  Another typical value is 1; however
  // other values are permitted by the reference implementation.
  //
  // Succeeds if all of the following are true:
  // - pHorizontalSubsampling is a valid pointer.
  // 
  // If this method fails, *pHorizontalSubsampling will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pHorizontalSubsampling arg is NULL.
  // 
  HRESULT GetHorizontalSubsampling (
    // Address to store the integer value.
    [out] aafUInt32 *  pHorizontalSubsampling);


  //***********************************************************
  //
  // SetVerticalSubsampling()
  //
  // Sets the VerticalSubsampling property.  Specifies the ratio of
  // luminance sampling to chrominance sampling in the vertical direction.
  // For 4:2:2 video, the value is 2, which means that there are twice as
  // many luminance values as there are color-difference values.
  // Another typical value is 1; however other values are permitted by
  // the reference implementation.
  //
  // If this method fails, the VerticalSubsampling property will
  // not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetVerticalSubsampling (
    // Integer value.
    [in] aafUInt32  VerticalSubsampling);


  //***********************************************************
  //
  // GetVerticalSubsampling()
  //
  // Gets the VerticalSubsampling property.  Specifies the ratio of
  // luminance sampling to chrominance sampling in the vertical
  // direction.  For 4:2:2 video, the value is 2, which means that
  // there are twice as many luminance values as there are
  // color-difference values.  Another typical value is 1; however
  // other values are permitted by the reference implementation.
  //
  // Succeeds if all of the following are true:
  // - pVerticalSubsampling is a valid pointer.
  // 
  // If this method fails, *pVerticalSubsampling will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVerticalSubsampling arg is NULL.
  // 
  HRESULT GetVerticalSubsampling (
    // Address to store the integer value.
    [out] aafUInt32 *  pVerticalSubsampling);


  //***********************************************************
  //
  // SetColorSiting()
  //
  // Sets the ColorSiting property.  Specifies how to compute subsampled
  // chrominance values.
  //
  // Valid values are:
  //
  //     kCoSiting  - To calculate subsampled pixels, take the preceding's pixels
  //                  color value, discard the other color values and cosite the
  //                  color with the first luminance value.
  //
  //     kAveraging - To calculate subsampled pixels, take the average of the two
  //                  adjacent pixels' color values and site the color in the center
  //                  of the luminance pixels.
  //
  //     kThreeTap  - To calculate subsampled pixels, take 25 percent of the the previous
  //                  pixel's color value, 50 percent of the first value and 25 percent
  //                  of the second value.  For the first value in a row, use 75 percent
  //                  of that value since there is no previous value.  The kThreeTap value
  //                  is only meaningful when the HorizontalSubsampling propert has a value
  //                  of 2.
  //
  // This property is optional.  The default value is kCoSiting.
  //
  // Succeeds if all of the following are true:
  // - ColorSiting is valid
  //
  // If this method fails, the ColorSiting property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetColorSiting (
    // Color siting value.
    [in] aafColorSiting_t  ColorSiting);


  //***********************************************************
  //
  // GetColorSiting()
  //
  // Gets the ColorSiting property.  Specifies how to compute
  // subsampled chrominance values.
  //
  // Valid values are:
  //
  //     kCoSiting  - To calculate subsampled pixels, take the
  //                  preceding's pixels color value, discard the
  //                  other color values and cosite the color with the
  //                  first luminance value.
  //
  //     kAveraging - To calculate subsampled pixels, take the
  //                  average of the two adjacent pixels' color values
  //                  and site the color in the center of the
  //                  luminance pixels.
  //
  //     kThreeTap  - To calculate subsampled pixels, take 25 percent
  //                  of the the previous pixel's color value, 50
  //                  percent of the first value and 25 percent of the
  //                  second value.  For the first value in a row,
  //                  use 75 percent of that value since there is no
  //                  previous value.  The kThreeTap value is only
  //                  meaningful when the HorizontalSubsampling
  //                  propert has a value of 2.
  //
  // Succeeds if all of the following are true:
  // - pColorSiting is a valid pointer.
  //
  // If this method fails, *pColorSiting will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pColorSiting arg is NULL.
  // 
  HRESULT GetColorSiting (
    // Address to store the color siting value.
    [out] aafColorSiting_t *  pColorSiting);


  //***********************************************************
  //
  // SetBlackReferenceLevel()
  //
  // Sets the BlackReferenceLevel property.  Specifies the digital luminance
  // component component value associated with black.
  //
  // For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  // 10-bit video.  For YUV, the value is 0.  These are typical
  // values; other values will not be disallowed by the reference
  // implementation.
  //
  // The same value is used in CDCI and RGBA when standard colorspace
  // conversion is used.
  //
  // This property is optional.  The default value is 0.
  //
  // If this method fails, the BlackReferenceLevel property will not
  // be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetBlackReferenceLevel (
    // Integer value.
    [in] aafUInt32  BlackReferenceLevel);


  //***********************************************************
  //
  // GetBlackReferenceLevel()
  //
  // Gets the BlackReferenceLevel property.  Specifies the digital
  // luminance component value associated with black.
  //
  // For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  // 10-bit video.  For YUV, the value is 0.  These are typical
  // values; other values will not be disallowed by the reference
  // implementation.
  //
  // The same value is used in CDCI and RGBA when standard colorspace
  // conversion is used.
  //
  // Succeeds if all of the following are true:
  // - pBlackReferenceLevel is a valid pointer.
  // 
  // If this method fails, *pBlackReferenceLevel will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pBlackReferenceLevel arg is NULL.
  // 
  HRESULT GetBlackReferenceLevel (
    // Address to store the integer value.
    [out] aafUInt32 *  pBlackReferenceLevel);


  //***********************************************************
  //
  // SetWhiteReferenceLevel()
  //
  // Sets the WhiteReferenceLevel property.  Specifies the digital
  // luminance component component value associated with white.
  //
  // For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  // 10-bit video.  For YUV, the value is 255 for 8-bit video and
  // 1023 for 10-bit video.  These are typical values; other values
  // will not be disallowed by the reference implementation.
  //
  // This property is optional.  The default value is the maximum
  // unsigned interger value for component size.
  //
  // If this method fails, the WhiteReferenceLevel property will not
  // be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetWhiteReferenceLevel (
    // Integer value.
    [in] aafUInt32  WhiteReferenceLevel);


  //***********************************************************
  //
  // GetWhiteReferenceLevel()
  //
  // Gets the WhiteReferenceLevel property.  Specifies the digital
  // luminance component component value associated with white.
  //
  // For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  // 10-bit video.  For YUV, the value is 255 for 8-bit video and
  // 1023 for 10-bit video.  These are typical values; other values
  // will not be disallowed by the reference implementation.
  //
  // Succeeds if all of the following are true:
  // - pWhiteReferenceLevel is a valid pointer.
  // 
  // If this method fails, *pWhiteReferenceLevel will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pWhiteReferenceLevel arg is NULL.
  // 
  HRESULT GetWhiteReferenceLevel (
    // Address to store the integer value.
    [out] aafUInt32 *  pWhiteReferenceLevel);


  //***********************************************************
  //
  // SetColorRange()
  //
  // Sets the ColorRange property.  Specifies the range of allowable
  // digital chrominance component values.  Chrominance values are
  // unsigned and the range is centered on 128 for 8-bit video and 512
  // for 10-bit video.  This value is used for both chrominance
  // components.
  //
  // For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  // 10-bit video.  For YUV, the range is 255 for 8-bit video and
  // 1023 for 10-bit video.  These are typical values; other values will
  // not be disallowed by the reference implementation.
  //
  // This property is optional.  The default value is the maximum
  // unsigned integer value for component size.
  //
  // Succeeds if all of the following are true:
  // 
  // If this method fails, the ColorRange property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetColorRange (
    // Integer value.
    [in] aafUInt32  ColorRange);


  //***********************************************************
  //
  // GetColorRange()
  //
  // Gets the ColorRange property.  Specifies the range of allowable
  // digital chrominance component values.  Chrominance values are
  // unsigned and the range is centered on 128 for 8-bit video and 512
  // for 10-bit video.  This value is used for both chrominance
  // components.
  //
  // For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  // 10-bit video.  For YUV, the range is 255 for 8-bit video and
  // 1023 for 10-bit video.  These are typical values; other values will
  // not be disallowed by the reference implementation.
  //
  // Succeeds if all of the following are true:
  // - pColorRange is a valid pointer.
  // 
  // If this method fails, *pColorRange will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pColorRange arg is NULL.
  // 
  HRESULT GetColorRange (
    // Address to store the integer value.
    [out] aafUInt32 *  pColorRange);


  //***********************************************************
  //
  // SetPaddingBits()
  //
  // Sets the PaddingBits property.  Specifies the number of bits
  // padded to each pixel.
  //
  // This property is optional.  The default value is 0.
  //
  // If this method fails, the PaddingBits property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetPaddingBits (
    // Number of bits.
    [in] aafInt16  PaddingBits);


  //***********************************************************
  //
  // GetPaddingBits()
  //
  // Gets the PaddingBits property.  Specifies the number of bits
  // padded to each pixel.
  //
  //
  // Succeeds if all of the following are true:
  // - pPaddingBits is a valid pointer.
  // 
  // If this method fails, pPaddingBits will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPaddingBits arg is NULL.
  // 
  HRESULT GetPaddingBits (
    // Address to store the number of bits.
    [out] aafInt16 *  pPaddingBits);
}



// ************************
//
// Interface IAAFEssenceFormat
//
// ************************
//
// The AAFEssenceFormat class represents a collection of parameters
// (such as image height/width, audio sample width) which describes
// a piece of essence.  Each parameter is specified by an AUID, and
// contains a variable length piece of data.
//
// When creating a piece of essence, you should call
// AddFormatSpecifier() for each required or known parameter, and
// the codec will supply defaults for other optional parameters.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.
//


[
    object,
    uuid(34C2DC82-904C-11d2-8088-006008143E6F),
    helpstring("IAAFEssenceFormat Interface"),
    pointer_default(unique)
]
interface IAAFEssenceFormat : IUnknown
{

  //***********************************************************
  //
  // AddFormatSpecifier()
  //
  // Appends a format specifier to the AAFEssenceFormat.  If an
  // essenceFormatCode has already been added, then this call
  // replaces the value, otherwise the value is appended.
  //
  // The value data is passed in as a void * through the "value"
  // argument.  The size of the value must be passed through the
  // valueSize argument.
  // 
  HRESULT AddFormatSpecifier (
    // From aaddefuids.h
    [in] aafUID_constref  essenceFormatCode,

    // Size of preallocated buffer
    [in] aafInt32  valueSize,

    // Value data
    [in, size_is(valueSize)] aafDataBuffer_t  value);


  //***********************************************************
  //
  // GetFormatSpecifier()
  //
  // The data value is returned in a preallocated buffer of size
  // valueSize.
  //
  // The actual number of bytes read is returned in bytesRead.  If the
  // buffer is not big enough to return the entire  value, an error
  // is returned.
  // 
  HRESULT GetFormatSpecifier (
    // From aaddefuids.h
    [in] aafUID_constref  essenceFormatCode,

    // Size of preallocated buffer
    [in] aafInt32  valueSize,

    // Preallocated buffer to hold value
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  value,

    // Number of actual bytes read
    [out] aafInt32*  bytesRead);


  //***********************************************************
  //
  // NumFormatSpecifiers()
  //
  // The data value is returned in a preallocated buffer of size
  // valueSize.
  // 
  HRESULT NumFormatSpecifiers (
    // The number of specifiers present.
    [out] aafInt32*  numSpecifiers);


  //***********************************************************
  //
  // GetIndexedFormatSpecifier()
  //
  // The data value is returned in a preallocated buffer of size
  // valueSize.
  // 
  HRESULT GetIndexedFormatSpecifier (
    // 0-based index
    [in] aafInt32  index,

    // From aaddefuids.h
    [out] aafUID_t*  essenceFormatCode,

    // Size of preallocated buffer
    [in] aafInt32  valueSize,

    // Preallocated buffer to hold value
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  value,

    // Number of actual bytes read
    [out] aafInt32*  bytesRead);
}



// ************************
//
// Interface IAAFEssenceGroup
//
// ************************
//
// This interface provides access to the IAAFEssenceGroup interface,
// which contains multiple representations of the same media within a
// MasterMob.  The IAAFEssenceAccess methods allow specifying
// parameters such as "best quality", or "lowest frame rate" for and
// follow the correct path through the EssenceGroup in order to find
// the media which matches the criteria.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFEssenceGroup also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(e58a8567-2a3e-11D2-bfa4-006097116212),
    helpstring("IAAFEssenceGroup Interface"),
    pointer_default(unique)
]
interface IAAFEssenceGroup : IUnknown
{

  //***********************************************************
  //
  // SetStillFrame()
  //
  // This method sets the still frame property on a essence group to
  // be the source clip passed as the stillFrame argument.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pStillFrame is null.
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetStillFrame (
    // Still Frame source clip 
    [in] IAAFSourceClip * pStillFrame);
    

  //***********************************************************
  //
  // GetStillFrame()
  //
  // Gets the still frame property on a essence group.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppStillFrame is null.
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT GetStillFrame (
    // Still Frame source clip 
    [out] IAAFSourceClip ** ppStillFrame);


  //***********************************************************
  //
  // AppendChoice()
  //
  // Append another choice to this AAFEssenceGroup.
  // 
  // Succeeds if all of the following are true:
  // - the pChoice pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pChoice is null.
  // 
  HRESULT AppendChoice (
    // Source clip to add as a choice 
    [in] IAAFSegment * pChoice);


  //***********************************************************
  //
  // PrependChoice()
  //
  // Prepend another choice to this AAFEssenceGroup.
  // 
  // Succeeds if all of the following are true:
  // - the pChoice pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pChoice is null.
  // 
  HRESULT PrependChoice (
    // Source clip to add as a choice
    [in] IAAFSegment * pChoice);


  //***********************************************************
  //
  // InsertChoiceAt()
  //
  // Insert another choice to this AAFEssenceGroup at the given
  // index.  Choices already existing at the given and higher indices
  // will be moved up by one index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pChoice pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountChoices().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pChoice is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountChoices().
  // 
  HRESULT InsertChoiceAt (
    // place to insert new choice
    [in] aafUInt32  index,

    // Source clip to add as a choice
    [in] IAAFSegment * pChoice);


  //***********************************************************
  //
  // CountChoices()
  //
  // Returns the number of choices attached to this AAFEssenceGroup.,
  // excepting the still frame.
  // 
  // Succeeds if all of the following are true:
  // - the pCount pointer is valid.
  // 
  // If this method fails nothing is written to *pCount.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount is null.
  // 
  HRESULT CountChoices (
    // The number of representations contained within.
    [out] aafUInt32*   pCount);


  //***********************************************************
  //
  // GetChoiceAt()
  //
  // Given an index, returns the corresponding source clip choice.
  // 
  // Succeeds if all of the following are true:
  // - the ppChoice pointer is valid.
  // 
  // If this method fails nothing will be written to *ppChoice.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_MISSING_INDEX
  //   - The given index value is not present.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppChoice arg is NULL.
  // 
  HRESULT GetChoiceAt (
    // The 0-based index into the array
    [in] aafUInt32  index,

    // The representation at that index
    [out] IAAFSegment  ** ppChoice);


  //***********************************************************
  //
  // RemoveChoiceAt()
  //
  // Removes the choice at the given index.  Items already existing at
  // higher indices will be moved down by one index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the ppChoice pointer is valid.
  // - index is less than the value returned by CountChoices().
  // 
  // If this method fails no state will be changed.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppChoice arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountChoices().
  // 
  HRESULT RemoveChoiceAt (
    // The 0-based index into the array
    [in] aafUInt32  index);
}



// ************************
//
// Interface IAAFFiller
//
// ************************
//
// The IAAFFiller interface is supported by objects which serve as
// placeholders for an unknown values for the component duration.
// Typically, a Filler object is used in a Sequence to allow
// positioning of a Segment whem not all of the preceding material has
// been specified.  If a Filler object is played, applications can
// choose any appropiate blank media to play.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFFiller also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(38e6f8a9-2a2c-11d2-8411-00600832acb8),
    helpstring("IAAFFiller Interface"),
    pointer_default(unique)
]

interface IAAFFiller : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // This function will create a new filler object with the given
  // property values.  Length is specified in units of the edit rate
  // of the containing timeline mob slot.
  // 
  // Succeeds if all of the following are true:
  // - this object has not yet been initialized.
  // - the length is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef is null.
  //
  // AAFRESULT_BAD_LENGTH
  //   - length is negative.
  // 
  HRESULT Initialize (
    // Data Definition Object
    [in] IAAFDataDef * pDataDef,

    // Length Property Value
    [in] aafLength_t  length);
}



// ************************
//
// Interface IAAFFindSourceInfo
//
// ************************

 
/***********************************************\
*	Stub only.   Implementation not yet added	*
\***********************************************/


[
    object,
    uuid(9346ACD1-2713-11d2-8035-006008143E6F),
    helpstring("IAAFFindSourceInfo Interface"),
    pointer_default(unique)
]
interface IAAFFindSourceInfo : IUnknown
{


  //***********************************************************
  //
  // GetMob()
  //
  // // This function returns the mob found by the function
  // which generated this IAAFFindSourceInfo as a result.
  //
  // Succeeds if all of the following are true:
  // - the ppMob pointer is valid.
  // 
  // If this method fails nothing will be written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULLOBJECT
  //   - There is no valid mob referenced
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob arg is NULL.
  // 
  HRESULT GetMob (
    // The final media object referenced
    [out] IAAFMob ** ppMob);

  //***********************************************************
  //
  // GetSourceReference()
  //
  // // This function returns the source reference found by the function
  // which generated this IAAFFindSourceInfo as a result.
  //
  // Note: the 3 properties that make up the "source
  // reference" are sourceID, sourceTrackID, and startTime.
  //
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // - the pSourceRef pointer is valid.
  // 
  // If this method fails nothing will be written to *pSourceRef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRef arg is NULL.
  // 
  HRESULT GetSourceReference (
    // Source Reference
    [out] aafSourceRef_t *  pSourceRef);

  //***********************************************************
  //
  // GetLength()
  //
  // Gets the  of this component.
  // This function returns the duration in edit units of the result.
  //	
  // Succeeds if all of the following are true:
  // - the pLength pointer is valid.
  // - the optional length property is present for this object.
  //
  // This method deals with an optional property, which will only be
  // present for time-varying media.
  // 
  // If this method fails nothing will be written to *pLength.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLength arg is NULL.
  //
  // AAFRESULT_BAD_PROP
  //   - the optional length property is not present for this object.
  // 
  HRESULT GetLength (
    // Length of this component
    [retval][out] aafLength_t *  pLength);

  //***********************************************************
  //
  // GetEditRate()
  //
  // This method will get the edit rate for this result.
  // 
  // Succeeds if all of the following are true:
  // - the pEditRate pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditRate arg is NULL.
  // 
  HRESULT GetEditRate (
    // Edit rate property value
    [out,retval] aafRational_t *  pEditRate);

}



// ************************
//
// Interface IAAFOperationGroup
//
// ************************
//
// The IAAFOperationGroup interface is implemented by objects describe
// an operation (such as an effect) affecting the interpretation of
// zero or more input segments.  OperationGroup objects may include
// any object implementing the IAAFSegment interface as source
// material, including another nested OperationGroup object.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFMob is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFOperationGroup also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(3AE3BA82-2C98-11d2-8042-006008143E6F),
    helpstring("IAAFOperationGroup Interface"),
    pointer_default(unique)
]
interface IAAFOperationGroup : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes an operation group object with the given property
  // values.
  //
  // This function takes an already created operation definition
  // object as an argument.  To add slots to the operation group, call
  // AddNewSlot.  To add renderings, call SetRender.
  // 
  HRESULT Initialize (
    // Data Definition Object
    [in] IAAFDataDef * pDataDef,

    // Length property value
    [in] aafLength_t  length,

    // Operation Definition object
    [in] IAAFOperationDef * operationDef);


  //***********************************************************
  //
  // GetOperationDefinition()
  //
  // Returns the operation definition for this invocation.
  // 
  // Succeeds if all of the following are true:
  // - the ppOperationDef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppOperationDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppOperationDef arg is NULL.
  // 
  HRESULT GetOperationDefinition (
    // Operation definition object
    [out] IAAFOperationDef ** ppOperationDef);

  //***********************************************************
  //
  // SetOperationDefinition()
  //
  // This function sets the operation definition for the given operation
  // group.
  // 
  // Succeeds if all of the following are true:
  // - the pOperationDef pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOperationDef arg is NULL.
  // 
  HRESULT SetOperationDefinition (
    // Operation definition object
    [in] IAAFOperationDef * pOperationDef);

  //***********************************************************
  //
  // GetRender()
  //
  // Returns the segment that represents the optional rendering on an
  // operation group object.  Working and final renderings are handled
  // by using an IAAFEssenceGroup as the segment. 
  // 
  // Succeeds if all of the following are true:
  // - the ppSourceRef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppSourceRef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSourceRef arg is NULL.
  // 
  HRESULT GetRender (
    // Final rendering segment
    [out] IAAFSourceReference ** ppSourceRef);


  //***********************************************************
  //
  // IsATimeWarp()
  //
  // This boolean function returns whether or not an operation group
  // is a timewarp effect.
  // 
  // Succeeds if all of the following are true:
  // - the pIsTimeWarp pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsTimeWarp.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsTimeWarp arg is NULL.
  // 
  HRESULT IsATimeWarp (
    // Returned boolean value
    [out, retval] aafBoolean_t *  pIsTimeWarp);


  //***********************************************************
  //
  // GetBypassOverride()
  //
  // Returns the optional bypass override propertyvalue from the input
  // operation def object.
  // 
  // Succeeds if all of the following are true:
  // - the pBypassOverride pointer is valid.
  // 
  // If this method fails nothing will be written to *pBypassOverride.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - pBypassOverride arg is NULL.
  // 
  HRESULT GetBypassOverride (
    // Bypass override property value
    [out] aafUInt32 *  pBypassOverride);


  //***********************************************************
  //
  // CountSourceSegments()
  //
  // Returns the number of media sources to the operation group.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT CountSourceSegments (
    // Number of source media segments in the operation group
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // IsValidTranOperation()
  //
  // Verifies that the input operation group object can be used in a
  // transition.
  // 
  // Succeeds if all of the following are true:
  // - the pValidTransition pointer is valid.
  // 
  // If this method fails nothing will be written to *pValidTransition.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pValidTransition arg is NULL.
  // 
  HRESULT IsValidTranOperation (
    // TRUE if the operation group is valid in a transition
    [out] aafBoolean_t *  pValidTransition);


  //***********************************************************
  //
  // CountParameters()
  //
  // Returns the number of parameters in the operation group.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT CountParameters (
    // Number of parameter slots in the operation group
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // AddParameter()
  //
  // Adds a new parameter object.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_PARAMETER
  //   - The given argID is already present.
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  // 
  HRESULT AddParameter (
    // Parameter to place in operation group slot
    [in] IAAFParameter * pParameter);


  //***********************************************************
  //
  // AppendInputSegment()
  //
  // Appends another input segment to an operation group.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_INDEX
  //   - The given index value is already present.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment arg is NULL.
  // 
  HRESULT AppendInputSegment (
    // Segment to place in operation group
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // PrependInputSegment()
  //
  // Prepends another input segment to an operation group.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_INDEX
  //   - The given index value is already present.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment arg is NULL.
  // 
  HRESULT PrependInputSegment (
    // Segment to place in operation group
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // InsertInputSegmentAt()
  //
  // Inserts an input segment to an operation group at the given
  // index.  The existing segments at the given and higher indices are
  // moved up by one to make room.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // - the index is not greater than the value returned by
  //   CountInputSegments().
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_INDEX
  //   - The given index value is already present.
  //
  // AAFRESULT_BAD_INDEX
  //   - index is greater than the value returned by
  //     CountInputSegments().
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment arg is NULL.
  // 
  HRESULT InsertInputSegmentAt (
    // index to place this segment
    [in] aafUInt32  index,

    // Segment to place in operation group
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // SetRender()
  //
  // This function sets the final rendering for the given operation
  // group to the input source clip.  (Multiple renderings may exist if
  // the source clip refers to a master mob that contains a Essence
  // group.)
  // 
  // Succeeds if all of the following are true:
  // - the ppSourceRef pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSourceRef arg is NULL.
  // 
  HRESULT SetRender (
    // A segment containing a representation of the rendering
    [in] IAAFSourceReference * ppSourceRef);


  //***********************************************************
  //
  // SetBypassOverride()
  //
  // This function sets the optional bypass override property on the
  // given operation group object.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetBypassOverride (
    // Bypass override
    [in] aafUInt32  bypassOverride);


  //***********************************************************
  //
  // GetParameters()
  //
  // returns an enumerator across all parameters.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT GetParameters (
    // Parameter enumerator
    [out] IEnumAAFParameters ** ppEnum);


  //***********************************************************
  //
  // LookupParameter()
  //
  // Given an argID, returns the corresponding parameter slot and
  // parameter slot value.
  // 
  // Succeeds if all of the following are true:
  // - the ppParameter pointer is valid.
  // 
  // If this method fails nothing will be written to *ppParameter.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_MISSING_PARAMETER
  //   - The given argID is not present.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppParameter arg is NULL.
  // 
  HRESULT LookupParameter (
    // Arg ID
    [in] aafArgIDType_constref  argID,

    // Parameter object
    [out] IAAFParameter ** ppParameter);


  //***********************************************************
  //
  // GetInputSegmentAt()
  //
  // Given an index, returns the corresponding input segment.
  // Working and final renderings are handled by using an
  // IAAFEssenceGroup as the segment.
  // 
  // Succeeds if all of the following are true:
  // - the ppInputSegment pointer is valid.
  // 
  // If this method fails nothing will be written to *ppInputSegment.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_MISSING_INDEX
  //   - The given index value is not present.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppInputSegment arg is NULL.
  // 
  HRESULT GetInputSegmentAt (
    // 0-based index into the effet inputs
    [in] aafUInt32  index,

    // Input segment
    [out] IAAFSegment ** ppInputSegment);


  //***********************************************************
  //
  // RemoveInputSegmentAt()
  //
  // Removes the segment at the given index.  Existing segments at
  // higher indices are moved down by one to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the result of CountInputSegments().
  // 
  // If this method fails no state will be changed.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_MISSING_INDEX
  //   - The given index value is not present.
  // 
  HRESULT RemoveInputSegmentAt (
    // 0-based index into the effect inputs
    [in] aafUInt32  index);
}



// ************************
//
// Interface IAAFGPITrigger
//
// ************************

//
// The IAAFGPITrigger interface is implemented by objects which represent
// an trigger action that should be taken when its position in time is
// reached.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFMobSlot is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
// 
//


//
// Objects that implement IAAFGPITrigger also implement the following interfaces:
//  - IAAFEvent
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(e684d78c-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFGPITrigger Interface"),
    pointer_default(unique)
]
interface IAAFGPITrigger : IUnknown
{


  //***********************************************************
  //
  // GetActiveState()
  //
  // Sets *pActiveState to AAFTrue it the event is on otherwise
  // sets it to AAFFalse.
  //
  // Succeeds if:
  // - The pActiveState pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - The pActiveState pointer is NULL.
  // 
  HRESULT GetActiveState (
    // pointer to the result
    [out, retval] aafBoolean_t *  pActiveState);


  //***********************************************************
  //
  // SetActiveState()
  //
  // Set to AAFTrue to turn the trigger on or AAFFalse
  // to turn the trigger off.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetActiveState (
    // the active state of the trigger
    [in] aafBoolean_t  ActiveState);

}



// ************************
//
// Interface IAAFHeader
//
// ************************
//
// The IAAFHeader interface provides file-wide information and
// indexes.  Each AAF file has one and only one instance of an object
// which supports IAAFHeader.
//
// When an IAAFHeader-supporting object is created, the contained
// dictionary object is automatically created.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFHeader also implement the following interfaces:
//  - IAAFEndian
//  - IAAFObject

[
    object,
    uuid(B1A21382-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFHeader Interface"),
    pointer_default(unique)
]
interface IAAFHeader : IUnknown
{
  //***********************************************************
  //
  // LookupMob()
  //
  // Looks up the Mob that matches the given mob id and puts it into
  // the ppMob argument.  The returned mob interface is AddRef()ed
  // before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppMob pointer is valid.
  // 
  // If this method fails nothing will be written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob is null
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the requested mob wasn't found.
  // 
  HRESULT LookupMob (
    // The Mob ID
    [in, ref] aafMobID_constref  mobID,

    // Matching Mob
    [out,retval] IAAFMob ** ppMob);


  //***********************************************************
  //
  // CountMobs()
  //
  // Writes the number of matches for the given mob kind into the
  // *pNumMobs argument.
  // 
  // Succeeds if all of the following are true:
  // - the pNumMobs pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumMobs.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumMobs is null.
  // 
  HRESULT CountMobs (
    // The mob kind to count
    [in] aafMobKind_t  mobKind,

    // Total number of mobs of kind mobKind
    [out, retval] aafNumSlots_t *  pResult);


  //***********************************************************
  //
  // GetMobs()
  //
  // Places an enumerator for mobs that apply to the criteria into the
  // *ppEnum argument.  If pSearchCriteria is null, all mobs are
  // returned.   The searchTag field of pSearchCriteria, and exactly
  // ONE of the fields in the union (tags.mobID, tags.name, etc. )
  // must be set.  Only one search criterion may be specified.  The
  // returned enumerator is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetMobs (
    // Search Criteria for enumeration
    [in] aafSearchCrit_t *  pSearchCriteria,

    // Mob Enumeration
    [out, retval] IEnumAAFMobs ** ppEnum);


  //***********************************************************
  //
  // AddMob()
  //
  // Appends the given mob to the header.  If the given mob is already
  // contained this method will do nothing and will return success.
  // 
  // Succeeds if all of the following are true:
  // - the pMob pointer is valid.
  // - the given mob is not already part of this collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMob is null.
  //
  // AAFRESULT_DUPLICATE_MOBID
  //   - the given mob is already contained.
  // 
  HRESULT AddMob (
    // Mob to add
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // RemoveMob()
  //
  // // Removes the given mob from the header.
  //
  // Succeeds if all of the following are true:
  // - the pMob pointer is valid.
  // - the given mob is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMob is null.
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the given mob is not already contained.
  // 
  HRESULT RemoveMob (
    // Mob to remove
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // CountEssenceData()
  //
  // Writes the total number of essence data into the *pNumEssenceData
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pNumEssenceData pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pNumEssenceData.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumEssenceData is null.
  // 
  HRESULT CountEssenceData (
    // Total number of essence data
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  // // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT IsEssenceDataPresent (
    // A Unique File Mob ID
    [in, ref] aafMobID_constref  fileMobID,

    // The Essence File Format
    [in] aafFileFormat_t  fmt,

    // True if the essence is found
    [out,retval] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // EnumEssenceData()
  //
  // Places an enumerator for essence that applies to the criteria
  // into the *ppEnum argument.  The returned enumerator is
  // AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the pMediaCriteria pointer is valid.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pMediaCriteria or ppEnum is null.
  // 
  HRESULT EnumEssenceData (
    // Essence Enumeration
    [out,retval] IEnumAAFEssenceData ** ppEnum);


  //***********************************************************
  //
  // AddEssenceData()
  //
  // Appends the given essence data object to the header.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pEssenceData pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_MOBID
  //   - The given mob has already been added.  The validation is done by comparing
  //		mobIDs, which should be unique.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  // 
  HRESULT AddEssenceData (
    // Essence data object to append
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  // // Removes the given EssenceData from the header.
  //
  // Succeeds if all of the following are true:
  // - the pEssenceData pointer is valid.
  // - the given EssenceData is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  //
  // AAFRESULT_ESSENCE_NOT_FOUND
  //   - the given EssenceData is not already contained.
  // 
  HRESULT RemoveEssenceData (
    // EssenceData to remove
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // LookupEssenceData()
  //
  // Looks up the EssenceData that matches the given mob id and puts it into
  // the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  // before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEssenceData pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEssenceData.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEssenceData is null
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the requested EssenceData wasn't found.
  // 
  HRESULT LookupEssenceData (
    // The Mob ID
    [in, ref] aafMobID_constref  mobID,

    // Matching EssenceData
    [out,retval] IAAFEssenceData ** ppEssenceData);

  //***********************************************************
  //
  // GetDictionary()
  //
  // Places the dictionary that contains all types of aaf definition
  // objects into the *ppDictionary argument.  The returned dictionary
  // is AddRef()ed before it is returned.  Note that the dictionary
  // is automatically created when the header object is created.
  // 
  // Succeeds if all of the following are true:
  // - the ppDictionary pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDictionary is null.
  // 
  HRESULT GetDictionary (
    // The AAF Dictionary
    [out, retval] IAAFDictionary ** ppDictionary);


  //***********************************************************
  //
  // GetLastIdentification()
  //
  // Places the identification of the last entity that modified the
  // file into the *ppIdentification argument.  The returned
  // identification is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentification pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppIdentification is null.
  // 
  HRESULT GetLastIdentification (
    // Indentification Object
    [out,retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // LookupIdentification()
  //
  // Places the Identification that matches the given generation into
  // the *ppIdentification argument.  The returned identification is
  // AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentification pointer is valid.
  // - the given generation was found.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppIdentification is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given generation was not found..
  // 
  HRESULT LookupIdentification (
    // Unique Generation ID
    [in, ref] aafUID_constref  generation,

    // Indentification Object
    [out,retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // CountIdentifications()
  //
  // Writes the number of identification objects into the *pResult
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountIdentifications (
    // Total number of identification objects
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetIdentifications()
  //
  // Places an enumerator for all Identifications criteria into	the
  // *ppEnum argument.  The returned enumerator is AddRef()ed before
  // it is returned.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetIdentifications (
    // Indentification Enumeration
    [out,retval] IEnumAAFIdentifications ** ppEnum);


  //***********************************************************
  //
  // AppendIdentification()
  //
  // Appends the given Identification class to the header.  This
  // method does not attempt to identify duplicate identifications, so
  // it will succeed even if an identical identification has already
  // been appended.
  // 
  // Succeeds if all of the following are true:
  // - the pIdent pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIdent is null.
  // 
  HRESULT AppendIdentification (
    // Identification to append
    [in] IAAFIdentification * pIdent);


  //***********************************************************
  //
  // GetIdentificationAt()
  //
  // Retrieves the indexed identification from the header.
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentification pointer is valid.
  // - index is less than the value returned by CountIdentifications().
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppIdent is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to result of
  //     CountIdentifications().
  // 
  HRESULT GetIdentificationAt (
    // Index of identification to retrieve
    [in] aafUInt32  index,

    // Retrieved identification
    [out, retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  // Return the version of the Reference Implementation currently
  // running on this machine, which implements these interfaces.
  // 
  // Succeeds if all of the following are true:
  // - the pVersion pointer is valid.
  // 
  // If this method fails nothing is written to *pVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion is null.
  // 
  HRESULT GetRefImplVersion (
    // The Reference Implementation Version
    [out, retval] aafProductVersion_t *  pVersion);


  //***********************************************************
  //
  // GetFileRevision()
  //
  // Return the File Revision property.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pRevision pointer is valid.
  // 
  // If this method fails nothing is written to *pRevision.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pRevision is null.
  // 
  HRESULT GetFileRevision (
    // The File Version
    [out, retval] aafVersionType_t *  pRevision);


  //***********************************************************
  //
  // GetLastModified()
  //
  // Return the Last Modified property.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pTimeStamp pointer is valid.
  // 
  // If this method fails nothing is written to *pTimeStamp.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimeStamp is null.
  // 
  HRESULT GetLastModified (
    // The modification date-time stamp
    [out, retval] aafTimeStamp_t *  pTimeStamp);


  //***********************************************************
  //
  // GetContentStorage()
  //
  // Places the Content Storage object attached to the header into the
  // *ppStorage argument.
  //
  // The returned content storage object is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppStorage pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppStorage is null.
  // 
  HRESULT GetContentStorage (
    // Returned Content Storage object
    [out] IAAFContentStorage ** ppStorage);


}


// ************************
//
// Interface IAAFIdentification
//
// ************************
//
// The IAAFIdentification interface provides information about an
// application that either created or modified the AAF file.
//
// If a file was opened for modification by many applications in its
// lifetime, then there will be multiple Identification objects.
// These are kept in an ordered array, with the first entry being the
// file creator, and the last entry being the last application to
// modify the file.
//
// The identification object is useful for technical support when
// diagnosing problem AAF files, as it tells which applications (and
// versions) have touched the file.   If a file has been modified by
// multiple applications, then the date and productID fields can be
// used to tell which changes to the file were made by a particular
// application.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFIdentification also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(B1A2137E-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFIdentification Interface"),
    pointer_default(unique)
]
interface IAAFIdentification : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated IAAFIdentification-supporting
  // object.  This method must be called after allocation, and before
  // any other method can be called.
  //
  // This method fills in the mandatory properties of the object.  The
  // values of the following required properties are set based on the
  // information given in arguments to this method:
  // - companyName
  // - productname
  // - productVersionString
  // - productID
  // 
  // The following mandatory properties will be filled in
  // automatically by the reference implementation:
  // - date
  // - generationAUID
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - companyName is a valid pointer
  // - productName is a valid pointer
  // - productVersionString is a valid pointer
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - companyName, productName, or productVersionString is NULL.
  // 
  HRESULT Initialize (
    // company name string
    [in] aafCharacter_constptr  companyName,

    // product name string
    [in] aafCharacter_constptr  productName,

    // product version string
    [in] aafCharacter_constptr  productVersionString,

    // product identification
    [in] aafUID_constref  productID);


  //***********************************************************
  //
  // GetCompanyName()
  //
  // Gets the Company Name string property.
  // 
  // Writes the CompanyName property, with a trailing null
  // character, into the pCompanyName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the CompanyName property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetCompanyNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pCompanyName.
  // 
  // Succeeds if:
  // - The pCompanyName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   CompanyName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCompanyName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold CompanyName.
  // 
  HRESULT GetCompanyName (
    // buffer into which CompanyName is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pCompanyName,

    // size of *pCompanyName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetCompanyNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetCompanyName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetCompanyNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetProductName()
  //
  // Gets the Product Name string property.
  // 
  // Writes the ProductName property, with a trailing null
  // character, into the pProductName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the ProductName property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetProductNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pProductName.
  // 
  // Succeeds if:
  // - The pProductName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   ProductName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pProductName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold ProductName.
  // 
  HRESULT GetProductName (
    // buffer into which ProductName is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pProductName,

    // size of *pProductName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetProductNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetProductName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetProductNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetProductVersionString()
  //
  // Gets the Product Version string property.
  // 
  // Writes the ProductVersionString property, with a trailing null
  // character, into the pProductVersionString buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the ProductVersionString property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetProductVersionStringBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pProductVersionString.
  // 
  // Succeeds if:
  // - The pProductVersionString pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   ProductVersionString.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pProductVersionString arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold ProductVersionString.
  // 
  HRESULT GetProductVersionString (
    // buffer into which ProductVersionString is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pProductVersionString,

    // size of *pProductVersionString buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetProductVersionStringBufLen()
  //
  // Returns size of buffer (in bytes) required for GetProductVersionString().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetProductVersionStringBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetProductVersion()
  //
  // Gets the Product Version property associated with this
  // identification object and places it into *pVersion.
  // 
  // Succeeds if all of the following are true:
  // - the pVersion pointer is valid.
  // 
  // If this method fails, nothing will be written to *pVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion arg is NULL.
  // 
  HRESULT GetProductVersion (
    // The Product Version
    [out] aafProductVersion_t *  pVersion);


  //***********************************************************
  //
  // SetProductVersion()
  //
  // Set the Product Version property to the value specified in
  // pVersion.  A copy is made of the data so the caller retains
  // ownership of the *pVersion struct and is responsible for
  // de-allocating it.
  // 
  // If this method fails the Product Version property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetProductVersion (
    // The Product Version
    [in] aafProductVersion_constref  version);


  //***********************************************************
  //
  // GetProductID()
  //
  // Obtains the Product ID, which is the identification number
  // assigned to the application and vendor of the application which
  // attached this object to the AAF file.  This ID is written into
  // the caller-allocated aafUID_t specified by the pProductID
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pProductID pointer is valid.
  // 
  // If this method fails nothing will be written to *pProductID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pProductID arg is NULL.
  // 
  HRESULT GetProductID (
    // The Product ID
    [out] aafUID_t *  pProductID);


  //***********************************************************
  //
  // GetDate()
  //
  // Writes the Date-time Stamp property into the caller-allocated
  // aafTimeStamp_t specified by the pTimeStamp argument.  The
  // date-time stamp recorded in this object corresponds to the time
  // that this file was created or modified upon the occasion that
  // this object was added to the file.
  //
  // Note: This is a read-only property.
  // 
  // Succeeds if all of the following are true:
  // - the pTimeStamp pointer is valid.
  // 
  // If this method fails nothing will be written to *pTimeStamp.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimeStamp arg is NULL.
  // 
  HRESULT GetDate (
    // The date-time stamp
    [out] aafTimeStamp_t *  pTimestamp);


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  // Obtains the version of the Reference Implementation which
  // created this identification object and writes it into the
  // caller-allocated aafProductVersion_t specified by the pVersion
  // argument.
  //
  // Note: This is a read-only property.
  // 
  // Succeeds if all of the following are true:
  // - the pVersion pointer is valid.
  // 
  // If this method fails nothing will be written to *pVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion arg is NULL.
  // 
  HRESULT GetRefImplVersion (
    // The Reference Implementation Version
    [out] aafProductVersion_t *  pVersion);


  //***********************************************************
  //
  // GetPlatform()
  //
  // Gets the Platform string property.
  //
  // This information is provided only to allow diagnostic printing of
  // platform information to be read by humans.  The format of the
  // strings is not guaranteed to remain the same for a given
  // platform.  Having said that, the possible values currently
  // returned are:
  // - "Win32" for Intel/Win32 platforms
  // - "MacOS" for MacOS platforms
  // - "Unknown" for unknown platforms
  // 
  // Writes the Platform property, with a trailing null
  // character, into the pPlatform buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Platform property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetPlatformBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pPlatform.
  // 
  // Succeeds if:
  // - The pPlatform pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Platform.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPlatform arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Platform.
  // 
  HRESULT GetPlatform (
    // buffer into which Platform is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pPlatform,

    // size of *pPlatform buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetPlatformBufLen()
  //
  // Returns size of buffer (in bytes) required for GetPlatform().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetPlatformBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetGenerationID()
  //
  // Obtains the generation of this AAF file, which was generated at
  // the time this identification object was created.  If a file was
  // opened for modification by many applications in its lifetime,
  // then there will be multiple Identification objects.  This is
  // written into the caller-allocated aafUID_t specified by the
  // pGeneration argument.
  // 
  // Note: This is a read-only property.
  // 
  // Succeeds if all of the following are true:
  // - the pGeneration pointer is valid.
  // 
  // If this method fails nothing will be written to *pGeneration.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pGeneration arg is NULL.
  // 
  HRESULT GetGenerationID (
    // The unique generation
    [out] aafUID_t *  pGeneration);
}



// ************************
//
// Interface IAAFInterpolationDef
//
// ************************
//
// This interface is used with an object representing a particular
// kind of interpolator, which may be implemented by one or more
// AAFPluginDescriptors.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFInterpolationDef also implement the following interfaces:
//  - IAAFDefObject
//  - IAAFObject

[
    object,
    uuid(293600A3-0D37-11d3-80A9-006008143E6F),
    helpstring("IAAFInterpolationDef Interface"),
    pointer_default(unique)
]
interface IAAFInterpolationDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new DefObject
    [in, string] aafCharacter_constptr  pName,

    // Description for new DefObject
    [in, string] aafCharacter_constptr  pDescription);


}



// ************************
//
// Interface IAAFKLVData
//
// ************************
//
// The IAAFKLVData interface is implemented by objects that
// specify an User defined tag and value.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFKLVData also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(46114414-0676-11d4-A356-009027DFCA6A),
    helpstring("IAAFKLVData Interface"),
    pointer_default(unique)
]
interface IAAFKLVData : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new KLVData object to be interpreted using the
  // given given key.  The key must have been registered using dictionary->RegisterKLVDataKey()
  // in order to use the byte swapping functionality of the type model.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pName is a valid pointer.
  // - pTypeDef is a valid pointer and registered
  // - pValue is a valid pointer
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeDef or pValue arg is NULL.
  // AAFRESULT_NOT_VALID_KEY
  //   - The  given key must not resolve to a builtin type.  For most purposes, use
  //     IAAFTypeDefRename to rename an existing type.
  //
  // 
  // 
  HRESULT Initialize (
    // Key of the following value data
    [in] aafUID_t  key,

    // Length of preallocated buffer
    [in] aafUInt32  length,

    // buffer containing value
    [in, size_is(length)] aafDataBuffer_t  pValue);

  //***********************************************************
  //
  // GetKey()
  //
  // Returns the type definition for this invocation.
  // 
  // Succeeds if all of the following are true:
  // - the pKey pointer is valid.
  // 
  // If this method fails nothing will be written to *pKey.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - pKey arg is NULL.
  // 
  HRESULT GetKey (
    // The key of this object
    [out] aafUID_t*  pKey);


  //***********************************************************
  //
  // GetValue()
  //
  // Writes the value into the pValue buffer.  The buffer is allocated
  // by the caller, and the size of the buffer is given by
  // valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  // 
  HRESULT GetValue (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // Preallocated buffer to hold value
    [out, size_is(valueSize), length_is(*bytesRead)] aafDataBuffer_t  pValue,

    // Number of actual bytes read
    [out] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the GetValue() method.
  // The value is placed into the location specified by pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  // 
  HRESULT GetValueBufLen (
    // Pointer to an variable used to return the length
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // SetValue()
  //
  // The data value is set from a buffer of size valueSize and type.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue is null.
  // 
  HRESULT SetValue (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // buffer containing value
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

}



// ************************
//
// Interface IAAFLocator
//
// ************************
//
// The IAAFLocator interface is implemented by objects that provide
// information to help find a file that contains the essence.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFLocator is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFLocator also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(d4f89061-69d6-11d2-841b-00600832acb8),
    helpstring("IAAFLocator Interface"),
    pointer_default(unique)
]
interface IAAFLocator : IUnknown
{

  //***********************************************************
  //
  // SetPath()
  //
  // Sets the Path string property.
  //
  // Set the Path property to the value specified in
  // pPath.  A copy is made of the data so the caller
  // retains ownership of the *pPath buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pPath pointer is valid.
  // 
  // If this method fails the Path property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPath arg is NULL.
  // 
  HRESULT SetPath (
    // buffer from which Path is to be read
    [in, string] aafCharacter_constptr  pPath);


  //***********************************************************
  //
  // GetPath()
  //
  // Gets the Path string property.
  // 
  // Writes the Path property, with a trailing null
  // character, into the pPath buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Path property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetPathBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pPath.
  // 
  // Succeeds if:
  // - The pPath pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Path.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPath arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Path.
  // 
  HRESULT GetPath (
    // buffer into which Path is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pPath,

    // size of *pPath buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetPathBufLen()
  //
  // Returns size of buffer (in bytes) required for GetPath().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetPathBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);
}



// ************************
//
// Interface IAAFMasterMob
//
// ************************
//
// The IAAFMasterMob interface is implemented by objects which provide
// access to the File Source Mobs and EssenceData objects.  The Master
// Mob object is used to provide a level of indirection for accessing
// Source Mobs from Composition Mobs.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFMasterMob also implement the following interfaces:
//  - IAAFSearchSource
//  - IAAFMob
//  - IAAFObject

[
    object,
    uuid(b1a21372-1a7d-11d2-bf78-00104bc9156d),
    helpstring("IAAFMasterMob Interface"),
    pointer_default(unique)
]
interface IAAFMasterMob : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty IAAFMasterMob-supporting
  // object.  This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


  //***********************************************************
  //
  // AddMasterSlot()
  //
  // This function adds a slot to the specified Master Mob that
  // references the specified a slot in the specified Source Mob. The
  // new slot in the Master Mob contains a Source Clip that specifies
  // the Source Mob in its source reference properties.  Typically this
  // is done automatically by passing the Master Mob handle to
  // AAFMedia::Create, but this function allows you to add it later.
  //
  // Note: If pSlotName is passed in with zero length, then the
  // slot is not assigned a name.  Slot names are not used by the
  // SDK, and exist only so the user can name slots.
  // 
  // Succeeds if all of the following are true:
  // (more conditions here)
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - One or more of the following parameters are NULL pSourceMob,
  //     pSlotName, and pDataDef.
  //
  // AAFRESULT_INVALID_DATADEF
  //   - The data kind of the source MOB slot to be added to the Master
  //     Mob does not match what is specfied in pDataDef.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Source Mob slot was not found.
  //
  // AAFRESULT_SLOT_EXISTS
  //   - The specified Master slot ID already exists.
  // 
  HRESULT AddMasterSlot (
    // Data kind of new slot.  Requires a data kind valid for a media
	// stream. Valid data kinds are:
    // - DDEF_Picture
    // - DDEF_Sound
    [in] IAAFDataDef * pDataDef,

    // Slot ID of the Source Mob slot to be added to the Master Mob
    [in] aafSlotID_t  sourceSlotID,

    // Source Mob containing the slot to be added to the Master Mob
    [in] IAAFSourceMob * pSourceMob,

    // SlotID assigned to the new Master Mob slot
    [in] aafSlotID_t  masterSlotID,

    // Name to assign to new slot in Master Mob
    [in, string] aafCharacter_constptr  pSlotName);


  //***********************************************************
  //
  // GetTapeName()
  //
  // Finds the tape Source Mob associated with a Master Mob slot
  // and writes the name of the tape, which is stored in the
  // Mobs Name property, into the pTapeName buffer.  The buffer is
  // allocated by the caller.  The size of the buffer is given by
  // bufSize.  If the property name has not yet been set, a
  // zero-length string will be written (that is, only the trailing
  // null character).
  // 
  // Caller may call GetTapeNameBufLen() to determine the required
  // buffer size.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pTapeName pointer is valid.
  // - the specified master slot was found.
  // - the specified master slot contains a tape mob.
  // - bufSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pTapeName.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeName arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Master Slot was not found.
  //
  // AAFRESULT_NOT_TAPEMOB
  //   - The specified Master Slot does not contain a Tape MOB.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  // 
  HRESULT GetTapeName (
    // SlotID of the Master Mob slot
    [in] aafUInt32  masterSlotID,

    // The returned name
    [out, size_is(bufSize), string] aafCharacter *  pTapeName,

    // the size of the pTapeName buffer
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetTapeNameBufLen()
  //
  // Returns the length of buffer required for the GetTapeName()
  // method.  The value is placed into the location specified by
  // pLen.  The value will include space required for the trailing
  // null character.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Master Slot was not found.
  //
  // AAFRESULT_NOT_TAPEMOB
  //   - The specified Master Slot does not contain a Tape MOB.
  // 
  HRESULT GetTapeNameBufLen (
    // SlotID of the Master Mob slot
    [in] aafUInt32  masterSlotID,

    // required buffer length
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNumRepresentations()
  //
  // This function returns the number of media representations
  // available for the specified SlotID on a specified Master
  // Mob. This function is meant to work with
  // GetRepresentationSourceClip, so that you can iterate through
  // all of the choices yourself.  In most cases, you can use
  // GetCriteriaSourceClip to handle multiple
  // representations.  This function and
  // GetRepresentationSourceClip are lower-level functions.
  //
  // Succeeds if all of the following are true:
  // - the pNumReps pointer is valid.
  //
  // If this method fails nothing will be written to *pNumReps.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumReps arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The Master Slot specified by slotID was not found.
  // 
  HRESULT GetNumRepresentations (
    // SlotID
    [in] aafSlotID_t  slotID,

    // number of representations
    [out, retval] aafNumSlots_t *  pNumReps);


  //***********************************************************
  //
  // GetRepresentation()
  //
  // This method returns the indexed media representation for the
  // specified Master Mob, SlotID, and index.  This call is meant to
  // work with GetNumRepresentations, so that you can iterate through
  // all of the choices yourself.  This method uses an integer index,
  // not an iterator.  The function GetRepresentationSourceClip takes
  // an index between 1 and the number of representations
  // [inclusive], and returns the indexed Source Mob. You can make
  // calls to functions such as AAFMedia::GetVideoInfo and
  // AAFMedia::IsMediaContiguous to determine which media is the best
  // fit.
  //
  // The returned source clip is AddRef()ed before it is returned.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the ppSourceClip pointer is valid.
  //
  // If this method fails nothing will be written to *ppSourceClip.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSourceClip arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Master Slot was not found.
  //
  // AAFRESULT_BADINDEX
  //   - No Source Mob at specified index.
  // 
  HRESULT GetRepresentation (
    // Slot ID
    [in] aafSlotID_t  slotID,

    // Index of requested representation
    [in] aafUInt32  index,

    // Requested Source Clip
    [out] IAAFSegment ** ppSourceClip);


  //***********************************************************
  //
  // GetCriteriaSegment()
  //
  // Returns the Segment on the specified slot of a Master Mob
  // that references the Source Mob that best meets the specified
  // criteria.  This function will work whether multiple media
  // representations exist or not.
  //
  // The returned segment is AddRef()ed before it is returned.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the ppSegment pointer is valid.
  //
  // If this method fails nothing will be written to *ppSegment.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSegment arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Master Slot was not found.
  // 
  HRESULT GetCriteriaSegment (
    // Slot ID
    [in] aafSlotID_t  slotID,

    // Index of requested representation.  Note: the
	// aafMediaCriteria_t is defined as the following structure:
    // typedef struct
    // {
    //	aafCriteriaType_t type;
    //	aafCriteriaProc_t proc;
    // } aafMediaCriteria_t;
	//
    // The type field can have one of the following values:
    // typedef enum
    // {
    //	kAAFAnyRepresentation = 0,
    //	kAAFFastestRepresentation,
    //	kAAFBestFidelityRepresentation,
    //	kAAFSmallestRepresentation,
    //	kAAFUseRepresentationProc
    // } aafCriteriaType_t;
    [in] aafMediaCriteria_t *  pCriteria,

    // Requested Segment
    [out] IAAFSegment ** ppSegment);


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  // Connects this Source Mob with the physical Source Mob that
  // describes the previous generation of essence, appending it to
  // existing Mob data.  If a physical Source Mob, such as a File
  // Source Mob or tape Source Mob, references another physical
  // Source Mob as its ancestor, with no pulldown, then this
  // function makes the connection between the two.
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFSourceClip referencing a particular piece of media.  This
  // function takes many parameters because the components of an
  // aafSourceRef_t have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  // AAFTapeDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // (other conditions here)
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  //
  // (other codes here.)
  // 
  HRESULT AppendPhysSourceRef (
    // Edit rate of slot to contain reference
    [in] aafRational_t  editrate,

    // SlotID of slot to contain reference
    [in] aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    [in] IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    [in] aafSourceRef_t  ref,

    // Length of the Source Clip
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  // Connects this Source Mob with the physical Source Mob that
  // describes the previous generation of essence, replacing any
  // existing Mob data.  If a physical Source Mob, such as a File
  // Source Mob or tape Source Mob, references another physical
  // Source Mob as its ancestor, with no pulldown, then this
  // function makes the connection between the two.
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFSourceClip referencing a particular piece of media.  This
  // function takes many parameters because the components of an
  // aafSourceRef_t have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  // AAFTapeDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // (other conditions here)
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  //
  // (other codes here.)
  // 
  HRESULT NewPhysSourceRef (
    // Edit rate of slot to contain reference
    [in] aafRational_t  editrate,

    // SlotID of slot to contain reference
    [in] aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    [in] IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    [in] aafSourceRef_t  ref,

    // Length of the Source Clip
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // CreateEssence()
  //
  // Creates a single channel stream of essence.  Convenience
  // functions exist to create audio or video essence, and a separate
  // call (MultiCreate) exists to create interleaved audio and video
  // data.
  //
  // The essence handle from this call can be used with
  // WriteDataSamples  and possibly WriteDataLines, but NOT with
  // WriteMultiSamples.
  // 
  // If you are creating the essence, and then attaching it to a
  // master mob, then the "masterMob" field may be left NULL.  For
  // video, the sampleRate should be the edit rate of the file mob.
  // For audio, the sample rate should be the actual samples per
  // second.
  // 
  HRESULT CreateEssence (
    // 
    [in] aafSlotID_t  masterSlotID,

    // create essence of this type
    [in] IAAFDataDef * pMediaKind,

    // using this codec
    [in, ref] aafUID_constref  codecID,

    // with this edit rate
    [in] aafRational_t  editRate,

    // with this sample rate
    [in] aafRational_t  samplerate,

    // optionally compressing it
    [in] aafCompressEnable_t  Enable,

    // Optionally create the file HERE.
    [in] IAAFLocator * destination,

    // with this format
    [in, ref] aafUID_constref  fileFormat,

    // Return an essence access on the essence.
    [out] IAAFEssenceAccess ** access);


  //***********************************************************
  //
  // CreateMultiEssence()
  //
  // Creates a multi-channel interleaved stream of essence.  The
  // essence handle from this call can be used with WriteDataSamples
  // or WriteMultiSamples but NOT with or WriteDataLines.
  // 
  // If you are creating the essence, and then attaching it to a
  // master mob, then the "masterMob" field may be left NULL.
  // 
  HRESULT CreateMultiEssence (
    // using this codec
    [in, ref] aafUID_constref  codecID,

    // this many channels
    [in] aafUInt16  arrayElemCount,

    // using these definitions
    [in,ref,size_is(arrayElemCount)] aafmMultiCreate_t *  mediaArray,

    // optionally compressing it
    [in] aafCompressEnable_t  Enable,

    // Optionally create the file HERE.
    [in] IAAFLocator * destination,

    // with this format
    [in, ref] aafUID_constref  fileFormat,

    // Return an essence access on the essence.
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // OpenEssence()
  //
  // Opens a single channel of a file mob.  If the essence is
  // interleaved, then it will be di-interleaved when samples are
  // read.  This routine follows the locator, and may call the locator
  // failure callback if the essence can not be found.  If the failure
  // callback finds the essence, then this routine will return
  // normally.
  // 
  // The essence handle from this call can be used with
  // ReadDataSamples  and possibly ReadDataLines, but NOT with
  // ReadMultiSamples.
  // 
  // NOTE: If a locator is followed, then essencePtr may reference
  // ANOTHER file object, which must be closed on file close.
  // 
  HRESULT OpenEssence (
    // On this slot
    [in] aafSlotID_t  slotID,

    // using this essence criteria
    [in] aafMediaCriteria_t*  mediaCrit,

    // ReadOnly or Append
    [in] aafMediaOpenMode_t  openMode,

    // optionally decompressing
    [in] aafCompressEnable_t  compEnable,

    // Return an essence access on the essence.
    [out] IAAFEssenceAccess ** access);
	

  //***********************************************************
  //
  // OpenMultiEssence()
  //
  // Opens a all channels associated with a file mob.  This routine
  // follows the locator, and may call the locator failure callback if
  // the essence can not be found.  If the failure callback finds the
  // essence, then this routine will return normally.
  //
  // The essence handle from this call can be used with
  // WriteMultiSamples but NOT with WriteDataSamples.
  // 
  HRESULT OpenMultiEssence (
    // On this slot
    [in] aafSlotID_t  slotID,

    // using this essence criteria
    [in] aafMediaCriteria_t*  mediaCrit,

    // ReadOnly or Append
    [in] aafMediaOpenMode_t  openMode,

    // optionally decompressing
    [in] aafCompressEnable_t  compEnable,

    // Return an essence access on the essence.
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // CountChannels()
  //
  // Takes an opaque handle, a master mob reference, and a slot ID
  // so that it may be called before the essence is opened.
  //
  // Returns the number of interleaved essence channels of a given
  // type in the essence stream referenced by the given file mob.
  //
  // If the data format is not interleaved, then the answer will
  // always be zero or one.  This function correctly returns zero for
  // essence types not handled by a given codec, and handles codecs
  // which work with multiple essence types.
  // 
  HRESULT CountChannels (
    // On this slot
    [in] aafSlotID_t  slotID,

    // using this essence criteria
    [in] aafMediaCriteria_t*  mediaCrit,

    // for this essence type
    [in] IAAFDataDef * pMediaKind,

    // How many channels?
    [out] aafUInt16*  numCh);


}


// ************************
//
// Interface IAAFMetaDefinition
//
// ************************
//
// This interface is defines an item to be referenced in the AAF file.
// It specifies the AUID unique identifier used to define types used
// in AAF persistent objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFObject is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.


[
    object,
    uuid(cee32174-0c10-11d4-8014-00104bc9156d),
    helpstring("IAAFMetaDefinition Interface"),
    pointer_default(unique)
]
interface IAAFMetaDefinition : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a meta definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new Meta Definition
    [in, string] aafCharacter_constptr  pName,

    // the Description of this meta definition
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetAUID()
  //
  // Gets the AUID for this object.
  // 
  HRESULT GetAUID (
    // Pointer to an AUID reference
    [retval,out] aafUID_t *  pAuid);

  //***********************************************************
  //
  // SetName()
  //
  // Sets the Name of this definition.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  // 
  HRESULT SetName (
    // buffer from which Name is to be read
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Name of this definition.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  // 
  HRESULT GetName (
    // buffer into which Name is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pName,

    // size of *pName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);

  //***********************************************************
  //
  // SetDescription()
  //
  // Sets the Description of this definition.
  //
  // Set the Description property to the value specified in
  // pDescription.  A copy is made of the data so the caller
  // retains ownership of the *pDescription buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pDescription pointer is valid.
  // 
  // If this method fails the Description property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  // 
  HRESULT SetDescription (
    // buffer from which Description is to be read
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetDescription()
  //
  // Gets the Description of this definition.
  // 
  // Writes the Description property, with a trailing null
  // character, into the pDescription buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Description property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetDescriptionBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pDescription.
  // 
  // Succeeds if:
  // - The pDescription pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Description.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Description.
  // 
  HRESULT GetDescription (
    // buffer into which Description is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pDescription,

    // size of *pDescription buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  // Returns size of buffer (in bytes) required for GetDescription().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetDescriptionBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);

}



// ************************
//
// Interface IAAFMob
//
// ************************
//
// The IAAFMob interface is implemented by objects that specify a
// Metadata Object, which can describe a composition, essence, or
// physical media.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFMob is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFMob also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(B1A21374-1A7D-11d2-BF78-00104BC9156D),
    helpstring("IAAFMob Interface"),
    pointer_default(unique)
]
interface IAAFMob : IUnknown
{

  //***********************************************************
  //
  // GetMobID()
  //
  // This method returns the unique Mob ID associated with this mob.
  //
  // Succeeds if all of the following are true:
  // - the pMobID pointer is valid.
  // 
  // If this method fails nothing will be written to *pMobID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMobID arg is NULL.
  // 
  HRESULT GetMobID (
    // The unique media object id
    [out] aafMobID_t *  pMobID);


  //***********************************************************
  //
  // SetMobID()
  //
  // // When a mob is initially created, the Reference Implementation
  // internally creates a mobID for the new mob.  This method should
  // be used to change the mob's identity to an explicit mobID.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetMobID (
    // New Mob ID
    [in, ref] aafMobID_constref  mobID);


  //***********************************************************
  //
  // SetName()
  //
  // Sets the Mob Name string property.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  // 
  HRESULT SetName (
    // buffer from which Name is to be read
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Mob Name string property.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  // 
  HRESULT GetName (
    // buffer into which Name is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pName,

    // size of *pName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // CountSlots()
  //
  // This method returns the number of slots contained by this mob.
  //
  // Succeeds if all of the following are true:
  // - the pNumSlots pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumSlots.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumSlots arg is NULL.
  // 
  HRESULT CountSlots (
    // Number of slots
    [out] aafNumSlots_t *  pNumSlots);


  //***********************************************************
  //
  // AppendSlot()
  //
  // Appends the given mob slot to the mob.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pSlot pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSlot is null.
  // 
  HRESULT AppendSlot (
    // slot to append
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // PrependSlot()
  //
  // Prepends the given mob slot to the mob.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pSlot pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSlot is null.
  // 
  HRESULT PrependSlot (
    // slot to prepend
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // InsertSlotAt()
  //
  // Inserts the given slot into this mob at the given index.  All
  // existing slots at the given and higher index will be moved up one
  // index to accommodate.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pSlot pointer is valid.
  // - index is less than or equal to the result obtained by
  //   CountSlots().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSlot is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the result obtained from CountSlots().
  // 
  HRESULT InsertSlotAt (
    // index where slot is to be inserted
    [in] aafUInt32  index,

    // slot to insert
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // RemoveSlotAt()
  //
  // Removes the slot at the given index.  All existing slots at
  // indices higher than the given index will be moved down one index
  // to accommodate.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - index is less than the result obtained by CountSlots().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than the result obtained from
  //     CountSlots().
  // 
  HRESULT RemoveSlotAt (
    // index of slot to be removed
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetSlotAt()
  //
  // Returns the indexed slot in *ppSlot.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - ppSlot is a valid pointer.
  // - index is less than the result obtained by CountSlots().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSlot is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than the result obtained from
  //     CountSlots().
  // 
  HRESULT GetSlotAt (
    // index of slot to be obtained
    [in] aafUInt32  index,

    // the returned slot
    [out, retval] IAAFMobSlot ** ppSlot);


  //***********************************************************
  //
  // GetSlots()
  //
  // return an enumeration for all mob slots.  The returned
  // enumerator is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetSlots (
    // Mob Slot Enumeration
    [out] IEnumAAFMobSlots ** ppEnum);


  //***********************************************************
  //
  // GetModTime()
  //
  // This method will return the modification time for this mob.
  //
  // Succeeds if all of the following are true:
  // - the pLastModified pointer is valid.
  // 
  // If this method fails nothing will be written to *pLastModified.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLastModified arg is NULL.
  // 
  HRESULT GetModTime (
    // Modified Time
    [out] aafTimeStamp_t *  pLastModified);


  //***********************************************************
  //
  // SetModTime()
  //
  // This method sets the modification time on a mob.  The
  // modification time is initially set to the time that the mob
  // was created.  The Reference Implementation does not maintain the
  // modification time every time that a mob has been updated.
  // Therefore, this method should be called explicitly to change the
  // modification time.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetModTime (
    // New Modification Time
    [in, ref] aafTimeStamp_constref  modTime);


  //***********************************************************
  //
  // GetCreateTime()
  //
  // This method will return the creation time for this mob.
  //
  // Succeeds if all of the following are true:
  // - the pCreationTime pointer is valid.
  // 
  // If this method fails nothing will be written to *pCreationTime.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCreationTime arg is NULL.
  // 
  HRESULT GetCreateTime (
    // Creation Time
    [out] aafTimeStamp_t *  pCreationTime);


  //***********************************************************
  //
  // SetCreateTime()
  //
  // This method sets the creation time on a mob.  The
  // creation time is initially set to the time that the mob
  // was created.
  // Therefore, this method should be called explicitly to change the
  // creation time.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetCreateTime (
    // New Creation Time
    [in, ref] aafTimeStamp_constref  createTime);


  //***********************************************************
  //
  // AppendComment()
  //
  // Creates a user-defined comment and appends it to the specified
  // Mob.  A Mob comment is implemented as a AAFTaggedValue object of type 
  // WCharString.
  // 
  // Succeeds if all of the following are true:
  // - the pCategory pointer is valid.
  // - the pComment pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pCategory or pComment args is NULL.
  // 
  HRESULT AppendComment (
    // Comment heading
    [in,string] aafCharacter *  pCategory,

    // Comment value
    [in, string] aafCharacter_constptr  pComment);


  //***********************************************************
  //
  // CountComments()
  //
  // return total number of comments attached to this mob.
  //
  // Succeeds if all of the following are true:
  // - the pNumComments pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumComments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumComments arg is NULL.
  // 
  HRESULT CountComments (
    // Number  of Mob Comments
    [out] aafUInt32 *  pNumComments);


  //***********************************************************
  //
  // GetComments()
  //
  // return the enumeration for all mob comments.  The returned
  // enumerator is AddRef()ed before it is returned.  Mob comments are 
  // implemented as AAFTaggedValue of type WCharString.   The enumerator
  // is implemented as a EnumAAAFTaggedValues.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetComments (
    // Mob Comments
    [out] IEnumAAFTaggedValues ** ppEnum);


  //***********************************************************
  //
  // RemoveComment()
  //
  // // Removes the given comment from this mob.
  // 
  // Succeeds if all of the following are true:
  // - the pComment pointer is valid.
  // - the given comment is present in the mob.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pComment is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given comment is not in this mob.
  // 
  HRESULT RemoveComment (
    // Comment to remove
    [in] IAAFTaggedValue * pComment);


  //***********************************************************
  //
  // AppendNewTimelineSlot()
  //
  // This method creates a new timeline mob slot with the given
  // property values and appends it to the input mob.
  // 
  // The returned mob slot is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // - the pSlotName pointer is valid.
  // - the ppNewSlot pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  // 
  HRESULT AppendNewTimelineSlot (
    // Edit rate property value
    [in] aafRational_t  editRate,

    // Segment to append as slot component
    [in] IAAFSegment * pSegment,

    // new slot ID
    [in] aafSlotID_t  slotID,

    // new slot name
    [in, string] aafCharacter_constptr  pSlotName,

    // The slot origin
    [in] aafPosition_t  origin,

    // Newly created slot
    [out] IAAFTimelineMobSlot ** ppNewSlot);


  //***********************************************************
  //
  // GetMobInfo()
  //
  // This method will get all mob property information is a single call.
  //
  // Caller may call GetNameBufLen() to determine the required pName
  // buffer size.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pLastModified pointer is valid.
  // - the pCreationTime pointer is valid.
  // - the pName pointer is valid.
  // 
  // If this method fails nothing will be written to *pLastModified,
  // *pCreationTime, or *pName.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any of pLastModified, pCreationTime, or pName arguments is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  // 
  HRESULT GetMobInfo (
    // Modified Time
    [out] aafTimeStamp_t *  pLastModified,

    // Creation Time
    [out] aafTimeStamp_t *  pCreationTime,

    // Mob Name
    [out, size_is(bufSize), string] aafCharacter *  pName,

    // size of the supplied buffer.
    [in] aafInt32  bufSize);


  //***********************************************************
  //
  // OffsetToMobTimecode()
  //
  // This method will determine the timecode at the given offset into
  // the given timecode segment, and will return it in *pResult.  If
  // pTcSeg is NULL, will search for the slot containing a timecode
  // segment and will use that instead.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pTcSeg pointer is valid.
  // - the pOffset pointer is valid.
  // - the pResult pointer is valid.
  // - Timecode track exists.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pOffset or pResult argument is NULL.
  //
  // AAFRESULT_TIMECODE_NOT_FOUND
  //   - timecode track wasn't found.
  // 
  HRESULT OffsetToMobTimecode (
    // Timecode Segment
    [in] IAAFSegment * pTcSeg,

    // Offset into segment in edit units for that segment's mob slot
    [in] aafPosition_t *  pOffset,

    // The resulting timecode
    [out] aafTimecode_t *  pResult);


  //***********************************************************
  //
  // LookupSlot()
  //
  // The method will find the mob slot for the given slot id.
  //
  // The returned mob slot is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppDestSlot pointer is valid.
  // - the given slot ID is found.
  // 
  // If this method fails nothing will be written to *ppDestSlot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDestSlot arg is NULL.
  // 
  HRESULT LookupSlot (
    // The requested slot id
    [in] aafSlotID_t  slotId,

    // The requested slot
    [out] IAAFMobSlot ** ppDestSlot);


  //***********************************************************
  //
  // ChangeRef()
  //
  // Finds all Source Clips in the specified Mob that refer to the
  // specified old Mob, and changes the references to point to the
  // new Mob.
  //
  // This function traverses through the entire structure of the input
  // Mob looking for Source Clips, and changes the sourceID property
  // on all Source Clips with oldMobID to newMobID.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT ChangeRef (
    // Old Mob ID reference in source clip
    [in, ref] aafMobID_constref  oldMobID,

    // New Mob ID reference in source clip
    [in, ref] aafMobID_constref  newMobID);


  //***********************************************************
  //
  // CloneExternal()
  //
  // Clones the specified Source Mob, and optionally all dependent
  // Mobs, to an external file, keeping the same MobID.  A pointer
  // to the newly created destination mob is returned in *ppDestMob.
  // 
  // This function clones the specified Source Mob in the source file
  // into a destination Mob, with the same MobID, in the destination
  // file.  If resolveDependencies is kFollowDepend, the function
  // also clones all Mobs referenced by the specified Source Mob.  If
  // includeMedia is kIncludeMedia, the function also copies the
  // media data associated with the Source Mob, returns the
  // destination Mob, and clones all private data.
  //
  // If the media data is not in the file, the function does not
  // attempt to find it in another file and clone it.  Both AAF files
  // must be open before you call this function and both must have the
  // same AAF Version number.
  //
  // The returned mob is AddRef()ed before it is returned.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pDestFile pointer is valid.
  // - the ppDestMob pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pDestFile or ppDestMob arguments is NULL.
  // 
  HRESULT CloneExternal (
    // Whether to clone dependent mobs
    [in] aafDepend_t  resolveDependencies,

    // Whether to include media data
    [in] aafIncMedia_t  includeMedia,

    // Destination AAF File
    [in] IAAFFile * pDestFile,

    // Destination Mob
    [out] IAAFMob ** ppDestMob);


  //***********************************************************
  //
  // Copy()
  //
  // This function copies the specified Mob into a destination Mob in
  // the same AAF file. The new Mob is returned through the destMob
  // parameter. The function gives the destination Mob a new MobID and
  // the name specified in the destMobName parameter. The function
  // also copies all private data.
  // 
  // The returned mob is AddRef()ed before it is returned.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pDestMobName pointer is valid.
  // - the ppDestMob pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pDestMobName or pDestMob arguments is NULL.
  // 
  HRESULT Copy (
    // Optional Input. The name to be assigned to the new copy of the
	// Mob.  The destMobName argument is optional. Specify a NULL
	// value if no destination Mob name is desired.
    [in, string] aafCharacter_constptr  pDestMobName,

    // Destination Mob
    [out] IAAFMob ** ppDestMob);

  //***********************************************************
  //
  // AppendKLVData()
  //
  // Appends a pre-existing KLV Data object to the specified
  // Mob.
  // 
  // Succeeds if all of the following are true:
  // - the pKLV pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pData arg is NULL.
  // 
  HRESULT AppendKLVData (
    // KLV object
    [in] IAAFKLVData * pData);


  //***********************************************************
  //
  // CountKLVData()
  //
  // return total number of KLV data objects attached to this mob.
  //
  // Succeeds if all of the following are true:
  // - the pNumData pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumComments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumData arg is NULL.
  // 
  HRESULT CountKLVData (
    // Number  of KLV data objects
    [out] aafUInt32 *  pNumData);


  //***********************************************************
  //
  // GetKLVData()
  //
  // return the enumeration for all KLV data objects on this mob.  The returned
  // enumerator is AddRef()ed before it is returned.  The enumerator
  // is implemented as a EnumAAFKLVData.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetKLVData (
    // KLV data objects
    [out] IEnumAAFKLVData ** ppEnum);


  //***********************************************************
  //
  // RemoveKLVData()
  //
  // // Removes the given KLV data object from this mob.
  // 
  // Succeeds if all of the following are true:
  // - the pData pointer is valid.
  // - the given KLV data object is present in the mob.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pData is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given KLV data object is not in this mob.
  // 
  HRESULT RemoveKLVData (
    // KLV data object to remove
    [in] IAAFKLVData * pData);
}



// ************************
//
// Interface IAAFMobSlot
//
// ************************
//
// The IAAFMobSlot interface is implemented by objects which represent
// a Segment of essence in a Mob.  IAAFMobSlot-implementing objects
// contan a Segment, which can be a timeline, static, or event Segment.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFMobSlot is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//
// Types required by this module:
//
// aafBool
// aafRational_t
// AAFSegment
// aafPosition_t
// aafSlotID_t
// aafUInt32
// AAFDataDef
//


//
// Objects that implement IAAFMobSlot also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(B1A21376-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFMobSlot Interface"),
    pointer_default(unique)
]
interface IAAFMobSlot : IUnknown
{

  //***********************************************************
  //
  // GetSegment()
  //
  // This method will get the segment for this mob slot and place an
  // interface for it into the **ppResult argument.  If a segment
  // exists, the result will be AddRef()ed.  If not, the result will
  // be NULL.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT GetSegment (
    // Segment property value
    [out,retval] IAAFSegment ** ppResult);


  //***********************************************************
  //
  // SetName()
  //
  // Sets the Mob Slot Name string property.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  // 
  HRESULT SetName (
    // buffer from which Name is to be read
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Mob Slot Name string property.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  // 
  HRESULT GetName (
    // buffer into which Name is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pName,

    // size of *pName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetPhysicalNum()
  //
  // Returns information about the physical output channel associated
  // with the  Slot.
  //
  // This function returns the physical slot number of the specified
  // slot. The physical slot number identifies the physical slot
  // associated with the media.  For File Source Mobs that describe
  // stereo audio media, the left channel should have a PhysicalSlot
  // of 1 and the right channel should have a Physical-Slot of 2.
  //
  // The function returns an error if the object specified in the slot
  // parameter is not a slot.
  //
  // Succeeds if all of the following are true:
  // - the pDatadef pointer is valid.
  // - the object in the slot parameter is a slot.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDatadef arg is NULL.
  //
  // AAFRESULT_SLOT_NOT_FOUND
  //   - object specified is not a slot.
  // 
  HRESULT GetPhysicalNum (
    // The physical slot number property value
    [out,retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetDataDef()
  //
  // This method will return the Data Definition object
  // associated with the segment in this Mob Slot.  Common
  // DataDefinitions are DDEF_Picture, DDEF_Sound, DDEF_Timecode,
  // and DDEF_Edgecode.
  //
  // Succeeds if all of the following are true:
  // - the ppResult pointer is valid.
  // 
  // If this method fails nothing will be written to *ppResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppResult arg is NULL.
  // 
  HRESULT GetDataDef (
    // Data Definition AUID
    [out,retval] IAAFDataDef ** ppResult);


  //***********************************************************
  //
  // GetSlotID()
  //
  // This method will return the slot id of this mob slot.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT GetSlotID (
    // Slot id of the Mob Slot
    [out,retval] aafSlotID_t *  pResult);


  //***********************************************************
  //
  // SetSegment()
  //
  // This method will set the segment for this mob slot.  If a segment
  // already exists for this mob slot, it will be discarded.
  // 
  // Always succeeds.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetSegment (
    // Segment property value
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // SetPhysicalNum()
  //
  // // This function sets the physical slot number of the specified
  // slot.  The physical slot number identifies the physical slot
  // associated with the media.  For File Source Mobs that describe
  // stereo audio media, the left channel should have a PhysicalSlot
  // of 1 and the right channel should have a Physical-Slot of 2.
  //
  // The function returns an error if the Mob Slot passed in is not a
  // slot.
  // 
  // Succeeds if all of the following are true:
  // - the Mob Slot passed in is a slot.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.
  //
  // AAFRESULT_SLOT_NOT_FOUND
  //   - object specified is not a slot.
  // 
  HRESULT SetPhysicalNum (
    // The physical slot number property value
    [in] aafUInt32  number);


  //***********************************************************
  //
  // SetSlotID()
  //
  // This method will set the slot id of this mob slot.
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetSlotID (
    // Slot id of the Mob Slot
    [in] aafSlotID_t  value);
}



// ************************
//
// Interface IAAFNestedScope
//
// ************************
//
// This interface is used with an object which contains an ordered set
// of AAFSegments and produces the value specified by the last
// AAFSegement in the ordered seta reference to a segment.
// AAFNestedScopes are used to encapsulate intermediate results which
// may be referenced from more than one place, in a manner much like
// common subexpressions in mathmatical expressions.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFNestedScope also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(e44be451-2099-11d2-bf98-006097116212),
    helpstring("IAAFNestedScope Interface"),
    pointer_default(unique)
]
interface IAAFNestedScope : IUnknown
{

  //***********************************************************
  //
  // AppendSegment()
  //
  // Append another input segment to the list of source segments.  The
  // last segment added will be used as the output of the nested
  // scope, and usually contains operations whose inputs are scope
  // references.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  // 
  HRESULT AppendSegment (
    // Pointer to segment to be added
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // PrependSegment()
  //
  // Prepend another input segment to the list of source segments.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  // 
  HRESULT PrependSegment (
    // Pointer to segment to be added
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // InsertSegmentAt()
  //
  // Insert an input segment to the list of source segments at the
  // given index.  Segments already existing at the given and higher
  // indices will be moved up one index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountSegments().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountSegments().
  // 
  HRESULT InsertSegmentAt (
    // index where segment is to be inserted
    [in] aafUInt32  index,

    // Pointer to segment to be added
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // RemoveSegmentAt()
  //
  // Removes the indexed segment.  Segments already existing at
  // indices greater than the given index will be moved down by one
  // index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // - index is less than the value returned by CountSegments().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountSegments().
  // 
  HRESULT RemoveSegmentAt (
    // index of segment to be removed
    [in] aafUInt32  index);


  //***********************************************************
  //
  // CountSegments()
  //
  // Returns the number of source segments currently contained.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails no value will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountSegments (
    // number of segments contained
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetSegmentAt()
  //
  // Retrieves the indexed segment.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // - index is less than the value returned by CountSegments().
  // 
  // If this method fails nothing will be written to *ppSegment.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountSegments().
  // 
  HRESULT GetSegmentAt (
    // index of segment to retrieve
    [in] aafUInt32  index,

    // retrieved segment
    [out, retval] IAAFSegment ** ppSegment);


  //***********************************************************
  //
  // GetSegments()
  //
  // Return an enumerator for the ordered list of AAFSegments which
  // make up the nested scope.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetSegments (
    // Slots - segment list  enumeration
    [out, retval] IEnumAAFSegments ** ppEnum);
}



// ************************
//
// Interface IAAFNetworkLocator
//
// ************************
//
// The IAAFNetworkLocator interface is implemented by objects which
// provide information to help find a file containing essence data.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.
//


//
// Objects that implement IAAFNetworkLocator also implement the following interfaces:
//  - IAAFLocator
//  - IAAFObject

[
    object,
    uuid(2c1097b2-69d6-11d2-841b-00600832acb8),
    helpstring("IAAFNetworkLocator Interface"),
    pointer_default(unique)
]
interface IAAFNetworkLocator : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFNetworkLocator-supporting object.  This method must be called
  // after allocation, and before any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


}



// ************************
//
// Interface IAAFObject
//
// ************************
//
// This interface is implemented for all AAF persistent classes.  In
// addition to methods which all clients can use, it provides methods
// for direct property access which should not be used unless the
// client programmer is aware of the liabilities.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFObject is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.


[
    object,
    uuid(B1A213AB-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFObject Interface"),
    pointer_default(unique)
]
interface IAAFObject : IUnknown
{

  //***********************************************************
  //
  // GetGeneration()
  //
  // Gets the generation of this object, which is represented by an
  // AAFIdentification object.  This is used to detect when an object
  // has been modified.
  //
  // This method will succeed if generation tracking is enabled for
  // this object.  Call EnableGenerationTrackint() and
  // DisableGenerationTrackint() to control generation tracking for
  // this object.  Call IsGenerationTracked() to determine if
  // generation tracking is currently enabled for this object.
  //
  // Succeeds if all of the following are true:
  // - the given pGeneration pointer is valid.
  // - generation tracking is enabled for this object.
  // - this object is attached to a file.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppGeneration arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - Generation tracking is not enabled for this object.
  //
  // AAFRESULT_OBJECT_NOT_ATTACHED
  //   - This object is not attached to a file from which generation
  //     information can be obtained..
  // 
  HRESULT GetGeneration (
    // AAFIdentification object corresponding to this object's
    // Generation ID
    [out] IAAFIdentification ** ppGeneration);


  //***********************************************************
  //
  // GetGenerationAUID()
  //
  // Shortcut to get the AUID representing the Identification
  // representing this object's generation.  (Can also be obtained by
  // calling this->GetGeneration(&pIdent), and using its result to
  // call pIdent->GetAuid()).
  //
  // This method will succeed if generation tracking is enabled for
  // this object.  Call EnableGenerationTrackint() and
  // DisableGenerationTrackint() to control generation tracking for
  // this object.  Call IsGenerationTracked() to determine if
  // generation tracking is currently enabled for this object.
  //
  // Succeeds if all of the following are true:
  // - the given pResult pointer is valid.
  // - generation tracking is enabled for this object.
  // - this object is attached to a file.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - Generation tracking is not enabled for this object.
  //
  // AAFRESULT_OBJECT_NOT_ATTACHED
  //   - This object is not attached to a file from which generation
  //     information can be obtained..
  // 
  HRESULT GetGenerationAUID (
    // AUID corresponding to this object's Generation ID
    [out] aafUID_t *  pResult);


  //***********************************************************
  //
  // GetDefinition()
  //
  // Returns the class definition which describes this object
  // instance.
  //
  // Succeeds if all of the following are true:
  // - the given ppClassDef pointer is valid.
  //
  // Note! Use care when dealing with the object class.  Among the
  // pitfalls to be avoided is that tests for equality will not
  // reflect inheritance.  This becomes important if an unknown
  // non-builtin (that is, user defined) object class ID is obtained.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppClassDef arg is NULL.
  // 
  HRESULT GetDefinition (
    // class definition of which this object is an instance.
    [out] IAAFClassDef ** ppClassDef);


  //***********************************************************
  //
  // GetProperties()
  //
  // Returns an enumerator across all properties actually contained in
  // this object.  Each property is represented by an IAAFProperty
  // interface.
  // 
  //
  // *ppEnum is AddRef()ed before it is returned.
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT GetProperties (
    // Property Enumeration
    [out, retval] IEnumAAFProperties ** ppEnum);


  //***********************************************************
  //
  // CountProperties()
  //
  // Returns the number of properties currently present in this
  // object.  This is the same number as will be accessed through
  // GetProperties().
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  // 
  HRESULT CountProperties (
    // count of properties present in this object
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // GetPropertyValue()
  //
  // Returns the requested Property Value.  The desired property data
  // is identified by the given property definition.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropDef or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - named property is optional, but not present in this class.
  // 
  HRESULT GetPropertyValue (
    // property definition indentifying desired property
    [in] IAAFPropertyDef * pPropDef,

    // returned AAFPropertyValue
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // SetPropertyValue()
  //
  // Sets the value of the given property to the given value.  If the
  // selected property is optional but not yet present, will make the
  // property present before setting its value.
  //
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropDef or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - named property is optional, but not present in this class.
  // 
  HRESULT SetPropertyValue (
    // property definition indentifying desired property
    [in] IAAFPropertyDef * pPropDef,

    // value to set.
    [in] IAAFPropertyValue * pPropVal);


  //***********************************************************
  //
  // IsPropertyPresent()
  //
  // Sets *pResultReturns true in if named property is legal and is
  // present; sets it to false if it is legal and is absent.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  // 
  HRESULT IsPropertyPresent (
    // property definition indentifying desired property
    [in] IAAFPropertyDef * pPropDef,

    // true if present; false if not present
    [out] aafBoolean_t*  pResult);


  //***********************************************************
  //
  // RemoveOptionalProperty()
  //
  // Removes the property if named property is legal and is
  // optional and present.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  // 
  HRESULT RemoveOptionalProperty (
    // property definition indentifying desired property
    [in] IAAFPropertyDef * pPropDef);


  //***********************************************************
  //
  // CreateOptionalPropertyValue()
  //
  // Returns the requested Property Value.  The desired property data
  // is identified by the given optional property definition.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropDef or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  //
  // AAFRESULT_PROP_ALREADY_PRESENT
  //   - named property is optional, but already present in this class.
  // 
  HRESULT CreateOptionalPropertyValue (
    // property definition indentifying desired property
    [in] IAAFPropertyDef * pPropDef,

    // returned AAFPropertyValue
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetDictionary()
  //
  // Returns the dictionary for this object instance.
  //
  // Succeeds if all of the following are true:
  // - the given ppDictionary pointer is valid.
  //
  // Note! Use care when dealing with the object class.  Among the
  // pitfalls to be avoided is that tests for equality will not
  // reflect inheritance.  This becomes important if an unknown
  // non-builtin (that is, user defined) object class ID is obtained.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppClassDef arg is NULL.
  // 
  HRESULT GetDictionary (
    // A pointer to an Dictionary pointer
    [out, retval] IAAFDictionary ** ppDictionary);


  //***********************************************************
  //
  // EnableGenerationTracking()
  //
  // Calling this method will cause generation tracking to be enabled
  // for this object.  Generation information will then be available
  // through the GetGeneration() and GetGenerationAUID() methods.
  // 
  // Calling the DisableGenerationTracking() method will disable
  // generation tracking for this object.
  // 
  // Generation tracking is disabled by default.
  //
  // This method always succeeds, even if generation tracking is
  // already enabled.
  // 
  // This method will return the following result:
  //  - AAFRESULT_SUCCESS
  // 
  HRESULT EnableGenerationTracking ();


  //***********************************************************
  //
  // DisableGenerationTracking()
  //
  // Calling this method will cause generation tracking to be disabled
  // for this object.  Generation information will then not be
  // available through the GetGeneration() and GetGenerationAUID()
  // methods.
  // 
  // Calling the EnableGenerationTracking() method will enable
  // generation tracking for this object.
  // 
  // Generation tracking is disabled by default.
  //
  // This method always succeeds, even if generation tracking is
  // already disbled.
  // 
  // This method will return the following result:
  //  - AAFRESULT_SUCCESS
  // 
  HRESULT DisableGenerationTracking ();


  //***********************************************************
  //
  // IsGenerationTracked()
  //
  // This method will set *pResult to AAFTrue if generations are
  // being tracked for this object.  A result of AAFTrue indicates
  // that generation information will be available through the
  // GetGeneration() and GetGenerationAUID() methods.
  // 
  // Calling the EnableGenerationTracking() method will enable
  // generation tracking for this object; calling the
  // DisableGenerationTracking() method will disable generation
  // tracking for this object.
  // 
  // Generation tracking is disabled by default.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT IsGenerationTracked (
    // set to true if generations are tracked; false otherwise
    [out] aafBoolean_t *  pResult);
}



// ************************
//
// Interface IAAFParameter
//
// ************************
//
// The IAAFParameter interface is implemented by objects that specify
// an Instantiation of an operation parameter.  It is an abstract
// class, so you should use AAFConstantValue or AAFVaryingValue.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


 

//
// Objects that implement IAAFParameter also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(9c568a81-2096-11d2-bf98-006097116212),
    helpstring("IAAFParameter Interface"),
    pointer_default(unique)
]
interface IAAFParameter : IUnknown
{


  //***********************************************************
  //
  // GetParameterDefinition()
  //
  // Places the parameter definition of the operation parameter into
  // the *ppParmDef argument.  The length of an operation parameter is
  // in the same edit units and has the same value as the
  // IAAFOperationGroup enclosing this parameter.
  //
  // Succeeds if all of the following are true:
  // - the ppParmDef pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppParmDef is null.
  // 
  HRESULT GetParameterDefinition (
    // New parameter definition
    [out,retval] IAAFParameterDef ** ppParmDef);

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Places the IAAFTypeDefinition of the data value inside this
  // parameter into the *ppTypeDef argument.  The data value is the
  // value of the parameter.  It is often an integer or rational, and
  // may change over time.  An example of a value would be the
  // "level" parameter of a video dissolve, which has control
  // points with a value of zero (0 percent B material) at the
  // start, to one (100 percent B material) at the end.  The data
  // value will actually be stored in either AAFConstantValue or one
  // of the AAFControlPoints inside of an AAFVaryingValue.
  //
  // The definition is stored in the base class because it should be
  // constant for all control points inside of a varying value.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  // 
  HRESULT GetTypeDefinition (
    // Type Definition of the data value inside of this object
    [out,retval] IAAFTypeDef ** ppTypeDef);
}



// ************************
//
// Interface IAAFParameterDef
//
// ************************
//
// The IAAFParameterDef interface is implemented by objects that
// specify a definition of an operation group parameter.  The
// parameterDef object is separate from the operation definition to
// allow some parameters, for example level, to be specified once
// for multiple operation definitions. Parmeter definitions define the
// possible values and display units of a single operation parameter.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//

 

//
// Objects that implement IAAFParameterDef also implement the following interfaces:
//  - IAAFDefObject
//  - IAAFObject

[
    object,
    uuid(20045fa1-1d87-11d2-bf96-006097116212),
    helpstring("IAAFParameterDef Interface"),
    pointer_default(unique)
]
interface IAAFParameterDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  // 
  HRESULT Initialize (
    // AUID for new DeObject
    [in, ref] aafUID_constref  id,

    // Name for new DefObject
    [in, string] aafCharacter_constptr  pName,

    // Description for new DefObject
    [in, string] aafCharacter_constptr  pDescription,

    // The type definition for all parameters that use this definition
    [in] IAAFTypeDef * pType);


  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Places the AAFTypeDef object attached to this IAAFParameterDef
  // into the *ppTypeDef argument.  If none exists yet, NULL is
  // placed into the *ppTypeDef argument.
  //
  // The returned AAFTypeDef object, if it exists, is AddRef()ed
  // before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppTypeDef pointer is valid.
  // - A valid AAFTypeDef exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  //
  // AAFRESULT_NO_ESSENCE_DESC
  //   - There is no AAFTypeDef.  There has to be one of some
  //     kind for this to be a valid operation definition.
  // 
  HRESULT GetTypeDefinition (
    // Pointer to a type definition
    [retval,out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // SetDisplayUnits()
  //
  // Sets the Display Units string property.
  //
  // Set the DisplayUnits property to the value specified in
  // pDisplayUnits.  A copy is made of the data so the caller
  // retains ownership of the *pDisplayUnits buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pDisplayUnits pointer is valid.
  // 
  // If this method fails the DisplayUnits property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDisplayUnits arg is NULL.
  // 
  HRESULT SetDisplayUnits (
    // buffer from which DisplayUnits is to be read
    [in, string] aafCharacter_constptr  pDisplayUnits);


  //***********************************************************
  //
  // GetDisplayUnits()
  //
  // Gets the Display Units string property.
  // 
  // Writes the DisplayUnits property, with a trailing null
  // character, into the pDisplayUnits buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the DisplayUnits property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetDisplayUnitsBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pDisplayUnits.
  // 
  // Succeeds if:
  // - The pDisplayUnits pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   DisplayUnits.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDisplayUnits arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold DisplayUnits.
  // 
  HRESULT GetDisplayUnits (
    // buffer into which DisplayUnits is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pDisplayUnits,

    // size of *pDisplayUnits buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDisplayUnitsBufLen()
  //
  // Returns size of buffer (in bytes) required for GetDisplayUnits().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetDisplayUnitsBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);
}



// ************************
//
// Interface IAAFProperty
//
// ************************
//
// This interface is used to access instances of properties contained
// in AAF persistent objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


[
    object,
    uuid(83057d74-9691-11d2-aa7f-80e6aa000000),
    helpstring("IAAFProperty Interface"),
    pointer_default(unique)
]
interface IAAFProperty : IUnknown
{

  //***********************************************************
  //
  // GetDefinition()
  //
  // Returns the definition of this property.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - The ppPropDef pointer is valid.
  // - The associated property definition can be found in the
  //   dictionary.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropDef arg is NULL.
  //
  // AAFRESULT_BAD_PROP
  //   - The definition for this property could not be found in the
  //     dictionary.
  // 
  HRESULT GetDefinition (
    // This property's definition
    [out] IAAFPropertyDef ** ppPropDef);


  //***********************************************************
  //
  // GetValue()
  //
  // Returns the Property Value object associated with this property.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - The ppPval pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppValue arg is NULL.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - The given property is optional and not present.
  // 
  HRESULT GetValue (
    // The Property Value object associated with this property.
    [out] IAAFPropertyValue ** ppValue);
}



// ************************
//
// Interface IAAFPropertyDef
//
// ************************
//
// This interface is used to access the definitions of types for
// properties contained in AAF persistent objects.
//
// A property definition is used to indicate a particular property
// within a class.  It defines the name and type of a property to be
// contained in objects.  Clients cannot create these directly; they
// must be created through IAAFClassDef::AppendNewPropertyDef().
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


 

//
// Objects that implement IAAFPropertyDef also implement the following interfaces:
//  - IAAFMetaDefinition

[
    object,
    uuid(dfbd6521-1d81-11d2-bf96-006097116212),
    helpstring("IAAFPropertyDef Interface"),
    pointer_default(unique)
]
interface IAAFPropertyDef : IUnknown
{

  //***********************************************************
  //
  // GetTypeDef()
  //
  // Returns a reference to this property's type definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT GetTypeDef (
    // definition of type contained by this property
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetName()
  //
  // Gets the human-legible name.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  // 
  HRESULT GetName (
    // buffer into which Name is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pName,

    // size of *pName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetIsOptional()
  //
  // Sets *pIsOptional to AAFTrue for properties that are optional.
  // Sets it to AAFFalse for properties that are mandatory.
  //
  // Succeeds if:
  // - The pIsOptional pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // NOTE! Stub only.   Implementation not yet added.
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - The pIsOptional pointer is NULL.
  // 
  HRESULT GetIsOptional (
    // pointer to the result
    [out, retval] aafBoolean_t *  pIsOptional);

  //***********************************************************
  //
  // GetIsUniqueIdentifier()
  //
  // Sets *pIsUniqueIdentifier to AAFTrue for properties that are optional.
  // Sets it to AAFFalse for properties that are mandatory.
  //
  // Succeeds if:
  // - The pIsUniqueIdentifier pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // NOTE! Stub only.   Implementation not yet added.
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - The pIsUniqueIdentifier pointer is NULL.
  // 
  HRESULT GetIsUniqueIdentifier (
    // pointer to the result
    [out, retval] aafBoolean_t *  pIsUniqueIdentifier);


  //***********************************************************
  //
  // SetDescription()
  //
  // Sets the description of the property definition.
  //
  // Set the Description property to the value specified in
  // pDescription.  A copy is made of the data so the caller
  // retains ownership of the *pDescription buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pDescription pointer is valid.
  // 
  // If this method fails the Description property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  // 
  HRESULT SetDescription (
    // buffer from which Description is to be read
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetDescription()
  //
  // Gets the description of the property definition.
  // 
  // Writes the Description property, with a trailing null
  // character, into the pDescription buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Description property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetDescriptionBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pDescription.
  // 
  // Succeeds if:
  // - The pDescription pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Description.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Description.
  // 
  HRESULT GetDescription (
    // buffer into which Description is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pDescription,

    // size of *pDescription buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  // Returns size of buffer (in bytes) required for GetDescription().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetDescriptionBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);

}



// ************************
//
// Interface IAAFPropertyValue
//
// ************************
//
// This interface is used to access the values of properties contained
// in AAF persistent objects.  Values may be simple (e.g. integer),
// structured (e.g. aafTimecode_t), other AAF persistent objects,
// media, or arrays of other types.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


[
    object,
    uuid(83057d72-9691-11d2-aa7f-80e6aa000000),
    helpstring("IAAFPropertyValue Interface"),
    pointer_default(unique)
]
interface IAAFPropertyValue : IUnknown
{

  //***********************************************************
  //
  // GetType()
  //
  // Returns the type definition associated with this property value.
  // If this Property Value is not of a recognized type (such as from
  // a damaged or incorrectly construct file) this method will return
  // a raw access type which can be used to access the property data
  // in a raw manner.
  //
  // Succeeds if:
  // - The ppTypeDef pointer is valid.
  // - The associated type definition can be found in the dictionary.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  // 
  HRESULT GetType (
    // The type definition associated with this property value
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // IsDefinedType()
  //
  // Returns false if this property value's type is not (necessarily)
  // the one which was defined for it.  That may be the case if this
  // property value was read from a damaged file where type
  // information was not available; in that case GetType() will return
  // the raw access type for this value.
  //
  // If this property value's type is the one which was defined for
  // it, this method will return true and GetType() will return that
  // defined type for this value.
  //
  // Succeeds if:
  // - The pIsDefined pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsDefined arg is NULL.
  // 
  HRESULT IsDefinedType (
    // result
    [out] aafBoolean_t *  pIsDefined);
}



// ************************
//
// Interface IAAFPluginManager
//
// ************************
//
// This interface is used with an object representing an AAF class
// definition.  The operations on a class definition include managing
// the position of the class within the class heirarchy, and
// accessing property definitions associated with the class.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(AD1BB85C-DBB2-11d2-809C-006008143E6F),
    helpstring("IAAFPluginManager Interface"),
    pointer_default(unique)
]
interface IAAFPluginManager : IUnknown
{

  //***********************************************************
  //
  // RegisterSharedPlugins()
  //
  // Attempts to load and register all of the AAF plugin files found
  // in shared installation directory.
  // 
  HRESULT RegisterSharedPlugins ();


  //***********************************************************
  //
  // RegisterPluginDirectory()
  //
  // Attempts to load and register all of the AAF plugin files found
  // in the given directory.
  // 
  HRESULT RegisterPluginDirectory (
    // Pointer to the name of directory to look for plugins.
    [in] aafCharacter_constptr  directoryName);


  //***********************************************************
  //
  // RegisterPluginFile()
  //
  // Attempts to load and register all of the AAF plugins found
  // in the given file.
  // 
  HRESULT RegisterPluginFile (
    // Pointer to the name of plugin file to register.
    [in] aafCharacter_constptr  fileName);


  //***********************************************************
  //
  // EnumLoadedPlugins()
  //
  // Returns an enumerator which enumerates over all of the loaded
  // pluigin choices through the *ppEnum argument.  The returned
  // enumerator is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - if ppEnum is null.
  // 
  HRESULT EnumLoadedPlugins (
    // Which category ID do we want to enumerate
    [in, ref] aafUID_constref  categoryID,

    // Loaded Plugin Enumeration
    [out,retval] IEnumAAFLoadedPlugins ** ppEnum);


  //***********************************************************
  //
  // CreatePluginDefinition()
  //
  // Given a plugin definition ID, find a plugin and manufactures a
  // plugin descriptor of the correct class for this plugin, filling
  // in the values, and returning the definition through the
  // *pPluginDesc argument.  The returned definition is AddRef()ed
  // before it is returned.  You must call QueryInterface on the
  // result in order to find the correct interface, and are
  // responsible for adding the definition to the correct place in the
  // dictionary, as well as preventing duplicates. The resulting
  // definiton has the plugin descriptor already attached.
  // 
  // Succeeds if all of the following are true:
  // - the pPluginDesc pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - if pPluginDesc is null.
  // 
  HRESULT CreatePluginDefinition (
    // Which plugin definition do you want to create
    [in, ref] aafUID_constref  pluginDefID,

    // The dictionary of the file where the descriptor is to be created
    [in] IAAFDictionary * pDictionary,

    // The interface of the returned definition
    [out] IAAFDefObject**  ppPluginDef);


  //***********************************************************
  //
  // CreateInstance()
  //
  // Create an object contained within one of the loaded plugin
  // files.
  // 
  // Succeeds if all of the following are true:
  // - the rclsid was found by the plugin manager
  // - the interface corresponding to riid is supported by the plugin
  // - if pUnkOuter is not NULL and given plugin supports aggregation
  //   and riid must be a reference to IID_IUnknown.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // E_INVALIDARG
  //   - if ppPlugin is null.
  //   - pUnkOuter is not NULL and riid is not IID_IUnknown.
  //
  // AAFRESULT_EXTENSION_NOT_FOUND
  //   - The given rclsid could not be found by the Plugin Manager.
  //
  // E_NOINTERFACE
  //   - if initial interface given by riid is not supported by the
  //     plugin.
  // 
  HRESULT CreateInstance (
    // The class id of the plugin object do you want to create
    [in] REFCLSID  rclsid,

    // The controlling unknown of the new instance
    [in] IUnknown *  pUnkOuter,

    // The IID of the initialial interface for the new plugin instance
    [in] REFIID  riid,

    // The IID of the initialial interface for the new plugin instance
    [out,iid_is(riid)] void **  ppPlugin);
}



// ************************
//
// Interface IAAFPulldown
//
// ************************
//
// This interface is used with an object which converts between film
// frame rates and videotape frame rates by describing the mapping
// between them.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFPulldown also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(92B88031-2B2B-11d2-BF7E-00104BC9156D),
    helpstring("IAAFPulldown Interface"),
    pointer_default(unique)
]
interface IAAFPulldown : IUnknown
{

  //***********************************************************
  //
  // GetInputSegment()
  //
  // Places the input Segment object in this pulldown into the
  // *ppInputSegment argument.  If none exists yet, NULL is placed
  // into the *ppInputSegment argument.
  //
  // The returned segment object, if it exists, is AddRef()ed
  // before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppInputSegment pointer is valid.
  // - A valid segment exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppInputSegment is null.
  // 
  HRESULT GetInputSegment (
    // Returns the input Segment object
    [out] IAAFSegment ** ppInputSegment);


  //***********************************************************
  //
  // SetInputSegment()
  //
  // Sets the input segment .
  //
  // Succeeds if all of the following are true:
  // - the pInputSegment pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInputSegment is null.
  // 
  HRESULT SetInputSegment (
    // A Segment object
    [in] IAAFSegment * pInputSegment);


  //***********************************************************
  //
  // GetPulldownKind()
  //
  // Returns the pulldownKind property of this pulldown through the
  // *pPulldownKind argument.  The pulldown kinds include
  // kThreeTwoPD, kPalPD, kOneToOneNTSC, kOneToOnePAL, and
  // kVideoTapNTSC.
  //
  // Succeeds if all of the following are true:
  // - the pPulldownKind pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPulldownKind is null.
  // 
  HRESULT GetPulldownKind (
    // Returns the pulldownKind property
    [out] aafPulldownKind_t *  pPulldownKind);


  //***********************************************************
  //
  // SetPulldownKind()
  //
  // Sets the pulldown kind field of this pulldown object.  The
  // pulldown kinds include kThreeTwoPD, kPalPD, kOneToOneNTSC,
  // kOneToOnePAL, and kVideoTapNTSC.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInputSegment is null.
  // 
  HRESULT SetPulldownKind (
    // A Segment object
    [in] aafPulldownKind_t  pulldownKind);


  //***********************************************************
  //
  // GetPulldownDirection()
  //
  // Returns the pulldownDirection field of this pulldown through the
  // *pPulldownDirection argument.  The valid pulldown directions are:
  //    kVideoToFilmSpeed -- The input segment is at videoSpeed, and
  //                         the pulldown object is on a mob slot at
  //                         film edit rate.
  //    kFilmToVideoSpeed -- The input segment is at film edit rate.
  //
  // The value kVideoToFilmSpeed is used when connecting 24fps file
  // mobs to tape mobs. 
  //
  // The value kFilmToVideoSpeed is used when connecting tape mobs to
  // film mobs.
  //
  // Succeeds if all of the following are true:
  // - the pPulldownDirection pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPulldownDirection is null.
  // 
  HRESULT GetPulldownDirection (
    // Returns the input Segment object
    [out] aafPulldownDir_t *  pPulldownDirection);


  //***********************************************************
  //
  // SetPulldownDirection()
  //
  // Sets the pulldown direction field of this pulldown object.  The
  // valid pulldown directions are:
  //    kVideoToFilmSpeed -- The input segment is at videoSpeed, and
  //                         the pulldown object is on a mob slot at
  //                         film edit rate.
  //    kFilmToVideoSpeed -- The input segment is at film edit rate.
  //
  // The value kVideoToFilmSpeed is used when connecting 24fps file
  // mobs to tape mobs.
  //
  // The value kFilmToVideoSpeed is used when connecting tape mobs to
  // film mobs.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInputSegment is null.
  // 
  HRESULT SetPulldownDirection (
    // A Segment object
    [in] aafPulldownDir_t  pulldownDirection);


  //***********************************************************
  //
  // GetPhaseFrame()
  //
  // Returns the phaseFrame field of this pulldown through the
  // *pPhaseFrame argument.  The phase frame field specifies the phase
  // within the repeating pattern used to map between the two edit
  // rates. A value of zero specifies that the pulldown object starts
  // at the begining of the pattern.
  //
  // Succeeds if all of the following are true:
  // - the pPhaseFrame pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPhaseFrame is null.
  // 
  HRESULT GetPhaseFrame (
    // Returns the input Segment object
    [out] aafPhaseFrame_t *  pPhaseFrame);


  //***********************************************************
  //
  // SetPhaseFrame()
  //
  // Sets the phase frame field of this pulldown object.  The phase
  // frame field specifies the phase within the repeating pattern used
  // to map between the two edit rates. A value of zero specifies that
  // the pulldown object starts at the begining of the pattern.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInputSegment is null.
  // 
  HRESULT SetPhaseFrame (
    // A Segment object
    [in] aafPhaseFrame_t  phaseFrame);


}



// ************************
//
// Interface IAAFRGBADescriptor
//
// ************************


//
// The IAAFRGBADescriptor interface is implemented by objects
// which describe video content data formatted using RGBA formatting.
//
// In addition to the parameters inherited from AAFDigitalImageDescriptor,
// this interface adds Pixel layout (order of R, B, G, alpha)
// PixelStructure (sizes of the various components), Palette, Palette Layout,
// and Palette Structure.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that
//     IAAFDigitalImageDescriptor is a primary interface for an
//     abstract class, so it is not appropriate for the
//     Initialize() method to exist in this interface.  The
//     Initialize() method is available through the concrete
//     object's primary interface.
//


//
// Objects that implement IAAFRGBADescriptor also implement the following interfaces:
//  - IAAFDigitalImageDescriptor
//  - IAAFFileDescriptor
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(e684d772-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFRGBADescriptor Interface"),
    pointer_default(unique)
]
interface IAAFRGBADescriptor : IUnknown
{


  //***********************************************************
  //
  // SetPixelLayout()
  //
  // Sets the layout and structure of the components in a single pixel.
  // The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  // from the set:
  //   	kAAFCompNone
  // 	kAAFCompAlpha
  // 	kAAFCompBlue
  // 	kAAFCompFill
  // 	kAAFCompGreen
  // 	kAAFCompPalette
  // 	kAAFCompRed
  // The 'Size' field of the struct is the component size in bits.
  // 
  // If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  // If this method fails the PixelLayout property will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetPixelLayout (
    // The number of elements in each array
    [in] aafUInt32  numberElements,

    // Array of up to 8 aafRGBAComponent_t indicating component order and size.
    [in] aafRGBAComponent_t*  PixelLayoutArray);

  //***********************************************************
  //
  // CountPixelLayoutElements()
  //
  // This function returns the number of components in a pixel.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountPixelLayoutElements (
    // Number of components
    [out] aafUInt32 *  pResult);

  //***********************************************************
  //
  // GetPixelLayout()
  //
  // Gets the layout and structure of the components in a single pixel.
  // The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  // from the set:
  //   	kAAFCompNone
  // 	kAAFCompAlpha
  // 	kAAFCompBlue
  // 	kAAFCompFill
  // 	kAAFCompGreen
  // 	kAAFCompPalette
  // 	kAAFCompRed
  //
  // The 'Size' field of the struct is the component size in bits.
  // 
  // If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  //
  // If this method fails, PixelLayoutArray will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements or PixelLayoutArray or PixelStructureArray is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - numberElements indicates that the array is too small to hold
  //     the data.
  // 
  HRESULT GetPixelLayout (
    // The number of elements in the array
    [in] aafUInt32  numberElements,

    // Array to hold up to 8 aafRGBAComponent_t indicating component order and size.
    [out, size_is(numberElements)] aafRGBAComponent_t*  PixelLayoutArray);

  //***********************************************************
  //
  // SetPalette()
  //
  // Sets the palette property.  The palette must be in the form specified
  // by the palette layout and palette structure parameters.
  // 
  // Succeeds if all of the following are true:
  // - pPalette is a valid pointer
  // 
  // If this method fails, the palette property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPalette is NULL.
  // 
  HRESULT SetPalette (
    // The number of bytes in the array
    [in] aafUInt32  numberElements,

    // Array to hold the palette information
    [in, size_is(numberElements)] aafUInt8*  pPalette);


  //***********************************************************
  //
  // GetPalette()
  //
  // Sets the palette property.  The palette must be in the form specified
  // by the palette layout and palette structure parameters.
  // The values are written to the array specified by pPalette,
  // which is of size numberElements.  The required size may be found
  // by calling GetPaletteSize().
  // 
  // Succeeds if all of the following are true:
  // - pPalette is a valid pointer.
  // - numberElements indicates the array is large enough to hold the
  //   data.
  // 
  // If this method fails, pPalette will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - numberElements indicates that the array is too small to hold
  //     the data.
  // 
  HRESULT GetPalette (
    // The number of bytes in the array
    [in] aafUInt32  numberRecords,

    // Array to hold the palette information
    [out, size_is(numberRecords)] aafUInt8*  pPalette);


  //***********************************************************
  //
  // GetPaletteSize()
  //
  // Get the number of bytes in the VideoLineMap property array.
  // 
  // Succeeds if all of the following are true:
  // - pNumberBytes is a valid pointer
  // 
  // If this method fails, *pNumberBytes will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberBytes is NULL.
  // 
  HRESULT GetPaletteSize (
    // The number of bytes in the array
    [out] aafUInt32 *  pNumberBytes);

  //***********************************************************
  //
  // CountPaletteLayoutElements()
  //
  // This function returns the number of components in a pixel.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountPaletteLayoutElements (
    // Number of components
    [out] aafUInt32 *  pResult);

  //***********************************************************
  //
  // SetPaletteLayout()
  //
  // Sets the layout and structure of the components in a single pixel.
  // The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  // from the set:
  //   	kAAFCompNone
  // 	kAAFCompAlpha
  // 	kAAFCompBlue
  // 	kAAFCompFill
  // 	kAAFCompGreen
  // 	kAAFCompPalette
  // 	kAAFCompRed
  // The 'Size' field of the struct is the component size in bits.
  // 
  // If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  // If this method fails the PaletteLayout property will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetPaletteLayout (
    // The number of elements in the array
    [in] aafUInt32  numberElements,

    // Array of up to 8 bytes indicating component size, matching layout, and terminated by a zero byte.
    [in] aafRGBAComponent_t*  PaletteLayoutArray);

  //***********************************************************
  //
  // GetPaletteLayout()
  //
  // // The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  // from the set:
  //   	kAAFCompNone
  // 	kAAFCompAlpha
  // 	kAAFCompBlue
  // 	kAAFCompFill
  // 	kAAFCompGreen
  // 	kAAFCompPalette
  // 	kAAFCompRed
  //
  // The 'Size' field of the struct is the component size in bits.
  // 
  // If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  //
  // If this method fails, PaletteLayoutArray will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements or PaletteLayoutArray is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - numberElements indicates that the array is too small to hold
  //     the data.
  // 
  HRESULT GetPaletteLayout (
    // The number of elements in each array
    [in] aafUInt32  numberElements,

    // Array to hold 8 aafRGBAComponent_t indicating component order and size.
    [out, size_is(numberElements)] aafRGBAComponent_t*  PaletteLayoutArray);

}



// ************************
//
// Interface IAAFScopeReference
//
// ************************
//
// This interface is used with an object representing a reference to a
// segment on another slot of this scope (AAFNestedScope or AAFMob)
// or an enclosing scope.  Scope references are specified in terms of
// a relative slot offset, and the number of scopes to skip outward.
// For example a slot offset of 1 and a scope of 0 means to look 1
// track back in the current scope.  A slot offset of 1 and a scope of
// 1 means to look one slot lower in the enslosing scope.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFScopeReference also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(e44be453-2099-11d2-bf98-006097116212),
    helpstring("IAAFScopeReference Interface"),
    pointer_default(unique)
]
interface IAAFScopeReference : IUnknown
{

  //***********************************************************
  //
  // Create()
  //
  // Constructs a Scope Reference object.
  // 
  // If this method fails the length property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Create (
    // Number of nested scopes to pass to find the Nested Scope slot
    [in] aafUInt32  RelativeScope,

    // Number of slots to look backwards from the slot containing the
    // Scope Reference
    [in] aafUInt32  RelativeSlot);

  //***********************************************************
  //
  // Initialize()
  //
  // Constructs a Scope Reference object.
  // 
  // If this method fails the length property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Initialize (
    // Data definition for referenced slot
    [in] IAAFDataDef * pDataDef,

    // Number of nested scopes to pass to find the Nested Scope slot
    [in] aafUInt32  RelativeScope,

    // Number of slots to look backwards from the slot containing the
    // Scope Reference
    [in] aafUInt32  RelativeSlot);

  //***********************************************************
  //
  // GetRelativeScope()
  //
  // Gets the number of nested scopes to pass to find the Nested Scope
  // slot.
  //	
  // Succeeds if all of the following are true:
  // - the pnRelativeScope pointer is valid.
  // 
  // If this method fails nothing will be written to *pnRelativeScope.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pnRelativeScope arg is NULL.
  // 
  HRESULT GetRelativeScope (
    // Pointer to a Relative Scope
    [retval][out] aafUInt32 *  pnRelativeScope);


  //***********************************************************
  //
  // GetRelativeSlot()
  //
  // Gets the number of slots that preced the slot containing the
  // Scope Reference. 
  //	
  // Succeeds if all of the following are true:
  // - the pnRelativeScope pointer is valid.
  // 
  // If this method fails nothing will be written to *pnRelativeSlot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pnRelativeSlot arg is NULL.
  // 
  HRESULT GetRelativeSlot (
    // Pointer to a Relative Slot
    [retval][out] aafUInt32 *  pnRelativeSlot);
}



// ************************
//
// Interface IAAFSegment
//
// ************************
//
// The IAAFSegment interface is implemented by objects which represent
// a component that is independent of any other components which may
// surround it in a sequence.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFSegment is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFSegment also implement the following interfaces:
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(7a2f0570-1ba3-11D2-bfaa-006097116212),
    helpstring("IAAFSegment Interface"),
    pointer_default(unique)
]
interface IAAFSegment : IUnknown
{

  //***********************************************************
  //
  // SegmentOffsetToTC()
  //
  // Converts the given Segment offset to timecode.
  // 
  // Succeeds if all of the following are true:
  // - the pOffset pointer is valid.
  // - the pTimeCode pointer is valid.
  // 
  // If this method fails the value of pTimecode is left unchanged.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any arg is NULL.
  //
  // AAFRESULT_TIMECODE_NOT_FOUND
  //   - the given offset is not available in this segment.
  // 
  HRESULT SegmentOffsetToTC (
    // Pointer to a Segment Offset to be convert to Timecode
    [in] aafPosition_t *  pOffset,

    // The converted timecode to be returned
    [out] aafTimecode_t *  pTimecode);


  //***********************************************************
  //
  // SegmentTCToOffset()
  //
  // Converts the given Timecode to an Offset.
  // 
  // Succeeds if all of the following are true:
  // - the pTimeCode pointer is valid.
  // - the pEditRate pointer is valid
  // - the pFrameOffset pointer is valid.
  // 
  // If this method fails the value of pOffset is left unchanged.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any arg is NULL.
  //
  // AAFRESULT_TIMECODE_NOT_FOUND
  //   - the given timecode is not available in this segment.
  // 
  HRESULT SegmentTCToOffset (
    // Pointer to a timecode to be converted to Offset
    [in] aafTimecode_t *  pTimecode,

    // The edit rate for the given timecode 
    [in] aafRational_t *  pEditRate,

    // Frame Offset to be returned if found
    [out] aafFrameOffset_t *  pOffset);
}



// ************************
//
// Interface IAAFSelector
//
// ************************
//
// The IAAFSelector interface is implemented by objects that specify a
// single segment while preserving references to unused alternatives.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface. 
//


//
// Objects that implement IAAFSelector also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(e684d788-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFSelector Interface"),
    pointer_default(unique)
]
interface IAAFSelector : IUnknown
{

  //***********************************************************
  //
  // GetSelectedSegment()
  //
  // Places the Selected Segment object in this Selector into the
  // *ppSelSegment argument.  If none exists yet, NULL is placed into
  // the *ppSelSegment argument.
  //
  // The returned essence descriptor object, if it exists, is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppSelSegment pointer is valid.
  // - A valid segment exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSelSegment is null.
  // 
  HRESULT GetSelectedSegment (
    // Returned the selected Segment object
    [out] IAAFSegment ** ppSelSegment);


  //***********************************************************
  //
  // SetSelectedSegment()
  //
  // Sets the Selected segment.
  //
  // Succeeds if all of the following are true:
  // - the pSelSegment pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSelSegment is null.
  // 
  HRESULT SetSelectedSegment (
    // A Segment object
    [in] IAAFSegment * pSelSegment);


  //***********************************************************
  //
  // AppendAlternateSegment()
  //
  // This function appends the input segment to the alternate segment
  // list, the alternate list of segments represents unused
  // alternative segments. 
  //
  // This method will AddRef() the segment if it succeeds.
  //
  // If the segment is successfully appended to the set of
  // alternates, the reference count of the segment is incremented.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pSegment pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  // 
  HRESULT AppendAlternateSegment (
    // Segment to append to the Alternate list of segments
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // GetNumAlternateSegments()
  //
  // This function returns the number of segments in the set.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pNumSegments pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumSegments is null.
  // 
  HRESULT GetNumAlternateSegments (
    // Number of Alternate Segments
    [out] aafInt32 *  pNumSegments);


  //***********************************************************
  //
  // EnumAlternateSegments()
  //
  // Places an IEnumAAFSegments enumerator for the alterante segments
  // contained in the selector into the *ppEnum argument.
  // 
  // The returned enumerator is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // E_FAIL
  //   - Failed to create the enumerator.
  // 
  HRESULT EnumAlternateSegments (
    // Segment Enumeration
    [out, retval] IEnumAAFSegments ** ppEnum);

  //***********************************************************
  //
  // RemoveAlternateSegment()
  //
  // // Removes the given Segment from the selector.
  //
  // Succeeds if all of the following are true:
  // - the v pointer is valid.
  // - the given segment is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  //
  // AAFRESULT_SEGMENT_NOT_FOUND
  //   - the given segment is not already contained.
  // 
  HRESULT RemoveAlternateSegment (
    // Segment to remove
    [in] IAAFSegment * pSegment);

}



// ************************
//
// Interface IAAFSequence
//
// ************************
//
// This interface provides access to the list of Segment and
// Transition objects maintained by a Sequence object.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFSequence also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(66e855f0-2bc2-11d2-bfaa-006097116212),
    helpstring("IAAFSequence Interface"),
    pointer_default(unique)
]
interface IAAFSequence : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // This function sets the properties on a newly created sequence
  // object with the given property values. The length of the sequence
  // is initially set to 0.  When components are appended to the
  // sequence with the AppendComponent() call, the length of the
  // appended component is added to the length of the sequence.  The
  // given DataDef specifies the kind of data which all components to
  // be contained in this sequence must share.
  // 
  // Succeeds if all of the following are true:
  // - this object has not yet been initialized.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef is null.
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize (
    // DataDef of this object
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // AppendComponent()
  //
  // This function appends the input component to the given sequence,
  // enforcing bottom up creation of mobs.  The length of the sequence
  // is incremented by the size of the component, unless the
  // component is a transition.  If the component is a transition, it
  // verifies that it is not the first object in a transition, and
  // that it is not neighboring another transition.  It also verifies
  // that there is enough source material on either side of the
  // transition.  The function also verifies that the datadefs are
  // compatible.
  //
  // This method will AddRef() the component if it succeeds.
  //
  // If the component is successfully appended to the sequence, the
  // reference count of the component is incremented.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pComponent pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponent is null.
  //
  // AAFRESULT_INVALID_DATADEF
  //   - The data kind of the component is not compatible with the 
  //     data def of the sequence.
  //
  // AAFRESULT_LEADING_TRAN
  //   - Attempted to append a transition as the first component of
  //     a sequence.  A sequence can not start with a transition. 
  //
  // AAFRESULT_ADJACENT_TRAN
  //   - Attempted to append a transition next to a transition.  A
  //     sequence can not contain back to back transitions.
  //
  // AAFRESULT_INSUFF_TRAN_MATERIAL
  //   - There is not enough source material to add this component.
  // 
  HRESULT AppendComponent (
    // Component to append to the sequence
    [in] IAAFComponent * pComponent);


  //***********************************************************
  //
  // PrependComponent()
  //
  // This function prepends the input component to the given
  // sequence, enforcing bottom up creation of mobs.  The length of
  // the sequence is incremented by the size of the component, unless
  // the component is a transition.  If the component is a
  // transition, it verifies that it is not the first object in a
  // transition, and that it is not neighboring another transition.
  // It also verifies that there is enough source material on either
  // side of the transition.  The function also verifies that the
  // datadefs are compatible.
  //
  // This method will AddRef() the component if it succeeds.
  //
  // If the component is successfully appended to the sequence, the
  // reference count of the component is incremented.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pComponent pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponent is null.
  //
  // AAFRESULT_INVALID_DATADEF
  //   - The data kind of the component is not compatible with the 
  //     data def of the sequence.
  //
  // AAFRESULT_LEADING_TRAN
  //   - Attempted to append a transition as the first component of
  //     a sequence.  A sequence can not start with a transition. 
  //
  // AAFRESULT_ADJACENT_TRAN
  //   - Attempted to append a transition next to a transition.  A
  //     sequence can not contain back to back transitions.
  //
  // AAFRESULT_INSUFF_TRAN_MATERIAL
  //   - There is not enough source material to add this component.
  // 
  HRESULT PrependComponent (
    // Component to prepend to the sequence
    [in] IAAFComponent * pComponent);


  //***********************************************************
  //
  // InsertComponentAt()
  //
  // This function inserts the input component into the given sequence
  // at the given index, enforcing bottom up creation of mobs.  The
  // length of the sequence is incremented by the size of the
  // component, unless the component is a transition.  If the
  // component is a transition, it verifies that it is not the first
  // object in a transition, and that it is not neighboring another
  // transition.  It also verifies that there is enough source
  // material on either side of the transition.  The function also
  // verifies that the datadefs are compatible.
  //
  // This method will AddRef() the component if it succeeds.
  //
  // If the component is successfully appended to the sequence, the
  // reference count of the component is incremented.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pComponent pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountComponents().
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponent is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountComponents().
  //
  // AAFRESULT_INVALID_DATADEF
  //   - The data kind of the component is not compatible with the 
  //     data def of the sequence.
  //
  // AAFRESULT_LEADING_TRAN
  //   - Attempted to append a transition as the first component of
  //     a sequence.  A sequence can not start with a transition. 
  //
  // AAFRESULT_ADJACENT_TRAN
  //   - Attempted to append a transition next to a transition.  A
  //     sequence can not contain back to back transitions.
  //
  // AAFRESULT_INSUFF_TRAN_MATERIAL
  //   - There is not enough source material to add this component.
  // 
  HRESULT InsertComponentAt (
    // index to insert component
    [in] aafUInt32  index,

    // Component to insert into the sequence
    [in] IAAFComponent * pComponent);


  //***********************************************************
  //
  // GetComponentAt()
  //
  // This function retrieves the input component at the given index in
  // the given sequence.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppComponent pointer is valid.
  // - index is less than the value returned by
  //   CountComponents().
  // 
  // If this method fails nothing will be written to *ppComponent.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponent is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountComponents().
  // 
  HRESULT GetComponentAt (
    // index of component to retrieve
    [in] aafUInt32  index,

    // Retrieved component
    [out, retval] IAAFComponent ** ppComponent);


  //***********************************************************
  //
  // RemoveComponentAt()
  //
  // This function removes the input component at the given index in
  // the given sequence.  Components already existing at indices
  // higher than the given index will be moved to the next lower index
  // to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - index is less than the value returned by
  //   CountComponents().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountComponents().
  // 
  HRESULT RemoveComponentAt (
    // index of component to remove
    [in] aafUInt32  index);


  //***********************************************************
  //
  // CountComponents()
  //
  // This function returns the number of components in the sequence.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountComponents (
    // Number of components
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetComponents()
  //
  // Places an IEnumAAFComponents enumerator for the components
  // contained in the sequence into the *ppEnum argument.
  // 
  // The returned enumerator is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // E_FAIL
  //   - Failed to create the enumerator.
  // 
  HRESULT GetComponents (
    // Component Enumeration
    [out, retval] IEnumAAFComponents ** ppEnum);


}



// ************************
//
// Interface IAAFSourceClip
//
// ************************
//
// The IAAFSourceClip interface is implemented by objects that
// reference the content data and identify the source of the content
// data.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFSourceClip also implement the following interfaces:
//  - IAAFSourceReference
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(38e6f8a7-2a2c-11d2-8411-00600832acb8),
    helpstring("IAAFSourceClip Interface"),
    pointer_default(unique)
]
interface IAAFSourceClip : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // This method initializes a source clip object with
  // the given properties.  Only required properties are set.
  // Optional properties are added with separate functions.
  //
  // Succeds if:
  // - This object has not already been Initialize()d.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef argument is NULL.
  // 
  HRESULT Initialize (
    // Data Definition object
    [in] IAAFDataDef * pDataDef,

    // Length property value
    [in] aafLength_constref  length,

    // Source Reference
    [in] aafSourceRef_t  sourceRef);


  //***********************************************************
  //
  // GetFade()
  //
  // This function returns the optional fade information from a
  // source clip.  This function only applies to audio source clips.
  // Length units are specified by the containing mob slot's edit
  // rate.
  //
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // - the all argument pointers are valid.
  // 
  // If this method fails nothing will be written to any of the
  // locations specified by the arguments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - any argument is NULL.
  // 
  HRESULT GetFade (
    // Fade In Length
    [out] aafLength_t *  pFadeInLen,

    // Fade In Type
    [out] aafFadeType_t *  pFadeInType,

    // Fade In Type
    [out] aafBoolean_t *  pFadeInPresent,

    // Fade Out Length
    [out] aafLength_t *  pFadeOutLen,

    // Fade Out Type
    [out] aafFadeType_t *  pFadeOutType,

    // Fade In Type
    [out] aafBoolean_t *  pFadeOutPresent);


  //***********************************************************
  //
  // ResolveRef()
  //
  // Given a source clip object, this function returns a pointer
  // to the mob that it references.
  //
  // The returned mob is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // - the ppMob pointer is valid.
  // 
  // If this method fails nothing will be written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob arg is NULL.
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - this mob does not exist.
  // 
  HRESULT ResolveRef (
    // Referenced mob
    [out] IAAFMob ** ppMob);


  //***********************************************************
  //
  // GetSourceReference()
  //
  // // This function returns the source reference of this source clip.
  //
  // Note: the 3 properties of a source Clip that make up the "source
  // reference" are sourceID, sourceTrackID, and startTime.
  //
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // - the pSourceRef pointer is valid.
  // 
  // If this method fails nothing will be written to *pSourceRef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRef arg is NULL.
  // 
  HRESULT GetSourceReference (
    // Source Reference
    [out] aafSourceRef_t *  pSourceRef);


  //***********************************************************
  //
  // SetFade()
  //
  // This function sets the optional fade properties on this source
  // clip object.  The fade properties only apply to a source clip of
  // data definition (or convertible to a data definition) of type
  // Sound.  All arguments should be specified.  Length units are
  // specified by the containing mob slot's edit rate.
  // 
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetFade (
    // Fade In Length
    [in] aafInt32  fadeInLen,

    // Fade In Type
    [in] aafFadeType_t  fadeInType,

    // Fade Out Length
    [in] aafInt32  fadeOutLen,

    // Fade Out Type
    [in] aafFadeType_t  fadeOutType);


  //***********************************************************
  //
  // SetSourceReference()
  //
  // This function sets the source reference of this source clip.
  //
  // Note: the  3 properties of a source Clip that make up the "source
  // reference" are sourceID, sourceTrackID, and startTime.
  // 
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetSourceReference (
    // Source Reference
    [in] aafSourceRef_t  sourceRef);
}



// ************************
//
// Interface IAAFSourceMob
//
// ************************
//
// This interface is used with an object representing a SourceMob
// containing some form of AAFEssenceDescriptor, either an
// AAFTapeDescriptor, AAFFileDescriptor AAFFilmDescriptor, or some
// extended descriptor not in the v1 specification.  Some methods
// exist here which exist only for one kind of AAFEssenceDescriptor. 
//      AppendTimecodeClip -- Works only on tape AAFSourceMobs
//      ValidateTimecodeRange -- Works only on tape AAFSourceMobs
//      AppendEdgecodeClip -- Works only on film AAFSourceMobs
// These will return an error if the wrong descriptor is present.
// 
// If an AAFSourceMob points to another AAFSourceMob at the same rate
// [or non-picture], then AppendPhysMobRef is used to create the
// relationship.
//
// If an AAFSourceMob points to picture on another AAFSourceMob at a different
// sample rate, then AddPulldownRef is used to create the relationship, and the
// AAFPulldown which describes how to map between the two rates.
//
// In an AAFSourceMob is the end of the derivation chain for a particular track, then
// AddNilReference should be called for that slot, to say that that slot does exist
// on the SourceMob.  For example, a video file mob with no derivation would have
// a single slot or type video, with a NIL reference to show that video exist, and was
// not derived from anything else on record.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFSourceMob also implement the following interfaces:
//  - IAAFSearchSource
//  - IAAFMob
//  - IAAFObject

[
    object,
    uuid(B1A2137C-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFSourceMob Interface"),
    pointer_default(unique)
]
interface IAAFSourceMob : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty IAAFSourceMob-supporting
  // object.  This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetEssenceDescriptor()
  //
  // Places the Essence Descriptor object attached to this Mob into the
  // *ppEssence argument.  If none exists yet, NULL is placed into the
  // *ppEssence argument.
  //
  // The returned essence descriptor object, if it exists, is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppEssence pointer is valid.
  // - A valid essence descriptor exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEssence is null.
  //
  // AAFRESULT_NO_ESSENCE_DESC
  //   - There is no essence descriptor.  There has to be one of some
  //     kind for this to be a valid Mob.
  // 
  HRESULT GetEssenceDescriptor (
    // Returned Essence Descriptor object
    [out] IAAFEssenceDescriptor ** ppEssence);


  //***********************************************************
  //
  // SetEssenceDescriptor()
  //
  // Sets the Essence Descriptor of this Mob to be the given one.
  //
  // Succeeds if all of the following are true:
  // - the pEssence pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssence is null.
  // 
  HRESULT SetEssenceDescriptor (
    // Essence Descriptor object
    [in] IAAFEssenceDescriptor * pEssence);


  //***********************************************************
  //
  // AddNilReference()
  //
  // This function adds a slot containing a NIL [sourceID 0.0....]
  // Source Clip.  This special SourceID indicates that the mob chain
  // ends here, which indicates that no record exists of what the
  // essence was derived from.  Some AAFSourceClip is still required
  // on the track to indicate that the track exists, and may be
  // referenced from other Mobs.
  //
  // Examples of Source Mobs that are not derived from a previous
  // source of essence are: Tape Source Mobs that were not created
  // from film; File Source Mobs whose digital essence data was
  // originally generated by computer and was not digitized from
  // videotape.
  //
  // Succeeds if all of the following are true:
  // - The pDataDef parameter is valid.
  // - editRate is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pDataDef parameter is NULL.
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BADRATE
  //   - the editRate is not valid.
  // 
  HRESULT AddNilReference (
    // SlotID to be assigned to the new slot
    [in] aafSlotID_t  slotID,

    // Duration of the Source Clip to be added to the new slot
    [in] aafLength_t  length,

    // Data definition of the new slot
    [in] IAAFDataDef * pDataDef,

    // Edit rate of the new slot
    [in] aafRational_t  editRate);


  //***********************************************************
  //
  // AppendTimecodeSlot()
  //
  // This function adds a Timecode slot to a specified tape Mob or
  // film Mob, with a specified starting timecode, length, and edit
  // rate.  Your must also call SpecifyValidCodeRange to add the
  // Filler to the other essence slots to indicate that the Timecode
  // is valid for that channel.
  // 
  // Note: The startTC parameter is expressed in frames since
  // midnight.
  // 
  // The length32 parameter can be the value FULL_RANGE, in which
  // case the length is 24 hours.
  //
  // Succeeds if all of the following are true:
  // - The specified slot ID is not yet used.
  // - This source mob references an AAFTapeDescriptor as an essence
  //   descriptor.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_SLOT_EXISTS
  //   - The specified slotID already exists.
  //
  // AAFRESULT_TAPEDESC_ONLY
  //   - Valid only for AAFSourceMob referencing an AAFTapeDescriptor
  //     as EssenceDescriptor.
  // 
  HRESULT AppendTimecodeSlot (
    // Edit rate of Timecode slot
    [in] aafRational_t  editrate,

    // SlotID of Timecode slot
    [in] aafInt32  slotID,

    // Starting time code
    [in] aafTimecode_t  startTC,

    // Duration of Timecode.
    [in] aafFrameLength_t  length32);


  //***********************************************************
  //
  // AppendEdgecodeSlot()
  //
  // Adds an Edgecode slot to a specified film Mob, with a specified
  // starting edgecode, length, and edit rate. You must add a essence
  // slot with SpecifyValidCodeRange to make the edgecode slot valid.
  //
  // Succeeds if all of the following are true:
  // - The specified slot ID is not yet used.
  // - This source mob references an AAFFilmDescriptor as an essence
  //   descriptor.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_SLOT_EXISTS
  //   - The specified slotID already exists.
  //
  // AAFRESULT_FILMDESC_ONLY
  //   - Valid only for AAFSourceMob referencing an AAFFilmDescriptor
  //   as EssenceDescriptor.
  // 
  HRESULT AppendEdgecodeSlot (
    // Edit rate of the Edgecode slot
    [in] aafRational_t  editrate,

    // SlotID to assign to the new Edgecode slot
    [in] aafInt32  slotID,

    // Starting Edgecode
    [in] aafFrameOffset_t  startEC,

    // Length of the Edgecode component in the slot
    [in] aafFrameLength_t  length32,

    // The film kind.  Can be one of:
	// - kFtNull
    // - kFt35MM
    // - kFt16MM
    // - kFt8MM
    // - kFt65MM
    [in] aafFilmType_t  filmKind,

    // The code format.  Can be one of:
    // - kEtNull
    // - kEtKeycode
    // - kEtEdgenum4
    // - kEtEdgenum5
    [in] aafEdgeType_t  codeFormat,

    // The Edgecode's 8-byte header
    [in] aafEdgecodeHeader_t  header);


  //***********************************************************
  //
  // SpecifyValidCodeRange()
  //
  // Adds slot containing Source Clips to a Source Mob to indicate
  // that the Timecode or Edgecode is valid for that channel.
  //
  // Note: The pEssenceKind parameter requires a data kind valid for a
  // essence stream.  Valid data kinds are:
  // - Picture
  // - Sound
  //
  // Succeeds if all of the following are true:
  // - the pEssenceKind pointer is valid.
  // - The specified slot ID is not yet used.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceKind is null.
  //
  // AAFRESULT_SLOT_EXISTS
  //   - The specified slotID already exists.
  // 
  HRESULT SpecifyValidCodeRange (
    // Data kind for the slot to be added
    [in] IAAFDataDef * pEssenceKind,

    // SlotID for the slot to be added
    [in] aafSlotID_t  slotID,

    // Edit rate for the slot to be added
    [in] aafRational_t  editrate,

    // Start offset for the slot to be added
    [in] aafFrameOffset_t  startOffset,

    // Duration of the Source Clip in the slot
    [in] aafFrameLength_t  length32);


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  // Connects this Source Mob with the physical Source Mob that
  // describes the previous generation of essence, appending it to
  // existing Mob data.  If a physical Source Mob, such as a File
  // Source Mob or tape Source Mob, references another physical
  // Source Mob as its ancestor, with no pulldown, then this
  // function makes the connection between the two.
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFSourceClip referencing a particular piece of media.  This
  // function takes many parameters because the components of an
  // aafSourceRef_t have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  // AAFTapeDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  // 
  HRESULT AppendPhysSourceRef (
    // Edit rate of slot to contain reference
    [in] aafRational_t  editrate,

    // SlotID of slot to contain reference
    [in] aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    [in] IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    [in] aafSourceRef_t  ref,

    // Length of the Source Clip
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  // Connects this Source Mob with the physical Source Mob that
  // describes the previous generation of essence, replacing any
  // existing Mob data.  If a physical Source Mob, such as a File
  // Source Mob or tape Source Mob, references another physical
  // Source Mob as its ancestor, with no pulldown, then this
  // function makes the connection between the two.
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFSourceClip referencing a particular piece of media.  This
  // function takes many parameters because the components of an
  // aafSourceRef_t have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  // AAFTapeDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  // 
  HRESULT NewPhysSourceRef (
    // Edit rate of slot to contain reference
    [in] aafRational_t  editrate,

    // SlotID of slot to contain reference
    [in] aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    [in] IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    [in] aafSourceRef_t  ref,

    // Length of the Source Clip
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // AddPulldownRef()
  //
  // Connects the specified Source Mob with the physical Source Mob
  // that describes the previous generation of essence, with an
  // additional AAFPulldown as part of the reference to indicate a non
  // 1-1 relationship Between the two. 
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFPulldown object which references an AAFSourceClip, which
  // references a particular piece of media.  This function takes many
  // parameters because the components of an aafSourceRef_t and the
  // AAFPulldown object have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFTapeDescriptor is
  // often an AAFFilmDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // - a valid pulldown direction was specified.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  //
  // AAFRESULT_PULLDOWN_DIRECTION
  //   - an invalid pulldown direction was specified.
  // 
  HRESULT AddPulldownRef (
    // Tells whether to overwrite an existing slot segment, or create
	// a sequence and append
    [in] aafAppendOption_t  addType,

    // Edit rate of slot to contain reference
    [in] aafRational_t  editrate,

    // SlotID of slot to contain reference
    [in] aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    [in] IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    [in] aafSourceRef_t  ref,

    // Length of the Source Clip in the Source Mob
    [in] aafLength_t  srcRefLength,

    // Method of conversion.  Possible values are:
    // - kAAFTwoThreePD   	-- Normal NTSC-20fps pulldown
    // - kAAFPALPD
    // - kAAFOneToOneNTSC   -- NTSC recorded as 1 frame == 1 film frame.
    // - kAAFOneToOnePAL    -- PAL recorded as 1 frame == 1 film frame.
    [in] aafPulldownKind_t  pulldownKind,

    // phase of first frame
    [in] aafPhaseFrame_t  phaseFrame,

    // Direction of the pulldown conversion. Possible values are:
    //	- kAAFTapeToFilmSpeed -- Used to link a file descriptor with a
    //							 tape descriptor.
    //	- kAAFFilmToTapeSpeed -- Used to link a tape descriptor with a
    //							 film descriptor.
    [in] aafPulldownDir_t  direction);

}



// ************************
//
// Interface IAAFSourceReference
//
// ************************
//
// The IAAFSourceReference interface is implemented by objects that
// represent the essence or other data described by a MobSlot in a
// Mob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFSourceReference
//     is a primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFSourceReference also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(92B88033-2B2B-11d2-BF7E-00104BC9156D),
    helpstring("IAAFSourceReference Interface"),
    pointer_default(unique)
]
interface IAAFSourceReference : IUnknown
{

  //***********************************************************
  //
  // GetSourceID()
  //
  // Gets the SourceID and places it into the pSourceID argument.
  //
  // Succeeds if all of the following are true:
  // - the pSourceID pointer is valid.
  // 
  // If this method fails nothing will be written to *pSourceID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceID arg is NULL.
  // 
  HRESULT GetSourceID (
    // Place to put source ID
    [retval][out] aafMobID_t *  pSourceID);


  //***********************************************************
  //
  // SetSourceID()
  //
  // Sets the SourceID using the sourceID argument.
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetSourceID (
    // Source ID to set
    [in] aafMobID_constref   sourceID);


  //***********************************************************
  //
  // GetSourceMobSlotID()
  //
  // Gets the Mob Slot ID and places it into the pMobSlotID argument.
  //
  // Succeeds if all of the following are true:
  // - the pMobSlotID pointer is valid.
  // 
  // If this method fails nothing will be written to *pMobSlotID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMobSlotID arg is NULL.
  // 
  HRESULT GetSourceMobSlotID (
    // Place to put source mob slot ID
    [retval][out] aafSlotID_t *  pMobSlotID);


  //***********************************************************
  //
  // SetSourceMobSlotID()
  //
  // Sets the mob slot ID using the mobSlotID argument.
  // 
  // Succeeds if all of the following are true:
  // - (preconditions here)
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // (other error codes here.)
  // 
  HRESULT SetSourceMobSlotID (
    // Source Mob ID to set
    [in] aafSlotID_t   mobSlotID);
}



// ************************
//
// Interface IAAFStaticMobSlot
//
// ************************

//
// StaticMobSlot describes essence data that has no relationship to time,
// such as a static image; consequently, a StaticMobSlot does not define an
// edit rate.
//


//
// Objects that implement IAAFStaticMobSlot also implement the following interfaces:
//  - IAAFMobSlot
//  - IAAFObject

[
    object,
    uuid(e684d764-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFStaticMobSlot Interface"),
    pointer_default(unique)
]
interface IAAFStaticMobSlot : IUnknown
{


}



// ************************
//
// Interface IAAFTapeDescriptor
//
// ************************

//
// The IAAFTapeDescriptor interface is implemented by objects which
// describe audio tape or videotape media.  A TapeDescriptor object
// shall be the EssenceDescription of a  physical Source Mob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFTapeDescriptor also implement the following interfaces:
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(e58a8569-2a3e-11D2-bfa4-006097116212),
    helpstring("IAAFTapeDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFTapeDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFTapeDescriptor-supporting object.  This method must be called
  // after allocation, and before any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetTapeManufacturer()
  //
  // Sets the Tape Manufacturer string property.
  //
  // Set the TapeManufacturer property to the value specified in
  // pTapeManufacturer.  A copy is made of the data so the caller
  // retains ownership of the *pTapeManufacturer buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pTapeManufacturer pointer is valid.
  // 
  // If this method fails the TapeManufacturer property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeManufacturer arg is NULL.
  // 
  HRESULT SetTapeManufacturer (
    // buffer from which TapeManufacturer is to be read
    [in, string] aafCharacter_constptr  pTapeManufacturer);


  //***********************************************************
  //
  // GetTapeManufacturer()
  //
  // Gets the Tape Manufacturer string property.
  // 
  // Writes the TapeManufacturer property, with a trailing null
  // character, into the pTapeManufacturer buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the TapeManufacturer property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetTapeManufacturerBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pTapeManufacturer.
  // 
  // Succeeds if:
  // - The pTapeManufacturer pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   TapeManufacturer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeManufacturer arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold TapeManufacturer.
  // 
  HRESULT GetTapeManufacturer (
    // buffer into which TapeManufacturer is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pTapeManufacturer,

    // size of *pTapeManufacturer buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetTapeManufacturerBufLen()
  //
  // Returns size of buffer (in bytes) required for GetTapeManufacturer().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetTapeManufacturerBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetTapeModel()
  //
  // Sets the Tape Model string property.
  //
  // Set the TapeModel property to the value specified in
  // pTapeModel.  A copy is made of the data so the caller
  // retains ownership of the *pTapeModel buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pTapeModel pointer is valid.
  // 
  // If this method fails the TapeModel property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeModel arg is NULL.
  // 
  HRESULT SetTapeModel (
    // buffer from which TapeModel is to be read
    [in, string] aafCharacter_constptr  pTapeModel);


  //***********************************************************
  //
  // GetTapeModel()
  //
  // Gets the Tape Model string property.
  // 
  // Writes the TapeModel property, with a trailing null
  // character, into the pTapeModel buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the TapeModel property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetTapeModelBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pTapeModel.
  // 
  // Succeeds if:
  // - The pTapeModel pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   TapeModel.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeModel arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold TapeModel.
  // 
  HRESULT GetTapeModel (
    // buffer into which TapeModel is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pTapeModel,

    // size of *pTapeModel buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetTapeModelBufLen()
  //
  // Returns size of buffer (in bytes) required for GetTapeModel().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetTapeModelBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetTapeFormFactor()
  //
  // Sets the form factor [case size] of the tape.
  // 
  // This method succeeds if all of the following are true:
  // - formFactor represents a valid format.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //	- formFactor is invalid.
  // 
  HRESULT SetTapeFormFactor (
    // ex: kVHSVideoTape, kDATCartridge 
    [in] aafTapeCaseType_t  formFactor);


  //***********************************************************
  //
  // GetTapeFormFactor()
  //
  // Gets the form factor [case size] of the tape.
  // 
  // This method succeeds if all of the following are true:
  // - the pFormFactor pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pFormFactor arg is NULL.
  // 
  HRESULT GetTapeFormFactor (
    // ex: kVHSVideoTape, kDATCartridge
    [out] aafTapeCaseType_t *  formFactor);


  //***********************************************************
  //
  // SetSignalType()
  //
  // Sets the signal standard recorded on the tape.
  // 
  // This method succeeds if all of the following are true:
  //	videoSignal represents a valid video signal type.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //	- videoSignal is invalid.
  // 
  HRESULT SetSignalType (
    // ex: kNTSCSignal
    [in] aafVideoSignalType_t  videoSignal);


  //***********************************************************
  //
  // GetSignalType()
  //
  // Gets the signal standard recorded on the tape.
  // 
  // This method succeeds if all of the following are true:
  // - the pVideoSignal pointer is valid.
  //
  // If this method fails nothing will be written to *pVideoSignal.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVideoSignal arg is NULL.
  // 
  HRESULT GetSignalType (
    // ex: kNTSCSignal
    [out] aafVideoSignalType_t *  pVideoSignal);


  //***********************************************************
  //
  // SetTapeFormat()
  //
  // Sets the recording method of the tape.
  // 
  // This method succeeds if all of the following are true:
  // - tapeFormat represents a valid tape format type.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //	- tapeFormat is invalid.
  // 
  HRESULT SetTapeFormat (
    // ex: kBetacamFormat, kBetacamSPFormat
    [in] aafTapeFormatType_t  tapeFormat);


  //***********************************************************
  //
  // GetTapeFormat()
  //
  // Gets the recording method of the tape.
  //
  // Succeeds if all of the following are true:
  // - the pTapeFormat pointer is valid.
  // 
  // This method succeeds if all of the following are true:
  // - the pTapeFormat pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeFormat arg is NULL.
  // 
  HRESULT GetTapeFormat (
    // ex: kBetacamFormat, kBetacamSPFormat
    [out] aafTapeFormatType_t *  pTapeFormat);


  //***********************************************************
  //
  // SetTapeLength()
  //
  // Sets the length of the tape in minutes.
  // 
  // This method succeeds if all of the following are true:
  // - tapeLength is a positive number.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_LENGTH
  //	- tapeLength is negative.
  // 
  HRESULT SetTapeLength (
    // The length of the tape in minutes.
    [in] aafUInt32  tapeLength);


  //***********************************************************
  //
  // GetTapeLength()
  //
  // Gets the length of the tape in minutes.
  //
  // This method succeeds if all of the following are true:
  // - the pTapeLength pointer is valid.
  // 
  // If this method fails nothing will be written to *pTapeLength.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeLength arg is NULL.
  // 
  HRESULT GetTapeLength (
    // The length of the tape in minutes.
    [out] aafUInt32 *  pTapeLength);
}



// ************************
//
// Interface IAAFTaggedValue
//
// ************************
//
// The IAAFTaggedValue interface is implemented by objects that
// specify an User defined tag and value.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFTaggedValue also implement the following interfaces:
//  - IAAFObject

[
    object,
    uuid(e684d762-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFTaggedValue Interface"),
    pointer_default(unique)
]
interface IAAFTaggedValue : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new tagged value object to be identified with the
  // given the given type, and with the given human-legible name.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pName is a valid pointer.
  // - pTypeDef is a valid pointer and registered
  // - pValue is a valid pointer
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName or pTypeDef or pValue arg is NULL.
  // 
  // 
  HRESULT Initialize (
    // User defined name (tag) of this tagged value object
    [in, string] aafCharacter_constptr  pName,

    // Type Definition of the following value data
    [in] IAAFTypeDef * pTypeDef,

    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // buffer containing value
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Name string property.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  // 
  HRESULT GetName (
    // buffer into which Name is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pName,

    // size of *pName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Returns the type definition for this invocation.
  // 
  // Succeeds if all of the following are true:
  // - the ppTypeDef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppTypeDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  // 
  HRESULT GetTypeDefinition (
    // Type definition object
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetValue()
  //
  // Writes the value into the pValue buffer.  The buffer is allocated
  // by the caller, and the size of the buffer is given by
  // valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  // 
  HRESULT GetValue (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // Preallocated buffer to hold value
    [out, size_is(valueSize), length_is(*bytesRead)] aafDataBuffer_t  pValue,

    // Number of actual bytes read
    [out] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the GetValue() method.
  // The value is placed into the location specified by pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  // 
  HRESULT GetValueBufLen (
    // Pointer to an variable used to return the length
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // SetValue()
  //
  // The data value is set from a buffer of size valueSize and type.
  //
  // Succeeds if all of the following are true:
  // - pTypeDef is valid and registered with the object's dictionary.
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  // 
  HRESULT SetValue (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // buffer containing value
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

}



// ************************
//
// Interface IAAFTextLocator
//
// ************************
//
// The IAAFTextLocator interface is implemented by objects which
// provide information to help find a file containing essence data
// in a descriptive way for files that are held off-line.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.
//


//
// Objects that implement IAAFTextLocator also implement the following interfaces:
//  - IAAFLocator
//  - IAAFObject

[
    object,
    uuid(e684d768-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFTextLocator Interface"),
    pointer_default(unique)
]
interface IAAFTextLocator : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFNetworkLocator-supporting object.  This method must be called
  // after allocation, and before any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetName()
  //
  // Sets the Name string property.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  // 
  HRESULT SetName (
    // buffer from which Name is to be read
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Name string property.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  // 
  HRESULT GetName (
    // buffer into which Name is to be written
    [out, string, size_is(bufSize)] aafCharacter *  pName,

    // size of *pName buffer in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  // 
  HRESULT GetNameBufLen (
    // size of required buffer, in bytes
    [out] aafUInt32 *  pBufSize);
}



// ************************
//
// Interface IAAFTimecode
//
// ************************
//
// The IAAFTimecode interface is implemented by objects which store
// videotape or audio tape timecode information.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFTimecode also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(92B88035-2B2B-11d2-BF7E-00104BC9156D),
    helpstring("IAAFTimecode Interface"),
    pointer_default(unique)
]
interface IAAFTimecode : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this object with the given length and timecode
  // values.  Length is specified in units of the edit rate of the
  // containing timeline mob slot.
  // 
  // Succeeds if all of the following are true:
  // - this object has not yet been initialized.
  // - the pTimecode pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimecode argument is NULL.
  // 
  HRESULT Initialize (
    // Length Property Value
    [in] aafLength_t  length,

    // Timecode Value (startFrame, drop, fps)
    [in] aafTimecode_t*  pTimecode);


  //***********************************************************
  //
  // GetTimecode()
  //
  // Get the timecode fields.
  //
  // Succeeds if all of the following are true:
  // - the pTimecode pointer is valid.
  // 
  // If this method fails nothing will be written to *pTimecode.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimecode arg is NULL.
  // 
  HRESULT GetTimecode (
    // Timecode (startFrame, drop, fps)
    [out] aafTimecode_t *  pTimecode);


  //***********************************************************
  //
  // SetTimecode()
  //
  // Set the timecode fields.
  // 
  // Succeeds if all of the following are true:
  // - the pTimecode pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimecode arg is NULL.
  // 
  HRESULT SetTimecode (
    // Timecode (startFrame, drop, fps)
    [in] aafTimecode_t *  timecode);


}



// ************************
//
// Interface IAAFTimelineMobSlot
//
// ************************
//
// The IAAFTimelineMobSlot interface is implemented by objects which
// contain time-varying timeline essence.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// Types required by this module:
//
// aafBool
// aafRational_t
// aafPosition_t
// aafTrackID_t
//


//
// Objects that implement IAAFTimelineMobSlot also implement the following interfaces:
//  - IAAFMobSlot
//  - IAAFObject

[
    object,
    uuid(B1A21378-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFTimelineMobSlot Interface"),
    pointer_default(unique)
]
interface IAAFTimelineMobSlot : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFTimelineMobSlot-supporting object.  This method must be
  // called after allocation, and before any other method can be
  // called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetEditRate()
  //
  // This method will get the edit rate for this mob slot.
  // 
  // Succeeds if all of the following are true:
  // - the pEditRate pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditRate arg is NULL.
  // 
  HRESULT GetEditRate (
    // Edit rate property value
    [out,retval] aafRational_t *  pEditRate);


  //***********************************************************
  //
  // SetEditRate()
  //
  // This method will get set edit rate for this mob slot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetEditRate (
    // Edit rate property value
    [in] aafRational_constref  editRate);


  //***********************************************************
  //
  // GetOrigin()
  //
  // This method will return the origin of this mob slot.
  // 
  // Succeeds if all of the following are true:
  // - the pOrigin pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOrigin arg is NULL.
  // 
  HRESULT GetOrigin (
    // Origin property value
    [out,retval] aafPosition_t *  pOrigin);


  //***********************************************************
  //
  // SetOrigin()
  //
  // This method will set the origin of this mob slot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.).
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetOrigin (
    // Origin property value
    [in] aafPosition_t  origin);
}



// ************************
//
// Interface IAAFTransition
//
// ************************
//
// The IAAFTransition interface is implemented by objects describe a
// change or transition from one piece of essence to another.
// Transitions must exist in the context of a sequence, and must be
// surrounded on both sides by segments (an object which has an
// IAAFSegment interface).
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFMob is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFTransition also implement the following interfaces:
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(E3F38312-2D3C-11d2-8043-006008143E6F),
    helpstring("IAAFTransition Interface"),
    pointer_default(unique)
]
interface IAAFTransition : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Constructor which allows specification of starting values.
  // 
  HRESULT Initialize (
    // Data Definition Object
    [in] IAAFDataDef * pDataDef,

    // Length property value
    [in] aafLength_t  length,

    // The point at which a cut would be inserted if the transition
	// were removed
    [in] aafPosition_t  cutPoint,

    // A reference to an operation group object
    [in] IAAFOperationGroup * op);	 


  //***********************************************************
  //
  // GetCutPoint()
  //
  // Gets the point at which a cut would be inserted if the transition
  // were removed.
  // 
  HRESULT GetCutPoint (
    // Cut Point
    [out] aafPosition_t *  cutPoint);


  //***********************************************************
  //
  // GetOperationGroup()
  //
  // Gets the OperationGroup associated with the transition.
  // 
  HRESULT GetOperationGroup (
    // OperationGroup used by transition
    [out] IAAFOperationGroup ** groupObj);


  //***********************************************************
  //
  // SetCutPoint()
  //
  // Sets the point at which a cut would be inserted if the transition
  // were removed.
  // 
  HRESULT SetCutPoint (
    // Cut Point
    [in] aafPosition_t  cutPoint);


  //***********************************************************
  //
  // SetOperationGroup()
  //
  // Sets the operation group associated with the transition.
  // 
  HRESULT SetOperationGroup (
    // Operation group used by transition
    [in] IAAFOperationGroup * opgroup);
}



// ************************
//
// Interface IAAFTIFFDescriptor
//
// ************************


//
// The IAAFTIFFDescriptor interface is implemented by objects which
// describe TIFF format media.  A TIFFDescriptor object
// shall be the EssenceDescription of a  physical Source Mob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//  


//
// Objects that implement IAAFTIFFDescriptor also implement the following interfaces:
//  - IAAFFileDescriptor
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(e684d76c-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFTIFFDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFTIFFDescriptor : IUnknown
{

  //***********************************************************
  //
  // SetIsUniform()
  //
  // Set to TRUE if essence data has the same number of rows per strip
  // throughout.
  //
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetIsUniform (
    // Sets the IsUniform flag value
    [in] aafBoolean_t  IsUniform);


  //***********************************************************
  //
  // GetIsUniform()
  //
  // Places TRUE into *pIsUniform if the data has the same number of
  // rows per strip throughout.
  //
  // Succeeds if all of the following are true:
  // - the pIsUniform pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsUniform.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsUniform arg is NULL.
  // 
  HRESULT GetIsUniform (
    // Gets the IsUniform flag value
    [out] aafBoolean_t *  pIsUniform);


  //***********************************************************
  //
  // SetIsContiguous()
  //
  // Set to TRUE if essence data is stored in contiguous bytes.
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetIsContiguous (
    // is data stores in contiguous bytes
    [in] aafBoolean_t  IsContiguous);


  //***********************************************************
  //
  // GetIsContiguous()
  //
  // Places TRUE into *pIsContiguous if essence data is stored in
  // contiguous bytes.
  //
  // Succeeds if all of the following are true:
  // - the pIsContiguous pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsContiguous.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsContiguous arg is NULL.
  // 
  HRESULT GetIsContiguous (
    // is this data stored in contiguous bytes
    [out] aafBoolean_t *  pIsContiguous);


  //***********************************************************
  //
  // SetLeadingLines()
  //
  // Sets the number of leading lines in the TIFF image file.
  // 
  // This method succeeds if all of the following are true:
  // - LeadingLines is  equal or greater than 0(zero).
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetLeadingLines (
    // Number of leading lines to be thrown away Optional
    [in] aafInt32  LeadingLines);


  //***********************************************************
  //
  // GetLeadingLines()
  //
  // Gets the leading lines of the TIFF image.
  //
  // This method succeeds if all of the following are true:
  // - the pLeadingLines pointer is valid.
  // 
  // If this method fails nothing will be written to *pLeadingLines.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pLeadingLines arg is NULL.
  // 
  HRESULT GetLeadingLines (
    // Address to store the number of leading lines
    [out] aafInt32 *  pLeadingLines);


  //***********************************************************
  //
  // SetTrailingLines()
  //
  // Sets the number of trailing lines in the TIFF image file
  // 
  // This method succeeds if all of the following are true:
  // - TrailingLines is  equal or greater than 0(zero).
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT SetTrailingLines (
    // Number of trailing lines to be thrown away Optional.
    [in] aafInt32  TrailingLines);


  //***********************************************************
  //
  // GetTrailingLines()
  //
  // Gets the trailing lines of the TIFF image.
  //
  // This method succeeds if all of the following are true:
  // - the pTrailingLines pointer is valid.
  // 
  // If this method fails nothing will be written to *pTrailingLines.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTrailingLines arg is NULL.
  // 
  HRESULT GetTrailingLines (
    // Address to store the number of trailing lines.
    [out] aafInt32 *  pTrailingLines);


  //***********************************************************
  //
  // SetJPEGTableID()
  //
  // Sets the JPEG table code for  the TIFF image file
  // 
  // This method always succeeds .
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SetJPEGTableID (
    // Registered JPEG table code or JT_NULL.
    [in] aafJPEGTableID_t  JPEGTableID);


  //***********************************************************
  //
  // GetJPEGTableID()
  //
  // Gets the JPEG table code of the TIFF image.
  //
  // This method succeeds if all of the following are true:
  // - the pJPEGTableID pointer is valid.
  // 
  // If this method fails nothing will be written to *pJPEGTableID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pJPEGTableID arg is NULL.
  // 
  HRESULT GetJPEGTableID (
    // Address to store the nJPEG table code
    [out] aafJPEGTableID_t *  pJPEGTableID);


  //***********************************************************
  //
  // GetSummary()
  //
  // Gets a copy of the TIFF IFD file information without the media.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer.
  // - The size of the buffer is large enough to hold the TIFF IFD
  //   file information. 
  // 
  // If this method fails pSummary will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - The buffer is too small to hold the WAVE file information.
  // 
  HRESULT GetSummary (
    // Size of preallocated buffer
    [in] aafUInt32  size,

    // Preallocated buffer to hold the TIFF IFD file information
    [out, size_is(size)] aafDataValue_t  pSummary);


  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  // Returns the size of the buffer required for the GetSummary()
  // method.  The value is placed into the location specified by pSize.
  //
  // Succeeds if all of the following are true:
  // - the pSize pointer is valid.
  //
  // If this method fails nothing will be written to *pSize.
  //
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  // 
  HRESULT GetSummaryBufferSize (
    // required buffer size
    [out] aafUInt32 *  pSize);


  //***********************************************************
  //
  // SetSummary()
  //
  // Sets the TIFF IFD file information.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer
  // 
  // If this method fails the summary property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  // 
  HRESULT SetSummary (
    // Size of preallocated buffer
    [in] aafUInt32  size,

    // buffer containing value
    [in, size_is(size)] aafDataValue_t  pSummary);
}



// ************************
//
// Interface IAAFTimecodeStream
//
// ************************
//
// Objects which support IAAFTimecodeStream specify a stream of
// timecode data.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFSearchSource is
//     not a primary interface for a concrete class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//


//
// Objects that implement IAAFTimecodeStream also implement the following interfaces:
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(7B007BF2-2D39-11d2-8043-006008143E6F),
    helpstring("IAAFTimecodeStream Interface"),
    pointer_default(unique)
]
interface IAAFTimecodeStream : IUnknown
{

  //***********************************************************
  //
  // GetPositionTimecode()
  //
  // Get the timecode fields at the given position.
  // 
  HRESULT GetPositionTimecode (
    // Zero based offset to set the timecode at
    [in] aafPosition_t  position,

    // Timecode [startFrame drop fps]
    [out] aafTimecode_t *  timecode);


  //***********************************************************
  //
  // SetPositionTimecode()
  //
  // Set the timecode fields for a given frame.  The frame index must
  // be within the length of the object.
  // 
  HRESULT SetPositionTimecode (
    // Zero-based offset to set the timecode at
    [in] aafPosition_t  position,

    // Timecode [startFrame  drop  fps]
    [in] aafTimecode_t  timecode);


  //***********************************************************
  //
  // GetUserDataLength()
  //
  // Gets the length of the user data for one frame.
  // 
  HRESULT GetUserDataLength (
    // Fixed length of the user data [userbits] in bytes
    [out] aafInt32 *  length);


  //***********************************************************
  //
  // GetUserDataAtPosition()
  //
  // Gets the user data [userbits] for a particular frame.
  // 
  HRESULT GetUserDataAtPosition (
    // Zero-based offset
    [in] aafPosition_t  position,

    // Length of the buffer
    [in] aafInt32  buflen,

    // Passed in and filled with user data
    [out] aafDataBuffer_t  buffer);


  //***********************************************************
  //
  // SetUserDataAtPosition()
  //
  // Gets the user data [userbits] for a particular frame.
  // 
  HRESULT SetUserDataAtPosition (
    // Zero-based offset to set the userbits at
    [in] aafPosition_t  position,

    // Length of the buffer
    [in] aafInt32  buflen,

    // user data for the given frame
    [in] aafDataBuffer_t  buffer);
							 

  //***********************************************************
  //
  // SetSampleRate()
  //
  // Sets the sample rate of the timecode data.
  // 
  HRESULT SetSampleRate (
    // The sample rate of the timecode data
    [in] aafRational_t  sampleRate);


  //***********************************************************
  //
  // GetSampleRate()
  //
  // Gets the sample rate of the timecode data.
  // 
  HRESULT GetSampleRate (
    // The sample rate of the timecode data
    [out] aafRational_t *  pSampleRate);


  //***********************************************************
  //
  // SetSourceType()
  //
  // Sets the type (LTC or VITC) of the timecode data.
  // 
  HRESULT SetSourceType (
    // The type (LTC or VITC) of the timecode data
    [in] aafTimecodeSourceType_t  sourceType);


  //***********************************************************
  //
  // GetSourceType()
  //
  // Gets the type (LTC or VITC) of the timecode data.
  // 
  HRESULT GetSourceType (
    // The type (LTC or VITC) of the timecode data
    [out] aafTimecodeSourceType_t *  pSourceType);


  //***********************************************************
  //
  // GetSampleSize()
  //
  // Gets the size (in samples) of one sample of the timecode data.
  // 
  HRESULT GetSampleSize (
    // The size (in bytes) of one sample of the timecode data
    [out] aafUInt32 *  pSampleSize);


  //***********************************************************
  //
  // GetSource()
  //
  // Writes the entire timecode data value into the pValue buffer.
  // The buffer is allocated by the caller, and the size of the
  // buffer is given by valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  // 
  HRESULT GetSource (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // Preallocated buffer to hold value
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  pValue,

    // Number of actual bytes read
    [out] aafUInt32*  bytesRead);


  //***********************************************************
  //
  // GetSourceBufLen()
  //
  // Returns the length of buffer required for the GetValue()
  // method.  The value is placed into the location specified by
  // pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  // 
  HRESULT GetSourceBufLen (
    // Pointer to an variable used to return the length
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // SetSource()
  //
  // The data value is set from a buffer of size valueSize.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue is null.
  // 
  HRESULT SetSource (
    // Size of preallocated buffer
    [in] aafUInt32  valueSize,

    // buffer containing value
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);


}



// ************************
//
// Interface IAAFTimecodeStream12M
//
// ************************


//
// Objects that implement IAAFTimecodeStream12M also implement the following interfaces:
//  - IAAFTimecodeStream
//  - IAAFSegment
//  - IAAFComponent
//  - IAAFObject

[
    object,
    uuid(EBF5EDB2-2D3A-11d2-8043-006008143E6F),
    helpstring("IAAFTimecodeStream12M Interface"),
    pointer_default(unique)
]

interface IAAFTimecodeStream12M : IUnknown
{


}



// ************************
//
// Interface IAAFTypeDef
//
// ************************
//
// This interface is used to define types used in AAF persistent
// objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFObject is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.


//
// Objects that implement IAAFTypeDef also implement the following interfaces:
//  - IAAFMetaDefinition

[
    object,
    uuid(dfbd6523-1d81-11d2-bf96-006097116212),
    helpstring("IAAFTypeDef Interface"),
    pointer_default(unique)
]
interface IAAFTypeDef : IUnknown
{

  //***********************************************************
  //
  // GetTypeCategory()
  //
  // Returns the type category to which this type definition	belongs.
  // 
  // Succeeds if:
  // - The pTid argument is valid
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTid arg is NULL.
  // 
  HRESULT GetTypeCategory (
    // Returned type category
    [out] eAAFTypeCategory_t *  pTid);


  //***********************************************************
  //
  // RawAccessType()
  //
  // This method returns the type def through which values of this
  // type may be accessed if the client wishes to access the value as
  // as raw data.
  //
  // NOTE! Stub only.   Implementation not yet added.
  // 
  // Succeeds if:
  // - The ppRawTYPEDEF argument is valid
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppRawTypeDef arg is NULL.
  // 
  HRESULT RawAccessType (
    // the raw access type definition
    [out] IAAFTypeDef ** ppRawTypeDef);


}



// ************************
//
// Interface IAAFTypeDefCharacter
//
// ************************
//
// This interface is used to define Integer types used in AAF persistent
// objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefCharacter also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(FE717CAA-F04C-11d3-800B-00104BC9156D),
    helpstring("IAAFTypeDefCharacter Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefCharacter : IUnknown
{


  //***********************************************************
  //
  // CreateValueFromCharacter()
  //
  // Gets a property value corresponding to the character data. 
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pCharacterValue pointer is valid.
  // - The ppActualPropertyValue pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppCharacterValue is not a valid pointer.
  //
  // 
  HRESULT CreateValueFromCharacter (
    // character data to write the the new value
    [in] aafCharacter  character,

    // character property value with the given character
    [out] IAAFPropertyValue ** ppCharacterValue);

  //***********************************************************
  //
  // GetCharacter()
  //
  // Gets a character from the property value. 
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pCharacterValue pointer is valid.
  // - The ppActualPropertyValue pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - pCharacterValue is not a valid character property value.
  //
  // 
  HRESULT GetCharacter (
    // character property value to read
    [in] IAAFPropertyValue * pCharacterValue,

    // character that is read
    [out] aafCharacter *  pCharacter);

  //***********************************************************
  //
  // SetCharacter()
  //
  // Sets a character into the given property value. 
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pCharacterValue pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - pCharacterValue is not a valid character property value.
  //
  // 
  HRESULT SetCharacter (
    // character property value to modify
    [in] IAAFPropertyValue * pCharacterValue,

    // character that is written
    [in] aafCharacter  character);


}



// ************************
//
// Interface IAAFTypeDefIndirect
//
// ************************
//
// This interface is used to define Integer types used in AAF persistent
// objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefIndirect also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(FE717CA8-F04C-11d3-800B-00104BC9156D),
    helpstring("IAAFTypeDefIndirect Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefIndirect : IUnknown
{


  //***********************************************************
  //
  // CreateValueFromActualValue()
  //
  // Creates an indirect property value which contains the actual type.  
  // Returns the newly-created property value in ppIndirectPropertyValue.
  //
  // Succeeds if all of the following are true:
  // - the pActualValue pointer is valid.
  // - the ppIndirectPropertyValue pointer is valid.
  //
  // If this method fails nothing will be written to *ppIndirectPropertyValue.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pActualValue or ppIndirectPropertyValue arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  // 
  HRESULT CreateValueFromActualValue (
    // pointer to actual value
    [in] IAAFPropertyValue * pActualValue,

    // newly created property value
    [out] IAAFPropertyValue ** ppIndirectPropertyValue);

  //***********************************************************
  //
  // CreateValueFromActualData()
  //
  // Creates an indirect property value which contains data of the 
  // actual type.  Returns the newly-created property value in
  // ppIndirectPropertyValue.
  //
  // Succeeds if all of the following are true:
  // - the pActualType pointer is valid and registered
  // - the pInitData pointer is valid.
  // - the ppIndirectPropertyValue pointer is valid.
  // - initDataSize indicates pInitData is the correct size for 
  //   the actual type.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppIndirectPropertyValue.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pActualType or InitData or ppIndirectPropertyValue arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  // 
  HRESULT CreateValueFromActualData (
    // the actual type of the data
    [in] IAAFTypeDef * pActualType,

    // pointer to buffer containing data to use
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,

    // size of data in pInitData
    [in] aafUInt32  initDataSize,

    // newly created property value
    [out] IAAFPropertyValue ** ppIndirectPropertyValue);


  //***********************************************************
  //
  // GetActualValue()
  //
  // Gets a property value corresponding to the actual data. 
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pIndirectPropertyValue pointer is valid.
  // - The ppActualPropertyValue pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pIndirectPropertyValue or ppActualPropertyValue arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  // 
  HRESULT GetActualValue (
    // indirect property value to read
    [in] IAAFPropertyValue * pIndirectPropertyValue,

    // value that is read
    [out] IAAFPropertyValue ** ppActualPropertyValue);
  //)

  //***********************************************************
  //
  // GetActualSize()
  //
  // Return the size of the actual data withing the indirect property value.
  //
  //
  // Succeeds if all of the following are true:
  // - the pIndirectPropertyValue pointer is valid.
  // - the pActualSize pointer is valid.
  //
  // If this method fails nothing will be written to *pActualSize.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pIndirectPropertyValue or pActualSize arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the type of pIndirectPropertyValue was not indirect. 
  //
  // AAFRESULT_TYPE_NOT_FOUND
  //   - the actual type cannot be found in the dictionary.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for 
  //    the actual typedef.
  // 
  HRESULT GetActualSize (
    // indirect property value to read
    [in] IAAFPropertyValue * pIndirectPropertyValue,

    // actual data size
    [out] aafUInt32 *  pActualSize);
  //***********************************************************
  //
  // GetActualType()
  //
  // Return the type definition of the  actual data within the indirect property value.
  //
  //
  // Succeeds if all of the following are true:
  // - the pIndirectPropertyValue pointer is valid.
  // - the pActualType pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pIndirectPropertyValue or pActualType arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the type of pIndirectPropertyValue was not indirect. 
  //
  // AAFRESULT_TYPE_NOT_FOUND
  //   - the actual type cannot be found in the dictionary.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for 
  //    the actual typedef.
  // 
  HRESULT GetActualType (
    // indirect property value to read
    [in] IAAFPropertyValue * pIndirectPropertyValue,

    // the type definition of the actual data
    [out] IAAFTypeDef ** pActualType);

  //***********************************************************
  //
  // GetActualData()
  //
  // Copies all the actual data contained in the given indirect property value,
  // interpreted as the actual type for this indirect property value, into the 
  // buffer pointed to by pData.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_TYPE_NOT_FOUND
  //   - the actual type cannot be found in the dictionary.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for 
  //    the actual typedef.
  // 
  HRESULT GetActualData (
    // indirect property value to read
    [in] IAAFPropertyValue * pPropVal,

    // buffer into which actual data should be written
    [out, size_is(dataSize)] aafMemPtr_t  pData,

    // size of pData buffer in bytes
    [in] aafUInt32  dataSize);


}



// ************************
//
// Interface IAAFTypeDefInt
//
// ************************
//
// This interface is used to define Integer types used in AAF persistent
// objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefInt also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(809c8ca2-9884-11d2-841f-00600832acb8),
    helpstring("IAAFTypeDefInt Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefInt : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be identified by the given guid, to
  // have the given size in bytes, and to be signed or unsigned.
  //
  // The implementation of this method may only allow certain values
  // for intSize.  It *will* allow at least 1, 2, 4, and 8-byte
  // integers; some implementations may allow more than that.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - intSize is a valid value.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_BAD_SIZE
  //  - intSize is not a valid value.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // the size of this integer type in bytes
    [in] aafUInt8  intSize,

    // true if this integer type is signed; false for unsigned
    [in] aafBoolean_t  isSigned,

    // friendly name of this type definition
    [in, string] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // CreateValue()
  //
  // Creates a property value which contains an integer.  Initializes
  // it to contain the given integer value.  The initialization value
  // is passed through pVal; the size of the initialzation value is
  // given in valSize.
  //
  // valSize may be smaller than GetSize() for this typedef; if so,
  // the value is lsb-justified and sign-extended (for signed) or
  // zero-filled (for unsigned).
  //
  // The implementation of this method may only allow certain values
  // for valSize.  It *will* allow at least 1, 2, 4, and 8-byte
  // integers; some implementations may allow more than that.
  //
  // Succeeds if:
  // - The pVal pointer is valid.
  // - The ppPropVal pointer is valid.
  // - valSize is no larger than GetSize() for this typedef.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pVal or ppPropVal arg is NULL.
  //
  // AAFRESULT_BAD_SIZE
  //   - valSize is larger than GetSize() for this typedef, or
  //     valSize is not a supported value.
  // 
  HRESULT CreateValue (
    // pointer to integer initialization value
    [in, size_is(valSize)] aafMemPtr_t  pVal,

    // size of integer, in bytes, in pVal
    [in] aafUInt32  valSize,

    // newly created property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetInteger()
  //
  // Returns the integer value of this property.  The value
  // to set is passed through pVal.  The size of the pVal buffer is
  // given in valSize.  valSize may be larger than GetSize(); if so,
  // the value is lsb-justified and sign-extended (for signed) or
  // zero-filled (for unsigned).
  //
  // valSize may be smaller than GetSize() for this typedef; if so,
  // the value is lsb-justified and sign-extended (for signed) or
  // zero-filled (for unsigned).
  //
  // The implementation of this method may only allow certain values
  // for valSize.  It *will* allow at least 1, 2, 4, and 8-byte
  // integers; some implementations may allow more than that.
  //
  // Succeeds if:
  // - The pPropVal pointer is valid.
  // - The pVal pointer is valid.
  // - valSize indicates that pVal is large enough to hold the value.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pVal arg is NULL.
  //
  // AAFRESULT_BAD_SIZE
  //   - valSize is smaller than GetSize() for this typedef, or
  //     valSize is not a supported value.
  //
  // AAFRESULT_BAD_TYPE
  //   - The type associated with pPropVal cannot be read as an
  //     integral type, or the int size of pPropVal is larger than the
  //     int size of this type.
  // 
  HRESULT GetInteger (
    // property value from which value is to be read
    [in] IAAFPropertyValue * pPropVal,

    // buffer into which value is written
    [out, size_is(valSize)] aafMemPtr_t  pVal,

    // size of pVal buffer in bytes
    [in] aafUInt32  valSize);


  //***********************************************************
  //
  // SetInteger()
  //
  // Sets this property value to the given integer value.  The value
  // to set is passed in pVal, and the size of the value in pVal is
  // given in valSize.  valSize may be smaller than GetSize(); if so,
  // the value is lsb-justified and sign-extended (for signed) or
  // zero-filled (for unsigned).
  //
  // Succeeds if:
  // - The pPropVal pointer is valid.
  // - The pVal pointer is valid.
  // - valSize indicates that pVal is large enough to hold the value.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pVal arg is NULL.
  //
  // AAFRESULT_BAD_SIZE
  //   - valSize is larger than GetSize() for this typedef.
  // 
  HRESULT SetInteger (
    // property value from which value is to be read
    [in] IAAFPropertyValue * pPropVal,

    // buffer from which value is read
    [in, size_is(valSize)] aafMemPtr_t  pVal,

    // size of pVal buffer in bytes
    [in] aafUInt32  valSize);


  //***********************************************************
  //
  // GetSize()
  //
  // Returns the size of the integral value defined by this type
  // definition. 
  //
  // Succeeds if:
  // - The pSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  // 
  HRESULT GetSize (
    // the returned size of this integral value, in bytes
    [out] aafUInt32 *  pSize);


  //***********************************************************
  //
  // IsSigned()
  //
  // Puts true in *pSigned if property values defined with this type
  // def are signed; puts false there for unsigned property values.
  //
  // Succeeds if:
  // - The pSigned pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSigned arg is NULL.
  // 
  HRESULT IsSigned (
    // set to true if this integer type is signed; set to false for
    // unsigned
    [out] aafBoolean_t *  pSigned);


}



// ************************
//
// Interface IAAFTypeDefRename
//
// ************************
//
// This interface is used to define Renamed types (analogous to C
// typedefs) used in AAF persistent objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFTypeDefRename also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(307e9e6a-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefRename Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefRename : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be an alias for the given type
  // (similar to a C typedef).
  // 
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pBaseType is a valid pointer.
  // - pTypeName is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  // AAFRESULT_NULL_PARAM
  //   - pBaseType or pTypeName is null.
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // type to which this is an alias
    [in] IAAFTypeDef * pBaseType,

    // friendly name of this type definition
    [in, string] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetBaseType()
  //
  // Returns the type definition to which this type def is an alias.
  //
  // Succeeds if:
  // - this object has been Initialize()d.
  // - The ppBaseType pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppBaseType pointer is NULL.
  // 
  HRESULT GetBaseType (
    // type definition for which this is an alias
    [out] IAAFTypeDef ** ppBaseType);


  //***********************************************************
  //
  // GetBaseValue()
  //
  // // Gets the property value of the base type from the given property
  // value of the typedef type and places a pointer to the base type's
  // property value into *ppOutPropVal.
  //
  // Succeeds if:
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInPropVal or ppOutPropVal is NULL.
  // 
  HRESULT GetBaseValue (
    // property value from which value is to be read
    [in] IAAFPropertyValue * pInPropVal,

    // pointer to property value represented by base type
    [out] IAAFPropertyValue ** ppOutPropVal);

  //***********************************************************
  //
  // CreateValue()
  //
  // // Gets the property value of the typedef type from the given property
  // value of the base type and places a pointer to the base type's
  // property value into *ppOutPropVal.
  //
  // Succeeds if:
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInPropVal or ppOutPropVal is NULL.
  // 
  HRESULT CreateValue (
    // property value from which value is to be read
    [in] IAAFPropertyValue * pInPropVal,

    // pointer to property value represented by rename type
    [out] IAAFPropertyValue ** ppOutPropVal);


}



// ************************
//
// Interface IAAFTypeDefEnum
//
// ************************
//
// This interface is used to define enumerated types used in AAF
// persistent objects.  Enumerated types are assumed to be based on
// integers of no larger than 64 bits.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefEnum also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(307e9e64-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefEnum Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefEnum : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be identified by the given guid, to
  // be implemented as the given data type, and to contain the given
  // elements (names and values).  The given data type must be an
  // integral type.  It is considered an error if multiple elements
  // have the same name or the same value.  The values and names are
  // given in parallel arrays, each of which has numElements
  // elements.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pType is a valid pointer.
  // - pElementValues is a valid pointer.
  // - pElementNames is a valid pointer.
  // - pTypeName is a valid pointer.
  // - base type is integral type.
  // - no duplicate names or values are found.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - any pointer argument arg is NULL.
  //
  // AAFRESULT_DUPLICATE
  //   - duplicate name or value is found.
  //
  // AAFRESULT_BAD_TYPE
  //   - base type is not integral type.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // Type of values in this enumeration.
			// Has to be of type Int
    [in] IAAFTypeDef * pType,

    // array of element values to be represented in this enumerated
    // type
    [in, size_is(numElems)] aafInt64 *  pElementValues,

    // array of element names to be represented in this enumerated
    // type
    [in, size_is(numElems)] aafString_t *  pElementNames,

    // number of members in pElementValues and pElementNames arrays
    [in] aafUInt32  numElems,

    // friendly name of this type definition
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // CreateValueFromName()
  //
  // Creates a property value which contains an Enum type.  A
  // lookup on the Name is done to find a match in the list of 
  // legal enumerations for this type. If the Name specified is not
  // found to exist then an INVALID_PARAM error code is returned.
  // If it succeeds then a newly-created property value in ppPropVal
  // is returned.
  //
  // Succeeds if all of the following are true:
  // - the Name pointer is valid.
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropVal arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - the Name specified is not in the list of legal Enumerations.
  // 
  HRESULT CreateValueFromName (
    // the Name of a valid Enum symbol
    [in] aafCharacter_constptr  Name,

    // newly created property value
    [out] IAAFPropertyValue ** ppPropVal);
  
  
  
  //***********************************************************
  //
  // GetElementType()
  //
  // Returns the type definition of the values which are found in this
  // enumeration.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The ppTypeDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  // 
  HRESULT GetElementType (
    // type definition of values of this enumeration
    [out] IAAFTypeDef ** ppTypeDef);

  //***********************************************************
  //
  // GetElementValue()
  //
  // Gets the indexed element in this enumerated type.  The
  // value is written into the client-allocated *pOutValue.  Index
  // must be less than the value returned by CountElements().
  //
  // Succeeds if:
  // - pOutValue is a valid pointer.
  // - index is less than CountElements().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOutValue arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  // 
  HRESULT GetElementValue (
    // index of element to retrieve
    [in] aafUInt32  index,

    // requested value
    [out] aafInt64 *  pOutValue);

  //***********************************************************
  //
  // GetElementName()
  //
  // Gets the indexed element in this enumerated type.  The
  // Name is written into the client-allocated *pOutValue. The
  // bufSize argument should be large enough to hold the pOutValue.
  // Index must be less than the value returned by CountElements().
  //
  // Caller may call GetElementNameBufLen() to determine the
  // required buffer size.
  //  
  // Succeeds if:
  // - pOutValue is a valid pointer.
  // - index is less than CountElements().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOutValue arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // 
  HRESULT GetElementName (
    // index of element to retrieve
    [in] aafUInt32  index,

    // requested value
    [out, size_is(bufSize)] aafCharacter *  pOutValue,

    // The size of the pOutValue buffer in bytes
    [in] aafUInt32  bufSize);
  
  

  //***********************************************************
  //
  // GetElementNameBufLen()
  //
  // Returns the length of buffer required for the GetElementName()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if the following is true:
  // - the pLen pointer is valid.
  // - index is less than CountElements().
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  // 
  HRESULT GetElementNameBufLen (
    // index of element to retrieve
    [in] aafUInt32  index,

    // required buffer length, in bytes
    [out] aafUInt32 *  pLen);


  
  //***********************************************************
  //
  // CountElements()
  //
  // Returns number of enumeration elements contained.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  // 
  HRESULT CountElements (
    // count of elements within this enumeration
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // GetNameFromValue()
  //
  // Writes the human-legible tag associated with the given value in
  // this enumerated type.  The name is written, with a trailing null
  // character, into the pName buffer.  The buffer is allocated by
  // the caller.  The size of the buffer is given by bufSize.
  // 
  // Caller may call GetNameBufLenFromValue() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // - the integer value is associated with an element of this
  //   enumerated type.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pValue or pName arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of
  //     this type.
  // 
  HRESULT GetNameFromValue (
    // value of element to get
    [in] IAAFPropertyValue * pValue,

    // buffer into which the element name is written
    [out, size_is(bufSize), string] aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLenFromValue()
  //
  // Returns the length of buffer required for the GetNameFromValue()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - the pLen pointer is valid.
  // - the value is associated with an element of this enumerated
  //   type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pValue or pLen arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of this
  //     type.
  // 
  HRESULT GetNameBufLenFromValue (
    // value of element to get
    [in] IAAFPropertyValue * pValue,

    // required buffer length, in bytes
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNameFromInteger()
  //
  // Writes the human-legible tag associated with the given value in
  // this enumerated type.  The name is written, with a trailing null
  // character, into the pName buffer.  The buffer is allocated by
  // the caller.  The size of the buffer is given by bufSize.
  // 
  // Caller may call GetNameBufLenFromInteger() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // - the integer value is associated with an element of this
  //   enumerated type.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the given value is not associated with an element of
  //     this type.
  // 
  HRESULT GetNameFromInteger (
    // value of element to get
    [in] aafInt64  value,

    // buffer into which the element name is written
    [out, size_is(bufSize), string] aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLenFromInteger()
  //
  // Returns the length of buffer required for the GetNameFromInteger()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  // - the value is associated with an element of this enumerated
  //   type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the given value is not associated with an element of this
  //     type.
  // 
  HRESULT GetNameBufLenFromInteger (
    // value of element to get
    [in] aafInt64  value,

    // required buffer length, in bytes
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetIntegerValue()
  //
  // Gets the value from the given property value and writes it as an
  // integer into *pValueOut.
  //
  // Succeeds if:
  // - The pPropValIn pointer is valid.
  // - The pValueOut pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pPropValIn or ppPropValOut arg is NULL.
  // 
  HRESULT GetIntegerValue (
    // property value to read
    [in] IAAFPropertyValue * pPropValIn,

    // value of the enum represented by the given input property value
    [out] aafInt64 *  pValueOut);


  //***********************************************************
  //
  // SetIntegerValue()
  //
  // Sets the given property to the value given in pValueIn.
  //
  // Succeeds if:
  // - The pPropValToSet pointer is valid.
  // - valueIn is a correct value for this enumerated type.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropValToSet arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - valueIn is not a correct value for this enumerated type.
  //   - pPropValIn's type doesn't match GetElementType()
  // 
  HRESULT SetIntegerValue (
    // property value to set
    [in] IAAFPropertyValue * pPropValToSet,

    // new value of the enum represented by the given property value
    [in] aafInt64  valueIn);


  //***********************************************************
  //
  // RegisterSize()
  //
  // Allows client to register to the reference implementation a
  // runtime C enum to represent objects of this TypeDef.  The size of
  // the enum to be represented should be passed as the enumSize
  // argument.  This allows the reference implementation to write
  // property values into compile-time-defined C enums intelligible
  // by the local machine and compiler.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  // 
  HRESULT RegisterSize (
    // size of this enum
    [in] aafUInt32  enumSize);

}



// ************************
//
// Interface IAAFTypeDefExtEnum
//
// ************************
//
// This interface is used to define field-extendible enumerated types
// used in AAF persistent objects.  Enumerated types are assumed to be
// based on AUIDs.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefExtEnum also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(a5456f01-0ef2-11d3-842e-00600832acb8),
    helpstring("IAAFTypeDefExtEnum Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefExtEnum : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be identified by the given guid.  No
  // element values are initially specified; they must be supplied
  // later using the AppendElement method.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pTypeName is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeName arg is NULL.
  //
  // AAFRESULT_DUPLICATE
  //   - duplicate name or value is found.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // friendly name of this type definition
    [in] aafCharacter_constptr  pTypeName);

  //***********************************************************
  //
  // CreateValueFromName()
  //
  // Creates a property value which contains an Enum type.  A
  // lookup on the Name is done to find a match in the list of 
  // legal enumerations for this type. If the Name specified is not
  // found to exist then an INVALID_PARAM error code is returned.
  // If it succeeds then a newly-created property value in ppPropVal
  // is returned.
  //
  // Succeeds if all of the following are true:
  // - the Name pointer is valid.
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropVal arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - the Name specified is not in the list of legal Enumerations.
  // 
  HRESULT CreateValueFromName (
    // the Name of a valid Enum symbol
    [in] aafCharacter_constptr  Name,

    // newly created property value
    [out] IAAFPropertyValue ** ppPropVal);
  

  //***********************************************************
  //
  // CountElements()
  //
  // Returns number of enumeration elements contained.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  // 
  HRESULT CountElements (
    // count of elements within this enumeration
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // GetElementValue()
  //
  // Gets the indexed element in this enumerated type.  The
  // value is written into the client-allocated *pOutValue.  Index
  // must be less than the value returned by CountElements().
  //
  // Succeeds if:
  // - pOutValue is a valid pointer.
  // - index is less than CountElements().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOutValue arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  // 
  HRESULT GetElementValue (
    // index of element to retrieve
    [in] aafUInt32  index,

    // requested value
    [out] aafUID_t *  pOutValue);


  //***********************************************************
  //
  // GetElementName()
  //
  // Gets the indexed element in this enumerated type.  The
  // Name is written into the client-allocated *pOutValue. The
  // bufSize argument should be large enough to hold the pOutValue.
  // Index must be less than the value returned by CountElements().
  //
  // Caller may call GetElementNameBufLen() to determine the
  // required buffer size.
  //  
  // Succeeds if:
  // - pOutValue is a valid pointer.
  // - index is less than CountElements().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOutValue arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // 
  HRESULT GetElementName (
    // index of element to retrieve
    [in] aafUInt32  index,

    // requested value
    [out, size_is(bufSize)] aafCharacter *  pOutValue,

    // The size of the pOutValue buffer in bytes
    [in] aafUInt32  bufSize);
  
  //***********************************************************
  //
  // GetElementNameBufLen()
  //
  // Returns the length of buffer required for the GetElementName()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if the following is true:
  // - the pLen pointer is valid.
  // - index is less than CountElements().
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  // 
  HRESULT GetElementNameBufLen (
    // index of element to retrieve
    [in] aafUInt32  index,

    // required buffer length, in bytes
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNameFromValue()
  //
  // Writes the human-legible tag associated with the given value in
  // this enumerated type.  The name is written, with a trailing null
  // character, into the pName buffer.  The buffer is allocated by
  // the caller.  The size of the buffer is given by bufSize.
  // 
  // Caller may call GetNameBufLenFromValue() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // - the integer value is associated with an element of this
  //   enumerated type.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pValue or pName arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of
  //     this type.
  // 
  HRESULT GetNameFromValue (
    // value of element to get
    [in] IAAFPropertyValue * pValue,

    // buffer into which the element name is written
    [out, size_is(bufSize), string] aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLenFromValue()
  //
  // Returns the length of buffer required for the GetNameFromValue()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - the pLen pointer is valid.
  // - the value is associated with an element of this enumerated
  //   type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pValue or pLen arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of this
  //     type.
  // 
  HRESULT GetNameBufLenFromValue (
    // value of element to get
    [in] IAAFPropertyValue * pValue,

    // required buffer length, in bytes
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNameFromAUID()
  //
  // Writes the human-legible tag associated with the given value in
  // this enumerated type.  The name is written, with a trailing null
  // character, into the pName buffer.  The buffer is allocated by
  // the caller.  The size of the buffer is given by bufSize.
  // 
  // Caller may call GetNameBufLenFromAUID() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // - the integer value is associated with an element of this
  //   enumerated type.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of
  //     this type.
  // 
  HRESULT GetNameFromAUID (
    // value of element to get
    [in, ref] aafUID_constref  value,

    // buffer into which the element name is written
    [out, size_is(bufSize), string] aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLenFromAUID()
  //
  // Returns the length of buffer required for the GetNameFromInteger()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  // - the value is associated with an element of this enumerated
  //   type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of this
  //     type.
  // 
  HRESULT GetNameBufLenFromAUID (
    // value of element to get
    [in, ref] aafUID_constref  value,

    // required buffer length, in bytes
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetAUIDValue()
  //
  // Gets the value from the given property value and writes it as an
  // AUID into *pValueOut.
  //
  // Succeeds if:
  // - The pPropValIn pointer is valid.
  // - The pValueOut pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pPropValIn or ppPropValOut arg is NULL.
  // 
  HRESULT GetAUIDValue (
    // property value to read
    [in] IAAFPropertyValue * pPropValIn,

    // value of the enum represented by the given input property value
    [out] aafUID_t *  pValueOut);


  //***********************************************************
  //
  // SetAUIDValue()
  //
  // Sets the given property to the value given in valueIn.
  //
  // Succeeds if:
  // - The pPropValToSet pointer is valid.
  // - valueIn is a correct value for this enumerated type.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropValToSet arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - valueIn is not a correct value for this enumerated type.
  //   - pPropValIn's type doesn't match GetElementType()
  // 
  HRESULT SetAUIDValue (
    // property value to set
    [in] IAAFPropertyValue * pPropValToSet,

    // new value of the enum represented by the given property value
    [in, ref] aafUID_constref  valueIn);


  //***********************************************************
  //
  // AppendElement()
  //
  // Appends a new element to this extendible enumeration.  The
  // element will have the given name and value.  It is not legal to
  // have elements with duplicate names or values.
  // 
  // Succeeds if:
  // - the pName pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_DUPLICATE
  //   - duplicate name or value is found.
  // 
  HRESULT AppendElement (
    // value of appended element
    [in, ref] aafUID_constref  value,

    // name of appended element
    [in] aafCharacter_constptr  pName);


}



// ************************
//
// Interface IAAFTypeDefFixedArray
//
// ************************
//
// This interface is used to define fixed-sized Array types used in
// AAF persistent objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefFixedArray also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(c3274646-9467-11d2-841f-00600832acb8),
    helpstring("IAAFTypeDefFixedArray Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefFixedArray : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to contain elements of the given type,
  // and have the given fixed size.  Note that it is only possible to
  // use certain types as the element type.  Those permissible types
  // include:
  // - AAFTypeDefInt
  // - AAFTypeDefRecord
  // - AAFTypeDefEnum
  // - AAFTypeDefExtEnum
  // - AAFTypeDefFixedArray
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pTypeDef is a valid pointer.
  // - pTypeName is a valid pointer.
  // - element type is permissible for use in a FixedArray.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pTypeDef or pTypeName arg is NULL.
  //
  // AAFRESULT_BAD_TYPE
  //   - an illegal element type was given.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // type of each element to be contained in this array
    [in] IAAFTypeDef * pTypeDef,

    // number of elements to be in this array
    [in] aafUInt32  nElements,

    // friendly name of this type definition
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetType()
  //
  // Returns the type of elements in this array.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - ppTypeDef is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  // 
  HRESULT GetType (
    // type of elements in this array
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of elements in this array.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  // 
  HRESULT GetCount (
    // count of elements in this array
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  // Creates a property value which contains a fixed array type.  The
  // array elements in the property value are initialized to contain
  // the given values, passed in the pElementValues array.
  // numElements, which indicates the size of the pElementValues
  // array, must match the value returned by GetCount().  Returns
  // the newly-created property value in ppPropVal.
  //
  // Succeeds if all of the following are true:
  // - the pElementValues pointer is valid.
  // - the ppPropVal pointer is valid.
  // - numElements matches the number of elements in this array
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pElementValues or ppPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - numElements does not match GetCount().
  // 
  HRESULT CreateValueFromValues (
    // array of property values for elements of array value which
    // is to be created.
    [in, size_is(numElements)] IAAFPropertyValue ** ppElementValues,

    // size of pElementValues array.
    [in] aafUInt32  numElements,

    // newly-created property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // CreateValueFromCArray()
  //
  // Creates a property value which contains a fixed array type.  The
  // array elements in the property value are initialized from data in
  // a C array which is pointed to by pInitData.  Requires that any
  // structures declared within this array typedef have had their
  // offsets registered with that type.  Returns the newly-created
  // property value in ppPropVal.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppPropVal pointer is valid.
  // - initDataSize indicates pInitData is the correct size.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - any contained struct offsets have not yet been registered for
  //    that typedef.
  // 
  HRESULT CreateValueFromCArray (
    // pointer to compile-time C array containing data to use
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,

    // size of data in pInitData, in bytes
    [in] aafUInt32  initDataSize,

    // newly created property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetElementValue()
  //
  // Gets a single property value corresponding to the indexed array
  // element.  Places a property value representing the array element
  // identified by the index into ppOutPropval.  Index is zero-based,
  // and must be less than the value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given index is out of range for this array type def.
  // 
  HRESULT GetElementValue (
    // property value to read
    [in] IAAFPropertyValue * pInPropVal,

    // zero-based index into elements in this array type
    [in] aafUInt32  index,

    // value that is read
    [out] IAAFPropertyValue ** ppOutPropVal);


  //***********************************************************
  //
  // GetCArray()
  //
  // Copies all the array data contained in the given property value,
  // interpreted as a fixed array of this type, into the C array
  // pointed to by pData.  Requires that any structures declared
  // within this array typedef have had their offsets registered with
  // that type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  // 
  HRESULT GetCArray (
    // property value to read
    [in] IAAFPropertyValue * pPropVal,

    // buffer into which C array data should be written
    [out, size_is(dataSize)] aafMemPtr_t  pData,

    // size of pData buffer in bytes
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // SetElementValue()
  //
  // Sets the value of the single, indicated element of the fixed
  // array contained in pPropVal, to the value contained in
  // pMemberPropVal.  Index is zero-based, and must be less than the
  // value returned by GetCount().  Property value must be of the
  // same type as returned by GetType().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given index is out of range for this array type def.
  // 
  HRESULT SetElementValue (
    // property value to write
    [in] IAAFPropertyValue * pPropVal,

    // zero-based index into members in this array type
    [in] aafUInt32  index,

    // value to be placed into this array
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // SetCArray()
  //
  // Copies all the array data contained in the C array pointed to by
  // pData into the given property value, interpreting the data as a
  // fixed array of this type.  Requires that any structures declared
  // within this typedef have had their offsets registered with that
  // type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData contains the correct amount of data.
  // - any contained compile-time struct has had its member offests
  //   registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //  - dataSize indicates pData is not the correct size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - offsets of any contained struct have not yet been registered.
  // 
  HRESULT SetCArray (
    // property value to write
    [in] IAAFPropertyValue * pPropVal,

    // buffer from which C array data should be read
    [in, size_is(dataSize)] aafMemPtr_t  pData,

    // size of pData buffer in bytes
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // GetElements()
  //
  // Returns an enumerator across elements in this set.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The PSetPropVal pointer is valid.
  // - The ppEnum pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either PSetPropVal or ppEnum arg is NULL.
  // 
  HRESULT GetElements (
    // property value to read
    [in] IAAFPropertyValue * PSetPropVal,

    // enumerator across property values
    [out] IEnumAAFPropertyValues ** ppEnum);

}



// ************************
//
// Interface IAAFTypeDefRecord
//
// ************************
//
// This interface is used to define C-like structured types used in
// AAF persistent objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefRecord also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(809c8ca6-9884-11d2-841f-00600832acb8),
    helpstring("IAAFTypeDefRecord Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefRecord : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be identified by the given guid, and
  // to contain the given members (types and names).  It is considered
  // an error if multiple members have the same name.  Note that it is
  // only possible to use certain types as member types.  Those
  // permissible types include:
  // - AAFTypeDefInt
  // - AAFTypeDefRecord
  // - AAFTypeDefEnum
  // - AAFTypeDefExtEnum
  // - AAFTypeDefFixedArray
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pMemberTypes is a valid pointer.
  // - pMemberNames is a valid pointer.
  // - pTypeName is a valid pointer.
  // - all specified member types are permissible for use in a Record.
  // - all member names are unique.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pMemberTypes, pMemberNames, or pTypeName arg is NULL.
  //
  // AAFRESULT_BAD_TYPE
  //   - an illegal member type was given.
  //
  // AAFRESULT_DUPLICATE
  //   - a duplicate member name was given.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // array of member types to be represented in this record
    // type
    [in, size_is(numMembers)] IAAFTypeDef ** ppMemberTypes,

    // array of member names to be represented in this enumerated
    // type
    [in, size_is(numMembers)] aafString_t *  pMemberNames,

    // number of members in pMemberInfo array
    [in] aafUInt32  numMembers,

    // friendly name of this type definition
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetMemberType()
  //
  // Returns the type definition of the indexed member in this
  // record type.  Index is zero-based, and must be less than the
  // value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this record type def.
  // - The ppTypeDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The given index is out of range for this record type def.
  // 
  HRESULT GetMemberType (
    // zero-based index into members in this record type
    [in] aafUInt32  index,

    // type definition of indexed member
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetMemberName()
  //
  // Writes the human-legible tag associated with the indexed member
  // in this record type.  Index is zero-based, and must be less
  // than the value returned by GetCount().  The name is written,
  // with a trailing null character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.
  // 
  // Caller may call GetMemberNameBufLen() to determine the required
  // buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  // 
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the given integer value is not associated with a member of
  //     this type.
  // 
  HRESULT GetMemberName (
    // zero-based index into members in this record type
    [in] aafUInt32  index,

    // buffer into which the member name is written
    [out, size_is(bufSize), string] aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetMemberNameBufLen()
  //
  // Returns the length of buffer required for the GetMemberName()
  // method.  Index is zero-based, and must be less than the value
  // returned by GetCount().  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  // - the integer value is associated with a member of this
  //   enumerated type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the given integer value is not associated with a member of
  //     this type.
  // 
  HRESULT GetMemberNameBufLen (
    // zero-based index into members in this record type
    [in] aafUInt32  index,

    // required buffer length, in bytes
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  // Creates a property value which contains a record type.  The
  // record members in the property value are initialized to
  // contain the given values, passed in the pMemberValues array.
  // numMembers, which indicates the size of the pMemberValues array,
  // must match the value returned by GetCount().  Returns the
  // newly-created property value in ppPropVal.
  //
  // Succeeds if all of the following are true:
  // - the pMemberValues pointer is valid.
  // - the ppPropVal pointer is valid.
  // - numMembers matches the number of members in this record.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pMemberValues or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - numMembers does not match GetCount().
  // 
  HRESULT CreateValueFromValues (
    // array of property values for members of record value which
    // is to be created.
    [in, size_is(numMembers)] IAAFPropertyValue ** pMemberValues,

    // size of pMemberValues array.
    [in] aafUInt32  numMembers,

    // newly-created property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // CreateValueFromStruct()
  //
  // Creates a property value which contains a record type.  The
  // record members in the property value are initialized from data
  // in a struct which is pointed to by pInitData.  Requires that the
  // structure pointed to by pInitData has had its offsets registered
  // with this type.  Returns the newly-created property value in
  // ppPropVal.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppPropVal pointer is valid.
  // - initDataSize indicates pInitData is the correct size.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  // 
  HRESULT CreateValueFromStruct (
    // pointer to compile-time struct containing data to use
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,

    // size of data in pInitData
    [in] aafUInt32  initDataSize,

    // newly created property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetValue()
  //
  // Gets a single property value corresponding to the indicated
  // record member.  Places a property value representing the
  // record member identified by the index into ppOutPropval.
  // Index is zero-based, and must be less than the value returned by
  // GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this record type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The given index is out of range for this record type def.
  // 
  HRESULT GetValue (
    // property value to read
    [in] IAAFPropertyValue * pInPropVal,

    // zero-based index into members in this record type
    [in] aafUInt32  index,

    // value that is read
    [out] IAAFPropertyValue ** ppOutPropVal);


  //***********************************************************
  //
  // GetStruct()
  //
  // Copies all the member data contained in the given property value,
  // interpreted as a record of this type, into the struct pointed
  // to by pData.  Requires that the struct pointed to by pData has
  // had its offsets registered with this type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  // 
  HRESULT GetStruct (
    // property value to read
    [in] IAAFPropertyValue * pPropVal,

    // buffer into which struct data should be written
    [out, size_is(dataSize)] aafMemPtr_t  pData,

    // size of pData buffer in bytes
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // SetValue()
  //
  // Sets the value of the single, indicated record member of the
  // record contained in pPropVal, to the value contained in
  // pMemberPropVal.  Index is zero-based, and must be less than the
  // value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this record type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The given index is out of range for this record type def.
  // 
  HRESULT SetValue (
    // property value to write
    [in] IAAFPropertyValue * pPropVal,

    // zero-based index into members in this record type
    [in] aafUInt32  index,

    // value to be placed into this record
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // SetStruct()
  //
  // Copies all the member data contained in the struct pointed to by
  // pData into the given property value, interpreting the data as a record of
  // this type.  Requires that the struct pointed to by pData has had
  // its offsets registered with this type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData contains the correct amount of data.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - dataSize indicates pData is not the correct size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  // 
  HRESULT SetStruct (
    // property value to write
    [in] IAAFPropertyValue * pPropVal,

    // buffer from which struct data should be read
    [in, size_is(dataSize)] aafMemPtr_t  pData,

    // size of pData buffer in bytes
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of members in this record type.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  // 
  HRESULT GetCount (
    // count of members in this record type
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // RegisterMembers()
  //
  // Allows client to register to the reference implementation a
  // runtime C struct to represent objects of this TypeDef.  Offsets
  // for each member in the struct are passed in as an array of
  // integers; size indicates the number of members in the array.
  // The offset is given in bytes from the start address of the
  // struct.  This allows the reference implementation to write
  // property values into compile-time-defined C structs intelligible
  // by the local machine and compiler.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pOffsets is a valid pointer.
  // - numMembers matches the number of members defined for this
  //   record type.
  // - all types of the fields in this record already have their
  //   offsets registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOffsets arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - numMembers does not match number of members in this record
  //     type.
  //
  // AAFRESULT_NOT_REGISTERED
  //   - The type of any field in this record has not yet had its
  //     offsets registered.
  //
  // AAFRESULT_DEFAULT_ALREADY_USED
  //   - The default registration for this type has already been used
  //     to persist or unpersist a property containing this type.
  // 
  HRESULT RegisterMembers (
    // array containing offset for each record member
    [in] aafUInt32 *  pOffsets,

    // number of members in pOffsets
    [in] aafUInt32  numMembers,

    // size of this struct
    [in] aafUInt32  structSize);
}



// ************************
//
// Interface IAAFTypeDefSet
//
// ************************
//
// This interface is used to define variably-sized set types used in
// AAF persistent objects.
//
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
/***********************************************\
*   Stub only.   Implementation not yet added   *
\***********************************************/


//
// Objects that implement IAAFTypeDefSet also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(381e1f22-e7bb-11d2-842a-00600832acb8),
    helpstring("IAAFTypeDefSet Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefSet : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to contain elements of the given type.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pTypeName is a valid pointer.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeName arg is NULL.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in] aafUID_constref  id,

    // type of each element to be contained in this set
    [in] IAAFTypeDef * pTypeDef,

    // friendly name of this type definition
    [in,string] aafCharacter_constptr  pTypeName);

  //***********************************************************
  //
  // GetElementType()
  //
  // Returns the type of elements in this set.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - ppTypeDef is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  // 
  HRESULT GetElementType (
    // type of elements in this array
    [out] IAAFTypeDef ** ppTypeDef);

  //***********************************************************
  //
  // AddElement()
  //
  // Adds an element to the set, setting it to the
  // value given in pElementPropertyValue.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue pointer is valid.
  // - pElementPropertyValue pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  // 
  HRESULT AddElement (
    // property value corresponding to set to which element is added
    [in] IAAFPropertyValue * pSetPropertyValue,

    // value to be added to this set
    [in] IAAFPropertyValue * pElementPropertyValue);

  //***********************************************************
  //
  // RemoveElement()
  //
  // Removes an element from the set.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue pointer is valid.
  // - pElementPropertyValue pointer is valid.
  // - The given element was in the set.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  // 
  HRESULT RemoveElement (
    // property value corresponding to set from which element is removed
    [in] IAAFPropertyValue * pSetPropertyValue,

    // value to be removed from this set
    [in] IAAFPropertyValue * pElementPropertyValue);

  //***********************************************************
  //
  // ContainsElement()
  //
  // Tests if an element is in the set.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue pointer is valid.
  // - pElementPropertyValue pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  // 
  HRESULT ContainsElement (
    // property value corresponding to set to which element is added
    [in] IAAFPropertyValue * pSetPropertyValue,

    // value whose presence is being tested in this set
    [in] IAAFPropertyValue * pElementPropertyValue,

    // value to be added to this set
    [out] aafBoolean_t*  pContainsElement);


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of elements in the referenced property value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue is a valid pointer.
  // - pCount is a valid pointer.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or pCount arg is NULL.
  // 
  HRESULT GetCount (
    // property value of array
    [in] IAAFPropertyValue * pSetPropertyValue,

    // count of elements in the specified set property value
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // CreateKey()
  //
  // Returns number of elements in the referenced property value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue is a valid pointer.
  // - pCount is a valid pointer.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or pCount arg is NULL.
  // 
  HRESULT CreateKey (
    // Pointer to the key value bytes
    [in,size_is(length)] aafDataBuffer_t  pKeyPtr,

    // The size of the key in bytes
    [in] aafUInt32  length,

    // An interface which may be passed to LookupElement() or ContainsKey()
    [out] IAAFPropertyValue ** ppKey);


  //***********************************************************
  //
  // LookupElement()
  //
  // Looks up the given key (created by CreateKey()) and returns the propertyValue
  // of the entry, or an error if the entry is not present.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue is a valid pointer.
  // - pCount is a valid pointer.
  // - An entry with the correct key is present in the set.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or pSetPropertyValue or ppElementPropertyValue arg is NULL.
  // 
  HRESULT LookupElement (
    // property value of set
    [in] IAAFPropertyValue * pSetPropertyValue,

    // A key returned from CreateKey()
    [in] IAAFPropertyValue * pKey,

    // The returned property value
    [out] IAAFPropertyValue ** ppElementPropertyValue);

  //***********************************************************
  //
  // ContainsKey()
  //
  // Looks up the given key (created by CreateKey()) and returns AAFTrue if the entry
  // is present, or AAFFalse if the entry is not present.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue is a valid pointer.
  // - pCount is a valid pointer.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or pContainsKey arg is NULL.
  // 
  HRESULT ContainsKey (
    // property value of set
    [in] IAAFPropertyValue * pSetPropertyValue,

    // A key returned from CreateKey()
    [in] IAAFPropertyValue * pKey,

    // Value returned is AAFTrue if an entry with the correct key is present
    [out] aafBoolean_t*  pContainsKey);


  //***********************************************************
  //
  // GetElements()
  //
  // Returns an enumerator across elements in this set.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pSetPropertyValue pointer is valid.
  // - The ppEnum pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or ppEnum arg is NULL.
  // 
  HRESULT GetElements (
    // property value to read
    [in] IAAFPropertyValue * pSetPropertyValue,

    // enumerator across property values
    [out] IEnumAAFPropertyValues ** ppEnum);


}



// ************************
//
// Interface IAAFTypeDefStream
//
// ************************
//
// This interface is used to define Stream types used in AAF
// persistent objects.  Streams are conceptually similar to
// variably-sized arrays except that they are intended to be used for
// very large pieces of data (such as essence).
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefStream also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(307e9e6e-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefStream Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefStream : IUnknown
{


cpp_quote("  //")  
cpp_quote("  // All reads/and writes advance the current position") 
cpp_quote("  //") 


cpp_quote("  //") 
cpp_quote("  // Raw byte stream access") 
cpp_quote("  //") 


cpp_quote("  // Stream size and positioning") 

  //***********************************************************
  //
  // GetSize()
  //
  // Returns number of bytes contained in the referenced property
  // value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - pSize is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pSize arg is NULL.
  // 
  HRESULT GetSize (
    // stream property value
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // count of bytes in the specified stream property value
    [out] aafInt64 *  pSize);

  //***********************************************************
  //
  // SetSize()
  //
  // Set the number of bytes contained in the give stream property value
  // to newElementCount
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - If pStreamPropertyValue arg is NULL.
  // 
  HRESULT SetSize (
    // stream property value
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // new count of bytes in the specified stream property value
    [in] aafInt64  newSize);

  //***********************************************************
  //
  // GetPosition()
  //
  // Returns the byte position of the current element in the stream. 
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - pPosition is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pPosition arg is NULL.
  // 
  HRESULT GetPosition (
    // stream property value
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // current byte position in the specified stream property value
    [out] aafInt64 *  pPosition);

  //***********************************************************
  //
  // SetPosition()
  //
  // Make the current byte position to the one at newPosition in the stream 
  // property value. 
  //
  // Succeeds if:
  // - pStreamPropertyValue is a valid pointer.
  // - the new position is valid
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - If pStreamPropertyValue arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - newPosition is outside the bounds of the stream.
  // 
  HRESULT SetPosition (
    // stream property value
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // the new position in the specified stream property value
    [in] aafInt64  newPosition);


cpp_quote("  // Sequential access") 

  //***********************************************************
  //
  // Read()
  //
  // Copies the data at the position of the stream to the given
  // buffer.
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pData pointer is valid.
  // - the indicated bytes exist in the stream.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pData arg is NULL.
  // 
  HRESULT Read (
    // stream property value to read
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // number of bytes to read
    [in] aafUInt32  dataSize,

    // buffer into which one element from the stream should be written
    [out, size_is(dataSize), length_is(*bytesRead)] aafMemPtr_t  pData,

    // number of bytes actually read (will be either dataSize or 0 if there 
    // is in error)
    [out,ref] aafUInt32 *  bytesRead);

  //***********************************************************
  //
  // Write()
  //
  // Copies the data in the given buffer into the stream at the 
  // current position of the stream..
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pData pointer is valid.
  // - the indicated bytes could be written to the stream.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pData arg is NULL.
  // 
  HRESULT Write (
    // stream property value to modify
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // number of bytes to write
    [in] aafUInt32  dataSize,

    // buffer into which should contain one element to be written to the stream
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


cpp_quote("  // Extending the stream") 

  //***********************************************************
  //
  // Append()
  //
  // Copies the data in the given buffer into the stream at the 
  // end of the stream.
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pData pointer is valid.
  // - the indicated bytes could be appended to the stream.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pData arg is NULL.
  // 
  HRESULT Append (
    // stream property value to modify
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // number of bytes to write (must be equal to the element type length)
    [in] aafUInt32  dataSize,

    // buffer into which should contain one element to be written to the stream
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


cpp_quote("  //") 
cpp_quote("  // Access byte order of the stream") 
cpp_quote("  //") 


  //***********************************************************
  //
  // HasStoredByteOrder()
  //
  // Returns kAAFTrue if the stream has a stored byte order or 
  // kAAFFalse otherwise.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - pHasByteOrder is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pHasByteOrder arg is NULL.
  // 
  HRESULT HasStoredByteOrder (
    // stream property value
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // kAAFTrue if this stream has a stored byte order
    [out] aafBoolean_t *  pHasByteOrder);

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  // Returns kAAFTrue if the stream has a stored byte order or 
  // kAAFFalse otherwise.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - pHasByteOrder is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pByteOrder arg is NULL.
  // 
  HRESULT GetStoredByteOrder (
    // stream property value
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // Pointer to variable where byte order is to be copied
    [out] eAAFByteOrder_t *  pByteOrder);

  //***********************************************************
  //
  // SetStoredByteOrder()
  //
  // Sets the byte order to be associated with this stream. Note: the stream
  // must be empty.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - stream is empty.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - If pStreamPropertyValue arg is NULL.
  // 
  HRESULT SetStoredByteOrder (
    // stream property value
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // byte order is to be stored with the stream
    [in] eAAFByteOrder_t  byteOrder);

  //***********************************************************
  //
  // ClearStoredByteOrder()
  //
  // Clears the byte order to be associated with this stream. Note: the stream
  // must be empty.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - stream is empty.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - If pStreamPropertyValue arg is NULL.
  // 
  HRESULT ClearStoredByteOrder (
    // stream property value
    [in] IAAFPropertyValue * pStreamPropertyValue);


cpp_quote("  //") 
cpp_quote("  // Access in typed chunks of Elements") 
cpp_quote("  //") 

  //***********************************************************
  //
  // ReadElements()
  //
  // Copies the data at the current position of the stream to the given
  // buffer. Requires that any structures declared within element 
  // typedef have had their offsets registered with that type.
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pElementType pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  // - the indicated elements exist in this stream type def.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pElementType or pBytesRead or pData arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for element typedef.
  //
  // AAFRESULT_INVALID_PARAM
  //   - there are not dataSize bytes left in the stream.
  // 
  HRESULT ReadElements (
    // stream property value to read
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // the type definition of the elements to read
    [in] IAAFTypeDef * pElementType,

    // number of bytes to read (must be evenly divisible by the element 
    // type length)
    [in] aafUInt32  dataSize,

    // buffer into which elements from the stream should be written
    [out, size_is(dataSize), length_is(*pBytesRead)] aafMemPtr_t  pData,

    // number of bytes actually read (will be either dataSize or 0 if 
    // there is in error)
    [out,ref] aafUInt32 *  pBytesRead);

  //***********************************************************
  //
  // WriteElements()
  //
  // Copies the data in the given buffer into the stream at the  
  // current position of the stream. Requires that any structures 
  // declared within element 
  // typedef have had their offsets registered with that type..
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pElementType pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  // - the indicated elements exist in this stream type def.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - dataSize indicates pData is an even multiple of the given 
  //     element type size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for the element typedef.
  // 
  HRESULT WriteElements (
    // stream property value to modify
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // the type definition of the elements to read
    [in] IAAFTypeDef * pElementType,

    // number of bytes to write (must be evenly divisible by the element type 
    // length)
    [in] aafUInt32  dataSize,

    // buffer into which elements from the stream should be written
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


cpp_quote("  // Extend in chunks of typed Elements") 

  //***********************************************************
  //
  // AppendElements()
  //
  // Copies the data in the given buffer onto the end of the stream. 
  // Requires that any structures declared within element 
  // typedef have had their offsets registered with that type..
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pElementType pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  // - the indicated elements exist in this stream type def.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - dataSize indicates pData is an even multiple of the given 
  //     element type size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for the element typedef.
  // 
  HRESULT AppendElements (
    // stream property value to modify
    [in] IAAFPropertyValue * pStreamPropertyValue,

    // the type definition of the elements to read
    [in] IAAFTypeDef * pElementType,

    // number of bytes to write (must be evenly divisible by the element type 
    // length)
    [in] aafUInt32  dataSize,

    // buffer into which elements from the stream should be written
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);

}



// ************************
//
// Interface IAAFTypeDefString
//
// ************************
//
// This interface is used to define variably-sized Array types whose
// length is determined by a special terminator element value.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefString also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(307e9e68-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefString Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefString : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to contain elements of the given type.
  // Note that it is only possible to use certain types as the element
  // type.  Those permissible types include:
  // - AAFTypeDefInt
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pTypeDef is a valid pointer.
  // - pTypeName is a valid pointer.
  // - element type is permissible for use in a String.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pTypeDef or pTypeName arg is NULL.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // type of each element to be contained in this array
    [in] IAAFTypeDef * pTypeDef,

    // friendly name of this type definition
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetType()
  //
  // Returns the type of elements in this string.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - ppTypeDef is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  // 
  HRESULT GetType (
    // type of elements in this array
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of elements contained in the referenced property
  // value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pPropVal is a valid pointer.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pPropVal or pCount arg is NULL.
  // 
  HRESULT GetCount (
    // property value of array
    [in] IAAFPropertyValue * pPropVal,

    // count of elements in the specified string property value
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // CreateValueFromCString()
  //
  // Creates a property value which contains a string type.  The
  // string in the property value are initialized from data in a C
  // string which is pointed to by pInitData.  Returns the
  // newly-created property value in ppPropVal.  The size of the
  // newly-created string property value will be determined by the
  // size of the initialization C array, as communicated by
  // initDataSize.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppPropVal arg is NULL.
  // 
  HRESULT CreateValueFromCString (
    // pointer to compile-time C string containing data to use
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,

    // size of data in pInitData, in bytes
    [in] aafUInt32  initDataSize,

    // newly created property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // SetCString()
  //
  // Copies all the string data contained in the C array pointed to by
  // pData into the given property value, interpreting the data as a
  // string of this type.  If dataSize indicates an array size
  // different from the size currently in the indicated array property
  // value, that array property value will be resized.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  // 
  HRESULT SetCString (
    // property value to write
    [in] IAAFPropertyValue * pPropVal,

    // buffer from which C string data should be read
    [in, size_is(dataSize)] aafMemPtr_t  pData,

    // size of pData buffer in bytes
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // AppendElements()
  //
  // Appends elements to the end of the array, setting them to the
  // values given in the pElements array.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pInPropVal pointer is valid.
  // - pElements pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or pElements arg is NULL.
  // 
  HRESULT AppendElements (
    // property value corresponding to string to which elements are to
    // be appended
    [in] IAAFPropertyValue * pInPropVal,

    // Null-terminated array of elements to be appended
    [in] aafMemPtr_t  pElements);


  //***********************************************************
  //
  // GetElements()
  //
  // Gets the value of this property as a string and places it into
  // pBuffer.  bufferSize indicates the size of the buffer, in bytes.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pInPropVal pointer is valid.
  // - bufferSize indicates that pBuffer is large enough to hold the
  //   data.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInPropVal arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufferSize indicates that pBuffer is too small to hold the
  //     data.
  // 
  HRESULT GetElements (
    // property value to read
    [in] IAAFPropertyValue * pInPropVal,

    // array of values that are read
    [out] aafMemPtr_t  pBuffer,

    // size of pBuffer, in bytes
    [in] aafUInt32  bufferSize);


}



// ************************
//
// Interface IAAFTypeDefStrongObjRef
//
// ************************
//
// This interface is used to implement Strong Object references.
//
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefStrongObjRef also implement the following interfaces:
//  - IAAFTypeDefObjectRef
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(381e1f26-e7bb-11d2-842a-00600832acb8),
    helpstring("IAAFTypeDefStrongObjRef Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefStrongObjRef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be a reference to objects of
  // the given type, and assigns this object the given AUID.  pObjType
  // points to the class definition of the least-derived class which
  // is possible to be contained in property values of this type.
  // 
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pObjType is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pObjType or pTypeName arg is NULL.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // class def of objects permitted to be referenced
    [in] IAAFClassDef * pObjType,

    // friendly name of this type definition
    [in, string] aafCharacter_constptr  pTypeName);


}



// ************************
//
// Interface IAAFTypeDefWeakObjRef
//
// ************************
//
// This interface is used to implement Weak Object references.
//
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
/***********************************************\
*   Stub only.   Implementation not yet added   *
\***********************************************/


//
// Objects that implement IAAFTypeDefWeakObjRef also implement the following interfaces:
//  - IAAFTypeDefObjectRef
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(381e1f24-e7bb-11d2-842a-00600832acb8),
    helpstring("IAAFTypeDefWeakObjRef Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefWeakObjRef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be a reference to objects of
  // the given type, and assigns this object the given AUID.  pObjType
  // points to the class definition of the least-derived class which
  // is possible to be contained in property values of this type.
  // 
  // pTargetSet points to an array of Property Def AUIDs which
  // indicate the location of the property containing the target of
  // this weak reference.  The AUIDs indicate the containment path to
  // the target property, starting at the root Header object.  For
  // example, if the containment hierarchy is:
  // Header->A->B->C
  // then the first AUID corresponds to the Header's property which
  // contains Object A; the second AUID corresponds to Object A's
  // property which contains Object B; and the third AUID corresponds
  // to Object B's property C which contans the target of this weak
  // reference.  If any intermediate property is a vector or set,
  // *all* objects in that vector or set are searched for the target.
  // Note that the final AUID *must* correspond to a Set property.
  // 
  // The number of AUIDs in pTargetSet is noted by ids.
  // 
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pObjType is a valid pointer.
  // - pTargetSet is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pObjType, pTypeName, or pTargetSet arg is NULL.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // class def of objects permitted to be referenced
    [in] IAAFClassDef * pObjType,

    // friendly name of this type definition
    [in, string] aafCharacter_constptr  pTypeName,

    // Number of property def IDs in pTargetSet
    [in] aafUInt32  ids,

    // List of property definition IDs indicating the property where
    // the target is to be found.
    [in, size_is(ids)] aafUID_constptr  pTargetSet);
}



// ************************
//
// Interface IAAFTypeDefObjectRef
//
// ************************
//
// This interface is used to define Object references (either strong
// or weak) used in AAF persistent objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefObjectRef also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(c3274644-9467-11d2-841f-00600832acb8),
    helpstring("IAAFTypeDefObjectRef Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefObjectRef : IUnknown
{


  //***********************************************************
  //
  // GetObjectType()
  //
  // Returns the class def representing objects to which this type def
  // can refer.  The returned type def is the class definition of the
  // least-derived type which is permissible to be represented.
  //
  // Succeeds if:
  // - this object has been Initialize()d.
  // - The ppObjType pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppObjType arg is NULL.
  // 
  HRESULT GetObjectType (
    // class def of objects permitted to be referenced
    [out] IAAFClassDef ** ppObjType);

  //***********************************************************
  //
  // CreateValue()
  //
  // Creates a property value which contains an object reference.
  // Initializes it to refer to the given object, and returns the
  // newly-created property value in ppPropVal.
  //
  // Succeeds if:
  // - The pObj pointer is valid.
  // - The ppPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pObj or ppPropVal arg is NULL.
  // 
  HRESULT CreateValue (
    // object with which to initialize this object reference
    [in] IUnknown * pObj,

    // newly created property value
    [out] IAAFPropertyValue ** ppPropVal);

  //***********************************************************
  //
  // GetObject()
  //
  // Returns the object contained in the named property value.
  // Requires that pPropVal be a strong object reference or a weak
  // object reference.
  //
  // Succeeds if:
  // - The pPropVal pointer is valid.
  // - The ppObject pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or ppObject arg is NULL.
  // 
  HRESULT GetObject (
    // property value from which value is to be read
    [in] IAAFPropertyValue * pPropVal,

    // interface id of the required output
    [in] REFIID  iid,

    // pointer to object value
    [out, iid_is(iid)] IUnknown ** ppObject);


  //***********************************************************
  //
  // SetObject()
  //
  // Sets the named property value to refer to the named object.
  // Requires that pPropVal be a strong object reference or a weak
  // object reference.
  //
  // Succeeds if:
  // - The pPropVal pointer is valid.
  // - The ppObject pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or ppObject arg is NULL.
  // 
  HRESULT SetObject (
    // property value from which value is to be read
    [in] IAAFPropertyValue * pPropVal,

    // pointer to object value
    [in] IUnknown * pObject);


}



// ************************
//
// Interface IAAFTypeDefOpaque
//
// ************************
//
// This interface is used to define Integer types used in AAF persistent
// objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefOpaque also implement the following interfaces:
//  - IAAFTypeDefIndirect
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(FE717CAC-F04C-11d3-800B-00104BC9156D),
    helpstring("IAAFTypeDefOpaque Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefOpaque : IUnknown
{


  //***********************************************************
  //
  // GetActualTypeID()
  //
  // Return the type id of the  actual data within the opaque property value.
  //
  //
  // Succeeds if all of the following are true:
  // - the pOpaquePropertyValue pointer is valid.
  // - the pActualType pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pOpaquePropertyValue or pActualTypeID arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the type of pOpaquePropertyValue was not opaque. 
  //
  // 
  HRESULT GetActualTypeID (
    // indirect property value to read
    [in] IAAFPropertyValue * pOpaquePropertyValue,

    // the type id of the actual data
    [out] aafUID_t *  pActualTypeID);

  //***********************************************************
  //
  // GetHandle()
  //
  // Used to read and save an unknown property without having to know its contents.
  // This call fills in a handle to a block of data which can be saved in you application, and
  // later written to another file using SetHandle().  Writes the data into the pHandle buffer. 
  // The buffer is allocated by the caller, and the size of the buffer is given by
  // handleSize.
  // 
  // Caller may call GetHandleBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pHandle pointer is valid.
  // - handleSize indicates the buffer is large enough to hold the
  //   name.
  // 
  // If this method fails nothing will be written to *pHandle.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pHandle arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - handleSize indicates the buffer is too small to hold the
  //     handle.
  // 
  HRESULT GetHandle (
    // value to get data from.
    [in] IAAFPropertyValue * pPropVal,

    // Size of preallocated buffer
    [in] aafUInt32  handleSize,

    // Preallocated buffer to hold handle
    [out, size_is(handleSize),length_is(*bytesRead)] aafDataBuffer_t  pHandle,

    // Number of actual bytes read
    [out] aafUInt32*  bytesRead);


  //***********************************************************
  //
  // GetHandleBufLen()
  //
  // Returns the length of buffer required for the GetHandle()
  // method.  The handle is placed into the location specified by
  // pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  // 
  HRESULT GetHandleBufLen (
    // value to set.
    [in] IAAFPropertyValue * pPropVal,

    // Pointer to an variable used to return the length
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // SetHandle()
  //
  // This call takes a block of unknown data created by a previous call to GetHandle()
  // and saved in you application, and sets an opaque property value.
  //
  // Succeeds if all of the following are true:
  // - the pHandle pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pHandle is null.
  // 
  HRESULT SetHandle (
    // value to write data to.
    [in] IAAFPropertyValue * pPropVal,

    // Size of preallocated buffer
    [in] aafUInt32  handleSize,

    // buffer containing handle
    [in, size_is(handleSize)] aafDataBuffer_t  pHandle);

  //***********************************************************
  //
  // CreateValueFromHandle()
  //
  // This call takes a block of unknown data created by GetHandle()
  // and saved in you application, and creates an opaque property value.
  // Returns the newly-created property value in ppOpaquePropertyValue.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppOpaquePropertyValue pointer is valid.
  // - initDataSize indicates pInitData is the correct size for 
  //   the actual type.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppOpaquePropertyValue.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppOpaquePropertyValue arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  // 
  HRESULT CreateValueFromHandle (
    // pointer to buffer containing handle to use
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,

    // size of handle in pInitData
    [in] aafUInt32  initDataSize,

    // newly created property value
    [out] IAAFPropertyValue ** ppOpaquePropertyValue);


}



// ************************
//
// Interface IAAFTypeDefVariableArray
//
// ************************
//
// This interface is used to define variably-sized Array types used in
// AAF persistent objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefVariableArray also implement the following interfaces:
//  - IAAFTypeDefVariableArrayEx
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(307e9e66-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefVariableArray Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefVariableArray : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to contain elements of the given type.
  // Note that it is only possible to use certain types as the element
  // type.  Those permissible types include:
  // - AAFTypeDefInt
  // - AAFTypeDefRecord
  // - AAFTypeDefEnum
  // - AAFTypeDefExtEnum
  // - AAFTypeDefFixedArray
  // - AAFTypeDefObjectRef
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pTypeDef is a valid pointer.
  // - pTypeName is a valid pointer.
  // - element type is permissible for use in a VariableArray.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pTypeDef or pTypeName arg is NULL.
  //
  // AAFRESULT_BAD_TYPE
  //   - an illegal element type was given.
  // 
  HRESULT Initialize (
    // auid to be used to identify this type
    [in, ref] aafUID_constref  id,

    // type of each element to be contained in this array
    [in] IAAFTypeDef * pTypeDef,

    // friendly name of this type definition
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetType()
  //
  // Returns the type of elements in this array.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - ppTypeDef is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  // 
  HRESULT GetType (
    // type of elements in this array
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of array elements in the referenced property
  // value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pPropVal is a valid pointer.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pPropVal or pCount arg is NULL.
  // 
  HRESULT GetCount (
    // property value of array
    [in] IAAFPropertyValue * pPropVal,

    // count of elements in the specified array property value
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // AppendElement()
  //
  // Appends an element to the end of the array, setting it to the
  // value given in pMemberPropVal.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pInPropVal pointer is valid.
  // - pMemberPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or pMemberPropVal arg is NULL.
  // 
  HRESULT AppendElement (
    // property value corresponding to array to which element is appended
    [in] IAAFPropertyValue * pInPropVal,

    // value to be appended to this array
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // CreateEmptyValue()
  //
  // Creates an empty property value which contains a variable array
  // type that initially is empty (that is, contains no elements
  // yet).
  //
  // Succeeds if all of the following are true:
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropVal arg is NULL.
  // 
  HRESULT CreateEmptyValue (
    // newly-created empty property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  // Creates a property value which contains a variable array type.
  // The array elements in the property value are initialized to
  // contain the given values, passed in the pElementValues array.
  // numElements, which indicates the size of the pElementValues
  // array, determines the size of the array in the new array
  // property value.
  //
  // Succeeds if all of the following are true:
  // - the pElementValues pointer is valid.
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pElementValues or ppPropVal arg is NULL.
  // 
  HRESULT CreateValueFromValues (
    // array of property values for elements of array value which
    // is to be created.
    [in, size_is(numElements)] IAAFPropertyValue ** pElementValues,

    // size of pElementValues array.
    [in] aafUInt32  numElements,

    // newly-created property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // CreateValueFromCArray()
  //
  // Creates a property value which contains a fixed array type.  The
  // array elements in the property value are initialized from data in
  // a C array which is pointed to by pInitData.  Requires that any
  // structures declared within this array typedef have had their
  // offsets registered with that type.  Returns the newly-created
  // property value in ppPropVal.  The size of the newly-created array
  // property value will be determined by the number of elements in
  // the initialization C array, as communicated by initDataSize.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppPropVal pointer is valid.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppPropVal arg is NULL.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - any contained struct offsets have not yet been registered for
  //    that typedef.
  // 
  HRESULT CreateValueFromCArray (
    // pointer to compile-time C array containing data to use
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,

    // size of data in pInitData, in bytes
    [in] aafUInt32  initDataSize,

    // newly created property value
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetElementValue()
  //
  // Gets a single property value corresponding to the indexed array
  // element.  Places a property value representing the array element
  // identified by the index into ppOutPropval.  Index is zero-based,
  // and must be less than the value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given index is out of range for this array type def.
  // 
  HRESULT GetElementValue (
    // property value to read
    [in] IAAFPropertyValue * pInPropVal,

    // zero-based index into elements in this array type
    [in] aafUInt32  index,

    // value that is read
    [out] IAAFPropertyValue ** ppOutPropVal);


  //***********************************************************
  //
  // GetCArray()
  //
  // Copies all the array data contained in the given property value,
  // interpreted as a fixed array of this type, into the C array
  // pointed to by pData.  Requires that any structures declared
  // within this array typedef have had their offsets registered with
  // that type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  // 
  HRESULT GetCArray (
    // property value to read
    [in] IAAFPropertyValue * pPropVal,

    // buffer into which C array data should be written
    [out, size_is(dataSize)] aafMemPtr_t  pData,

    // size of pData buffer in bytes
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // SetElementValue()
  //
  // Sets the value of the single, indicated element of the fixed
  // array contained in pPropVal, to the value contained in
  // pMemberPropVal.  Index is zero-based, and must be less than the
  // value returned by GetCount().  Property value must be of the
  // same type as returned by GetType().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given index is out of range for this array type def.
  // 
  HRESULT SetElementValue (
    // property value to write
    [in] IAAFPropertyValue * pPropVal,

    // zero-based index into members in this array type
    [in] aafUInt32  index,

    // value to be placed into this array
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // SetCArray()
  //
  // Copies all the array data contained in the C array pointed to by
  // pData into the given property value, interpreting the data as a
  // fixed array of this type.  Requires that any structures declared
  // within this typedef have had their offsets registered with that
  // type.  If dataSize indicates an array size different from the
  // size currently in the indicated array property value, that array
  // property value will be resized.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - any contained compile-time struct has had its member offests
  //   registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - offsets of any contained struct have not yet been registered.
  // 
  HRESULT SetCArray (
    // property value to write
    [in] IAAFPropertyValue * pPropVal,

    // buffer from which C array data should be read
    [in, size_is(dataSize)] aafMemPtr_t  pData,

    // size of pData buffer in bytes
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // GetElements()
  //
  // Returns an enumerator across elements in this set.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The PSetPropVal pointer is valid.
  // - The ppEnum pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either PSetPropVal or ppEnum arg is NULL.
  // 
  HRESULT GetElements (
    // property value to read
    [in] IAAFPropertyValue * PSetPropVal,

    // enumerator across property values
    [out] IEnumAAFPropertyValues ** ppEnum);


}


// ************************
//
// Interface IAAFVaryingValue
//
// ************************
//
// The IAAFVaryingValue interface is implemented by objects that
// specify a parameter whose value changes during the operation group.
// The actual values are stored in one or more IAAFControlPoints.  For
// parameters which are constant in value during the operation group,
// use IAAFConstantValue.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFVaryingValue also implement the following interfaces:
//  - IAAFParameter
//  - IAAFObject

[
    object,
    uuid(91920d60-2a2e-11D2-bfA3-006097116212),
    helpstring("IAAFVaryingValue Interface"),
    pointer_default(unique)
]
interface IAAFVaryingValue : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new varying value object to be identified with the
  // given the given parameter definition and interpolation definition.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pParameterDef and pInterpolation are a valid pointers.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pParameterDef or pInterpolation arg is NULL.
  // 
  // 
  HRESULT Initialize (
    // Parameter definition for this object (this determines the type of the varying value)
    [in] IAAFParameterDef * pParameterDef,

    // InterpolationDefinition object
    [in] IAAFInterpolationDef * pInterpolation);

  //***********************************************************
  //
  // AddControlPoint()
  //
  // Adds a control point to the AAFVaryingValue object.
  // The point will be sorted by time order, not the order in which
  // the points were added.
  // 
  // Succeeds if all of the following are true:
  // - the pControlPoint pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pControlPoint is null.
  // 
  HRESULT AddControlPoint (
    // pointer to IAAFControlPoint object
    [in] IAAFControlPoint * pControlPoint);


  //***********************************************************
  //
  // GetControlPoints()
  //
  // Return an enumerator for the list of IAAFControlPoints.  The list
  // will be returned in time order, not the order in which the
  // points were added.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT GetControlPoints (
    // Parameter definition enumeration
    [out,retval] IEnumAAFControlPoints ** ppEnum);


  //***********************************************************
  //
  // CountControlPoints()
  //
  // This function returns the number of control points in the sequence.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  // 
  HRESULT CountControlPoints (
    // Number of control points
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetControlPointAt()
  //
  // This function retrieves the input control point at the given index in
  // the given sequence.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppControlPoint pointer is valid.
  // - index is less than the value returned by
  //   CountControlPoints().
  // 
  // If this method fails nothing will be written to *ppControlPoint.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pControlPoint is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountControlPoints().
  // 
  HRESULT GetControlPointAt (
    // index of control point to retrieve
    [in] aafUInt32  index,

    // Retrieved control point
    [out, retval] IAAFControlPoint ** ppControlPoint);


  //***********************************************************
  //
  // RemoveControlPointAt()
  //
  // This function removes the input control point at the given index in
  // the given sequence.  Control points already existing at indices
  // higher than the given index will be moved to the next lower index
  // to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - index is less than the value returned by
  //   CountControlPoints().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountControlPoints().
  // 
  HRESULT RemoveControlPointAt (
    // index of control point to remove
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetInterpolationDefinition()
  //
  // Places the InterpolationDefinition object attached to this
  // VaryingValue into the *ppInterpolation argument.  If none exists
  // yet, NULL is placed into the *ppInterpolation argument.
  //
  // The returned InterpolationDefinition object, if it exists, is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppInterpolation pointer is valid.
  // - A valid InterpolationDefinition exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppInterpolation is null.
  // 
  HRESULT GetInterpolationDefinition (
    // Returned InterpolationDefinition object
    [out] IAAFInterpolationDef ** ppInterpolation);

  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the
  // GetInterpolatedValue() method.  The value is placed into the
  // location specified by pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  // 
  HRESULT GetValueBufLen (
    // Mob Name
    [out] aafInt32 *  pLen);


  //***********************************************************
  //
  // GetInterpolatedValue()
  //
  // Writes the interpolated value of the IAAFVaryingValue at a given
  // position into the pValue buffer.  The buffer is allocated by the
  // caller, and the size of the buffer is given by valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  // 
  HRESULT GetInterpolatedValue (
    // Position along the operation group
    [in] aafRational_t  inputValue,

    // Size of preallocated buffer
    [in] aafInt32  valueSize,

    // Preallocated buffer to hold value
    [out,
		   size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  pValue,

    // Number of actual bytes read
    [out] aafInt32 *  bytesRead);
}



// ************************
//
// Interface IAAFWAVEDescriptor
//
// ************************
//
// The IAAFWaveDescriptor interface is implemented by objects which
// describe audio content data formatted according to the RIFF
// Waveform Audio File Format (WAVE).
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFWAVEDescriptor also implement the following interfaces:
//  - IAAFFileDescriptor
//  - IAAFEssenceDescriptor
//  - IAAFObject

[
    object,
    uuid(4c2e1692-8ae6-11d2-813c-006097310172),
    helpstring("IAAFWAVEDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFWAVEDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFWaveDescriptor-supporting object.  This method must be
  // called after allocation, and before any other method can be
  // called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  // 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetSummary()
  //
  // Gets a copy of the WAVE file information without the media.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer.
  // - The size of the buffer is large enough to hold the WAVE file
  //   information.
  // 
  // If this method fails pSummary will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - The buffer is too small to hold the WAVE file information.
  // 
  HRESULT GetSummary (
    // Size of preallocated buffer
    [in] aafUInt32  size,

    // Preallocated buffer to hold the WAVE file information
    [out, size_is(size)] aafDataValue_t  pSummary);


  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  // Returns the size of the buffer required for the GetSummary()
  // method.  The value is placed into the location specified by pSize.
  //
  // Succeeds if all of the following are true:
  // - the pSize pointer is valid.
  //
  // If this method fails nothing will be written to *pSize.
  //
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  // 
  HRESULT GetSummaryBufferSize (
    // required buffer size
    [out] aafUInt32 *  pSize);


  //***********************************************************
  //
  // SetSummary()
  //
  // Sets the WAVE file information.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer
  // 
  // If this method fails the summary property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  // 
  HRESULT SetSummary (
    // Size of preallocated buffer
    [in] aafUInt32  size,

    // buffer containing value
    [in, size_is(size)] aafDataValue_t  pSummary);


}



// ************************
//
// Interface IEnumAAFClassDefs
//
// ************************
//
// This interface is used to enumerate across Class Definition
// objects.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
/***********************************************\
*   Stub only.   Implementation not yet added   *
\***********************************************/
//


[
    object,
    uuid(B1A2138E-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFClassDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFClassDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppClassDefs pointer is valid.
  // - there are Class Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppClassDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppClassDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Class Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Class Definition
    [out,retval] IAAFClassDef ** ppClassDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFClassDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppClassDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Class Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppClassDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppClassDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of ClassDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFClassDef ** ppClassDefs,

    // number of actual Class Definition objects fetched into ppClassDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFClassDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFCodecDefs
//
// ************************


[
    object,
    uuid(3B2C9AD4-022A-11d3-80A6-006008143E6F),
    helpstring("IEnumAAFCodecDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFCodecDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppCodecDefs pointer is valid.
  // - there are Codec Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppCodecDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppCodecDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Codec Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Codec Definition
    [out,retval] IAAFCodecDef ** ppCodecDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFCodecDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppCodecDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Codec Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppCodecDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppCodecDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of CodecDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFCodecDef ** ppCodecDefs,

    // number of actual Codec Definition objects fetched into ppCodecDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFCodecDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFCodecFlavours
//
// ************************
//
// An object which allows iteration over all of the flavour codes
// which a given codec is able to handle.
//
// Flavours are used when a single codec can support multiple formats.
// An Example would be a codec which would accept a "resolution ID"
// for a particular manufacturer and set up all of the parameters.
// When a new resolution ID is released, then a new codec plugin
// would give users the ability to use the new resolutions without
// upgrading the application.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(AB4D9F12-DD69-11d2-809C-006008143E6F),
    helpstring("IEnumAAFCodecFlavours Interface"),
    pointer_default(unique)
]
interface IEnumAAFCodecFlavours : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for passing in a pointer to an aafUID_t,
  // and retains control over the pointer.
  //
  // This is a just simplified version of the Next method. 
  // 
  HRESULT NextOne (
    // The Next flavour code
    [out,retval] aafUID_t *  pAAFCodecFlavour);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (codec flavour IDs) in
  // the enumerator's list, returning them in the given array along
  // with the actual number of enumerated elements in pFetched. The
  // caller is responsible for passing in a pointer to an array of
  // aafUID_t, and retains control over the pointer.
  // 
  HRESULT Next (
    // number of AAFPluggableDefs requested
    [in] aafUInt32  count,

    // array to receive flavour codes
    [out, size_is(count), length_is(*pFetched)] aafUID_t *  pAAFCodecFlavours,

    // number of actual flavour IDs fetched into pAAFCodecFlavours array
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFCodecFlavours::Next
  // will not return those elements.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // There is no guarantee that the same set of elements will be
  // enumerated on each pass through the list, nor will the elements
  // necessarily be enumerated in the same order. The exact behavior
  // depends on the collection being enumerated.
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another EnumAAFCodecFlavours enumerator with the same
  // state as the current enumerator to iterate over the same
  // list.  This method makes it possible to record a point in the
  // enumeration sequence in order to return to that point at a later
  // time.
  // 
  // The caller must release this new enumerator separately from the
  // first enumerator.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFCodecFlavours ** ppEnum);
}



// ************************
//
// Interface IEnumAAFComponents
//
// ************************
//
// This interface is used to enumerate over the AAFComponents contained
// in an AAFSequence.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(B1A21394-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFComponents Interface"),
    pointer_default(unique)
]
interface IEnumAAFComponents : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppComponent pointer is valid.
  // - there are Component objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppComponent.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppComponent is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Components remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Component
    [out,retval] IAAFComponent ** ppComponent);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFComponent pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppComponents pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  // - There are Component objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppComponents or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppComponents or pNumFetched is null.
  // 
  HRESULT Next (
    // number of components requested
    [in] aafUInt32  count,

    // array to receive components
    [out, size_is(count), length_is(*pNumFetched)] IAAFComponent ** ppComponents,

    // number of actual Components fetched into ppComponents array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another component enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFComponents ** ppEnum);
}



// ************************
//
// Interface IEnumAAFContainerDefs
//
// ************************


[
    object,
    uuid(3B2C9AD2-022A-11d3-80A6-006008143E6F),
    helpstring("IEnumAAFContainerDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFContainerDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppContainerDefs pointer is valid.
  // - there are Container Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppContainerDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppContainerDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Container Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Container Definition
    [out,retval] IAAFContainerDef ** ppContainerDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFContainerDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppContainerDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Container Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppContainerDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppContainerDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of ContainerDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFContainerDef ** ppContainerDefs,

    // number of actual Container Definition objects fetched into ppContainerDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFContainerDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFControlPoints
//
// ************************


[
    object,
    uuid(B1A2139C-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFControlPoints Interface"),
    pointer_default(unique)
]
interface IEnumAAFControlPoints : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppControlPoints pointer is valid.
  // - there are Control Point objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppControlPoints.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppControlPoints arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Control Point objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Control Point
    [out,retval] IAAFControlPoint ** ppControlPoints);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFControlPoint pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppControlPoints pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Control Point objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppControlPoints or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppControlPoints or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of ControlPoints requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFControlPoint ** ppControlPoints,

    // number of actual Control Point objects fetched into ppControlPoints array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFControlPoints ** ppEnum);
}



// ************************
//
// Interface IEnumAAFDataDefs
//
// ************************


[
    object,
    uuid(d8000382-498e-11d2-841B-00600832ACB8),
    helpstring("IEnumAAFDataDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFDataDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppDataDefs pointer is valid.
  // - there are Data Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppDataDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDataDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Data Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Data Definition
    [out,retval] IAAFDataDef ** ppDataDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFDataDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppDataDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Data Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppDataDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppDataDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of DataDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFDataDef ** ppDataDefs,

    // number of actual Data Definition objects fetched into ppDataDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFDataDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFIdentifications
//
// ************************
//
// This interfaces allows access to individual
// IAAFIdentification-supporting objects within a collection.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(B1A21384-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFIdentifications Interface"),
    pointer_default(unique)
]
interface IEnumAAFIdentifications : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed. 
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentification pointer is valid.
  // - there are Identification objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppIdentification.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppIdentification is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Identifications remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Identification
    [out, retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // Next()
  //
  // // Enumerates the next count elements (AAFIdentification pointers)
  // in the enumerator's list, returning them in the given array
  // along with the actual number of enumerated elements in
  // pNumFetched. The caller is responsible for properly releasing the
  // returned pointers when thery are no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentifications pointer is valid.
  // - the pNumFetched pointer is valid.
  // - there are Identification objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppIdentifications or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppIdentification or pNumFetched is null.
  // 
  HRESULT Next (
    // number of identifications requested
    [in] aafUInt32  count,

    // array to receive identification objects
    [out, size_is(count), length_is(*pNumFetched)] IAAFIdentification ** ppIdentifications,

    // number of actual Identifications fetched into ppIdentifications array
    [out] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFIdentifications::Next
  // will not return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // // Creates another identification enumerator with the same state as
  // the current enumerator to iterate over the same list. This method
  // makes it possible to record a point in the enumeration sequence
  // in order to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT Clone (
    // new enumeration
    [out, retval] IEnumAAFIdentifications ** ppEnum);
}



// ************************
//
// Interface IEnumAAFInterpolationDefs
//
// ************************


[
    object,
    uuid(293600A5-0D37-11d3-80A9-006008143E6F),
    helpstring("IEnumAAFInterpolationDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFInterpolationDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppInterpolationDefs pointer is valid.
  // - there are Interpolation Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppInterpolationDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppInterpolationDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Interpolation Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Interpolation Definition
    [out,retval] IAAFInterpolationDef ** ppInterpolationDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFInterpolationDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppInterpolationDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Interpolation Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppInterpolationDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppInterpolationDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of InterpolationDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFInterpolationDef ** ppInterpolationDefs,

    // number of actual Interpolation Definition objects fetched into ppInterpolationDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFInterpolationDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFOperationDefs
//
// ************************


[
    object,
    uuid(92B88021-2B2B-11D2-BF7E-00104BC9156D),
    helpstring("IEnumAAFOperationDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFOperationDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppOperationDefs pointer is valid.
  // - there are Operation Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppOperationDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppOperationDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Operation Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Operation Definition
    [out,retval] IAAFOperationDef ** ppOperationDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFOperationDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppOperationDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Operation Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppOperationDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppOperationDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of OperationDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFOperationDef ** ppOperationDefs,

    // number of actual Operation Definition objects fetched into ppOperationDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFOperationDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFEssenceData
//
// ************************
//
// The IEnumAAFEssenceData interface is used enumerate all of the
// AAFEssenceData objects in a file.  The AAFEssenceData objects
// contain the actual essence data (ex. WAVE) when it is contained
// within an AAF file.  Normally the client application would access the
// essence through the IAAFEssenceAccess interface, which handles the work
// of finding and (de)compressing the data.  However, in rare cases
// direct access to the data is required, so this interface is exposed.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
//
// AAFRESULT_NULL_PARAM
//   - One of the passed in pointers is NULL.
//
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(B1A21392-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFEssenceData Interface"),
    pointer_default(unique)
]
interface IEnumAAFEssenceData : IUnknown
{


  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The caller is responsible for 
  // properly releasing the returned pointer when it is no longer needed.
  // @comm This is a just simplified version of the Next method. 
  // 
  HRESULT NextOne (
    // The Next EssenceData
    [out,retval] IAAFEssenceData ** ppEssenceData);

  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFEssenceData pointers) in 
  // the enumerator's list, returning them in the given array along with the actual 
  // number of enumerated elements in pcFetched. The caller is responsible for 
  // properly releasing the returned pointers.
  // 
  HRESULT Next (
    // number of essence data requested
    [in] aafUInt32  count,

    // array to receive EssenceData
    [out, size_is(count), length_is(*pFetched)] IAAFEssenceData ** ppEssenceData,

    // number of actual EssenceData fetched into ppEssenceData array
    [out,ref] aafUInt32 *  pFetched);

  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the enumeration so that 
  // the next call to EnumAAFEssenceData::Next will not return 
  // those elements.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);

  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of the list of elements. 
  // @comm There is no guarantee that the same set of elements will be enumerated on 
  // each pass through the list, nor will the elements necessarily be enumerated in 
  // the same order. The exact behavior depends on the collection being enumerated.
  // 
  HRESULT Reset ();

  //***********************************************************
  //
  // Clone()
  //
  // Creates another essence data enumerator with the same state as the current 
  // enumerator to iterate over the same list. This method makes it possible to 
  // record a point in the enumeration sequence in order to return to that point 
  // at a later time.
  // @comm The caller must release this new enumerator separately from the first enumerator.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFEssenceData ** ppEnum);

}



// ************************
//
// Interface IEnumAAFKLVData
//
// ************************


[
    object,
    uuid(46114416-0676-11d4-A356-009027DFCA6A),
    helpstring("IEnumAAFKLVData Interface"),
    pointer_default(unique)
]
interface IEnumAAFKLVData : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppKLVData pointer is valid.
  // - there are KLV Data objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppKLVData.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppKLVData arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no KLV Data objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next KLV Data
    [out,retval] IAAFKLVData ** ppKLVData);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFKLVData pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppKLVData pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are KLV Data objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppKLVData or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppKLVData or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of KLVData requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFKLVData ** ppKLVData,

    // number of actual KLV Data objects fetched into ppKLVData array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFKLVData ** ppEnum);
}



// ************************
//
// Interface IEnumAAFLoadedPlugins
//
// ************************
//
// An object which allows iteration over all of the AAFDefObject
// managed by the AAFPluginManager.  This is useful when adding something pluggable
// into an AAF file, as you know what choices are locally available.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(AB4D9F14-DD69-11d2-809C-006008143E6F),
    helpstring("IEnumAAFLoadedPlugins Interface"),
    pointer_default(unique)
]
interface IEnumAAFLoadedPlugins : IUnknown
{


  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The caller is responsible 
  // for properly releasing the returned pointer when it is no longer needed.
  // @comm This is a just simplified version of the Next method. 
  // 
  HRESULT NextOne (
    // The Next AAFPluginID
    [out,retval] aafUID_t*  ppAAFPluginID);

  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFPluginDesc pointers) in 
  // the enumerator's list, returning them in the given array along with the actual 
  // number of enumerated elements in pFetched. The caller is responsible for 
  // properly releasing the returned pointers.
  // 
  HRESULT Next (
    // number of AAFPluginDef requested
    [in] aafUInt32  count,

    // array to receive aafUID_t
    [out, size_is(count), length_is(*pFetched)] aafUID_t*  pAAFPluginIDs,

    // number of actual AAFPluginDef fetched into ppAAFPluginDef array
    [out,ref] aafUInt32 *  pFetched);

  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the enumeration so that 
  // the next call to EnumAAFLoadedPlugins::Next will not return 
  // those elements.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);

  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of the list of elements. 
  // @comm There is no guarantee that the same set of elements will be enumerated on 
  // each pass through the list, nor will the elements necessarily be enumerated in 
  // the same order. The exact behavior depends on the collection being enumerated.
  // 
  HRESULT Reset ();

  //***********************************************************
  //
  // Clone()
  //
  // Creates another EnumAAFLoadedPlugins enumerator with the same state as the current 
  // enumerator to iterate over the same list. This method makes it possible to 
  // record a point in the enumeration sequence in order to return to that point 
  // at a later time.
  // @comm The caller must release this new enumerator separately from the first
  // enumerator.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFLoadedPlugins ** ppEnum);

}



// ************************
//
// Interface IEnumAAFLocators
//
// ************************
//
// This interface is for the enumerator which is generated by
// IAAFEssenceDescriptor and is used for enumerating over IAAFLocators
// attached to EssenceDescriptor attached to an AAFSourceMob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(B1A2139E-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFLocators Interface"),
    pointer_default(unique)
]
interface IEnumAAFLocators : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppLocator pointer is valid.
  // - there are Locator objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppLocator.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppLocator is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Locators remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Locator
    [out,retval] IAAFLocator ** ppLocator);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFLocator pointers) in 
  // the enumerator's list, returning them in the given array along
  // with the actual number of enumerated elements in pcFetched. The
  // caller is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppLocators pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  // - There are Locator objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppLocators or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppLocators or pNumFetched is null.
  // 
  HRESULT Next (
    // number of locators requested
    [in] aafUInt32  count,

    // array to receive locators
    [out, size_is(count), length_is(*pFetched)] IAAFLocator ** ppLocators,

    // number of actual Locators fetched into ppLocators array
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFLocators::Next will
  // not return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another locator enumerator with the same state as the
  // current enumerator to iterate over the same list. This method
  // makes it possible to record a point in the enumeration sequence
  // in order to return to that point at a later time.
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFLocators ** ppEnum);
}



// ************************
//
// Interface IEnumAAFMobSlots
//
// ************************
//
// This interface is for the enumerator which is generated by IAAFMob
// and is used for enumerating over IAAFMobSlots attached to the mob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(B1A21388-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFMobSlots Interface"),
    pointer_default(unique)
]
interface IEnumAAFMobSlots : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppMobSlot pointer is valid.
  // - there are Mob Slot objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppMobSlot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMobSlot is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - Hit the end of the list of slots being enumerated over.
  // 
  HRESULT NextOne (
    // The Next MobSlot
    [out,retval] IAAFMobSlot ** ppMobSlot);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFMobSlot pointers) in 
  // the enumerator's list, returning them in the given array along
  // with the actual number of enumerated elements in pNumFetched. The
  // caller is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - the ppMobSlots pointer is valid.
  // - the pNumFetched pointer is valid.
  // - there are Mob Slot objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppMobSlots or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppMob or pNumFetched is null.
  //
  // E_INVALIDARG
  //   - Hit the end of the list of slots being enumerated over.
  // 
  HRESULT Next (
    // number of mob slots requested
    [in] aafUInt32  count,

    // array to receive mob slots
    [out, size_is(count), length_is(*pNumFetched)] IAAFMobSlot ** ppMobSlots,

    // number of actual MobSlots fetched into ppMobSlots array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFMobSlots::Next will
  // not return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another mob slot enumerator with the same state as the
  // current enumerator to iterate over the same list. This method
  // makes it possible to record a point in the enumeration sequence
  // in order to return to that point at a later time.
  // 
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFMobSlots ** ppEnum);
}



// ************************
//
// Interface IEnumAAFMobs
//
// ************************
//
// This interface is for the enumerator which is generated by
// IAAFHeader and is used for enumerating over IAAFMobs attached to
// the content storage attached to the header.  The call to generate
// this enumerator takes a mob kind [see below], and enumerates over
// a subset of the mobs attached to the content storage.  This is
// because importing programs often import starting with the source
// mobs, and ending with the composition mobs, so that no dangling
// references must be maintained in their internal representation.
// The possible values for mobKind are:
//  kCompMob   -- Iterate over AAFCompositionMob.
//  kMasterMob -- iterate over AAFMasterMob.
//  kFileMob   -- Iterate over AAFSourceMob with attached
//                AAFFileDescriptor. 
//  kTapeMob   -- Iterate over AAFSourceMob with attached
//                AAFTapeDescriptor.
//  kFilmMob   -- Iterate over AAFSourceMob with attached
//                AAFFilmDescriptor.
//  kAllMob    -- Iterate over all IAAMob.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(B1A21386-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFMobs Interface"),
    pointer_default(unique)
]
interface IEnumAAFMobs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppMob pointer is valid.
  // - there are Mob objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Mobs remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Mob
    [out, retval] IAAFMob ** ppMob);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFMob pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - the ppMobs pointer is valid.
  // - the pNumFetched pointer is valid.
  // - there are Mob objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppMobs or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppMob or pNumFetched is null.
  // 
  HRESULT Next (
    // number of mobs requested
    [in] aafUInt32  count,

    // array to receive mobs
    [out, size_is(count), length_is(*pNumFetched)] IAAFMob ** ppMobs,

    // number of actual Mobs fetched into ppMobs array
    [out] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFMobs::Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another mob enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT Clone (
    // new enumeration
    [out, retval] IEnumAAFMobs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFParameterDefs
//
// ************************
//
// This interface is used to enumerate over the AAFParameterDefinitions referenced
// from in an AAFOperationDefinition or AAFParameter, and contained within
// the AAFDictionary.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(B1A213A4-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFParameterDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFParameterDefs : IUnknown
{


  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppParameterDef pointer is valid.
  // - there are ParameterDef objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppParameterDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppParameterDef is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no ParameterDefs remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next ParameterDefinition
    [out,retval] IAAFParameterDef ** ppParameterDef);

  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFParameterDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppParameterDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  // - There are AAFParameterDef objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppComponents or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppParameterDefs or pNumFetched is null.
  // 
  HRESULT Next (
    // number of control code definitions requested
    [in] aafUInt32  count,

    // array to receive control code definitions
    [out, size_is(count), length_is(*pFetched)] IAAFParameterDef ** ppParameterDefs,

    // number of actual ParameterDefs fetched into ppParameterDefs array
    [out,ref] aafUInt32 *  pFetched);

  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);

  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();
  // @comm There is no guarantee that the same set of elements will be enumerated on 
  // each pass through the list\, nor will the elements necessarily be enumerated in 
  // the same order. The exact behavior depends on the collection being enumerated.)

  //***********************************************************
  //
  // Clone()
  //
  // Creates another EnumAAFParameterDefs enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFParameterDefs ** ppEnum);

}



// ************************
//
// Interface IEnumAAFParameters
//
// ************************
//
// This interface is used to enumerate over the AAFParameters
// referenced from in an AAFOperationDefinition or AAFParameter, and
// contained within the AAFDictionary.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(7227261E-A8C9-11D3-A3ED-0004AC96A937),
    helpstring("IEnumAAFParameters Interface"),
    pointer_default(unique)
]
interface IEnumAAFParameters : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppParameter pointer is valid.
  // - there are Parameter objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppParameter.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppParameter is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Parameters remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Parameter
    [out,retval] IAAFParameter ** ppParameter);

  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFParameter pointers) in
  // the enumerator's list, returning them in the given array along
  // with the actual number of enumerated elements in pNumFetched. The
  // caller is responsible for properly releasing the returned
  // pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppParameters pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are AAFParameter objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppComponents or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppParameters or pNumFetched is null.
  // 
  HRESULT Next (
    // number of parameter objects requested
    [in] aafUInt32  count,

    // array to receive parameter objects
    [out, size_is(count), length_is(*pFetched)] IAAFParameter ** ppParameters,

    // number of actual Parameters fetched into ppParameters array
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // There is no guarantee that the same set of elements will be
  // enumerated on each pass through the list, nor will the elements
  // necessarily be enumerated in the same order. The exact behavior
  // depends on the collection being enumerated.
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another EnumAAFParameters enumerator with the same state
  // as the current enumerator to iterate over the same list. This
  // method makes it possible to record a point in the enumeration
  // sequence in order to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFParameters ** ppEnum);
}



// ************************
//
// Interface IEnumAAFProperties
//
// ************************
//
// This interface is used to enumerate over the AAFProperties
// contained in a collection.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
/***********************************************\
*   Stub only.   Implementation not yet added   *
\***********************************************/


[
    object,
    uuid(BE316DB2-7E73-11D2-841D-00600832ACB8),
    helpstring("IEnumAAFProperties Interface"),
    pointer_default(unique)
]
interface IEnumAAFProperties : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppProperties pointer is valid.
  // - there are Property objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppProperties.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppProperties arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Property objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Property
    [out,retval] IAAFProperty ** ppProperties);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFProperty pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppProperties pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Property objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppProperties or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppProperties or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of Properties requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFProperty ** ppProperties,

    // number of actual Property objects fetched into ppProperties array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFProperties ** ppEnum);
}



// ************************
//
// Interface IEnumAAFPropertyDefs
//
// ************************


[
    object,
    uuid(245343C1-2D59-11D2-BF80-00104BC9156D),
    helpstring("IEnumAAFPropertyDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFPropertyDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppPropertyDefs pointer is valid.
  // - there are Property Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPropertyDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropertyDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Property Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Property Definition
    [out,retval] IAAFPropertyDef ** ppPropertyDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFPropertyDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppPropertyDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Property Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPropertyDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppPropertyDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of PropertyDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFPropertyDef ** ppPropertyDefs,

    // number of actual Property Definition objects fetched into ppPropertyDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFPropertyDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFPropertyValues
//
// ************************
//
// This interface is used to enumerate over the AAFPropertyValues
// contained in a collection.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
/***********************************************
*	Stub only.   Implementation not yet added	*
***********************************************/


[
    object,
    uuid(809c8caa-9884-11d2-841f-00600832acb8),
    helpstring("IEnumAAFPropertyValues Interface"),
    pointer_default(unique)
]
interface IEnumAAFPropertyValues : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppPropertyValue pointer is valid.
  // - there are Property Values remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPropertyValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropertyValue is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Components remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Property Value
    [out,retval] IAAFPropertyValue ** ppPropertyValue);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFPropertyValue pointers)
  // in the enumerator's list, returning them in the given array
  // along with the actual number of enumerated elements in
  // pNumFetched. The caller is responsible for properly releasing the
  // returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppMobs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL. 
  // - There are Property Value objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPropertyValues or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppCompoents or pNumFetched is null.
  // 
  HRESULT Next (
    // number of objects requested
    [in] aafUInt32  count,

    // array to receive Property Values
    [out, size_is(count), length_is(*pFetched)] IAAFPropertyValue ** ppPropertyValues,

    // number of actual Property Values fetched into ppPropertyValues
	// array
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // Always succeeds.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another Property Value enumerator with the same state as
  // the current enumerator to iterate over the same list. This method
  // makes it possible to record a point in the enumeration sequence
  // in order to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFPropertyValues ** ppEnum);
}



// ************************
//
// Interface IEnumAAFPluginDefs
//
// ************************
//
// An object which allows iteration over all of the AAFPluginDefinitions
// in the dictionary.  These descriptors describe particular
// implementation of the particular plugin interface.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(AD1BB85F-DBB2-11d2-809C-006008143E6F),
    helpstring("IEnumAAFPluginDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFPluginDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppPluginDefs pointer is valid.
  // - there are Plugin Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPluginDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPluginDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Plugin Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Plugin Definition
    [out,retval] IAAFPluginDef ** ppPluginDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFPluginDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppPluginDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Plugin Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPluginDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppPluginDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of PluginDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFPluginDef ** ppPluginDefs,

    // number of actual Plugin Definition objects fetched into ppPluginDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFPluginDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFPluginLocators
//
// ************************
//
// An object which allows iteration over all of the AAFLocators
// attached to an AAFPluginDescriptor.  These locators describe how to
// locate the exact object code described in the AAFPluginDescriptor.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


[
    object,
    uuid(AD1BB861-DBB2-11d2-809C-006008143E6F),
    helpstring("IEnumAAFPluginLocators Interface"),
    pointer_default(unique)
]
interface IEnumAAFPluginLocators : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  HRESULT NextOne (
    // The Next AAFLocator
    [out,retval] IAAFLocator ** ppAAFLocator);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFLocator pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  HRESULT Next (
    // number of AAFLocators requested
    [in] aafUInt32  count,

    // array to receive AAFLocators
    [out, size_is(count), length_is(*pFetched)] IAAFLocator ** ppAAFLocators,

    // number of actual AAFLocators fetched into ppAAFLocators array
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFPluginLocators::Next
  // will not return  those elements.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // There is no guarantee that the same set of elements will be
  // enumerated on each pass through the list, nor will the elements
  // necessarily be enumerated inthe same order. The exact behavior
  // depends on the collection being enumerated.
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another AAFPluginLocators enumerator with the same state
  // as the current enumerator to iterate over the same list. This
  // method makes it possible to record a point in the enumeration
  // sequence in order to return to that point at a later time.
  //
  // The caller must release this new enumerator separately from the
  // first enumerator.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFPluginLocators ** ppEnum);
}



// ************************
//
// Interface IEnumAAFSegments
//
// ************************


[
    object,
    uuid(B1A213A2-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFSegments Interface"),
    pointer_default(unique)
]
interface IEnumAAFSegments : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppSegments pointer is valid.
  // - there are Segment objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppSegments.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSegments arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Segment objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Segment
    [out,retval] IAAFSegment ** ppSegments);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFSegment pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppSegments pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Segment objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppSegments or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppSegments or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of Segments requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFSegment ** ppSegments,

    // number of actual Segment objects fetched into ppSegments array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFSegments ** ppEnum);
}



// ************************
//
// Interface IEnumAAFTaggedValues
//
// ************************


[
    object,
    uuid(5f7916f1-0f87-11d3-8a3e-0050040ef7d2),
    helpstring("IEnumAAFTaggedValues Interface"),
    pointer_default(unique)
]
interface IEnumAAFTaggedValues : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppTaggedValues pointer is valid.
  // - there are Tagged Value objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppTaggedValues.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTaggedValues arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Tagged Value objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Tagged Value
    [out,retval] IAAFTaggedValue ** ppTaggedValues);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFTaggedValue pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppTaggedValues pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Tagged Value objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppTaggedValues or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppTaggedValues or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of TaggedValues requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFTaggedValue ** ppTaggedValues,

    // number of actual Tagged Value objects fetched into ppTaggedValues array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFTaggedValues ** ppEnum);
}



// ************************
//
// Interface IEnumAAFTypeDefs
//
// ************************


[
    object,
    uuid(B1A2138C-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFTypeDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFTypeDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppTypeDefs pointer is valid.
  // - there are Type Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppTypeDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Type Definition objects remaining to be returned.
  // 
  HRESULT NextOne (
    // The Next Type Definition
    [out,retval] IAAFTypeDef ** ppTypeDefs);


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFTypeDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppTypeDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Type Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppTypeDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppTypeDefs or pNumFetched arg is NULL.
  // 
  HRESULT Next (
    // number of TypeDefs requested
    [in] aafUInt32  count,

    // array to receive elements
    [out, size_is(count), length_is(*pNumFetched)] IAAFTypeDef ** ppTypeDefs,

    // number of actual Type Definition objects fetched into ppTypeDefs array
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  // 
  HRESULT Skip (
    // Number of elements to skip
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  // 
  HRESULT Clone (
    // new enumeration
    [out,retval] IEnumAAFTypeDefs ** ppEnum);
}



// ************************
//
// Interface IAAFRawStorage
//
// ************************
//
// This interface is used by the toolkit to access storage in which
// AAF files are to be read and written.  It is typically implemented
// by clients of IAAFFileXXX.  Note that some implementations are
// provided as a convenience to IAAFFileXXX clients.
//
// When writing to a stream, clients should be aware that the
// stream's capacity may be limited.  To insure that writes will not
// fail due to insufficient stream capacity, clients can call
// SetSize() to pre-allocate capacity in the stream.  Writes done
// within the size specified to the most recent successful SetSize()
// call are guaranteed to succeed.
//
// Assumes that the storage has at least sequential access
// capability.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


[
    object,
    uuid(F45FA9E1-7166-11D4-B80D-0000863F2C27),
    helpstring("IAAFRawStorage Interface"),
    pointer_default(unique)
]
interface IAAFRawStorage : IUnknown
{

  //***********************************************************
  //
  // IsReadable()
  //
  // Sets *pResult to true if this storage is readable; sets it to
  // false otherwise.
  //
  // Succeeds if:
  // - The pResult pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT IsReadable (
    // set to true if readable
    [out] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // Read()
  //
  // Attempts to read bufsize bytes from this stream.  Places the data
  // into buf, and puts the actual number of bytes read into
  // *pNumRead.  If the end of the stream is encountered before
  // bufSize bytes can be read, the value written into *pNumRead may
  // be smaller than bufSize.
  //
  // This call will advance the current position by *pNumRead bytes.
  //
  // Succeeds if:
  // - The pNumBytes pointer is valid.
  // - This stream is open for read or read/write.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - buf or pNumRead arg is NULL.
  //
  // AAFRESULT_NOT_READABLE
  //   - This stream is not open for read or read/write.
  // 
  HRESULT Read (
    // Buffer into which data is read
    [out, size_is(bufSize), length_is(*pNumRead)] aafMemPtr_t  buf,

    // Size of buf in bytes
    [in] aafUInt32  bufSize,

    // Number of bytes read
    [out] aafUInt32 *  pNumRead);


  //***********************************************************
  //
  // IsWriteable()
  //
  // Sets *pResult to true if this storage is writeable; sets it to
  // false otherwise.
  //
  // Succeeds if:
  // - The pResult pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT IsWriteable (
    // set to true if writeable
    [out] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // Write()
  //
  // Writes bufsize bytes into this stream.  Obtains the data
  // from buf.
  //
  // This call may fail if the stream has insufficient capacity to
  // complete the request.  If this storage supports the
  // IAAFRandomRawStorage interface, the client can call
  // IAAFRandomRawStorage::SetSize() to attempt to reserve capacity
  // in the stream; if the SetSize() call succeeds, subsequent
  // Write() calls within that capacity are guaranteed to succeed.
  //
  // This call will advance the current position by bufSize bytes.
  //
  // Succeeds if:
  // - This stream is open for write or read/write.
  // - Sufficient capacity exists in this stream to perform the
  //   write.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - This stream is not open for write or read/write.
  //
  // AAFRESULT_SMALLBUF
  //   - This stream has insufficient capacity to perform the write.
  // 
  HRESULT Write (
    // Buffer from which data is written
    [in, size_is(bufSize)] aafMemConstPtr_t  buf,

    // Number of bytes to write
    [in] aafUInt32  bufSize,

    // Number of bytes written
    [out] aafUInt32 *  pNumWritten);


  //***********************************************************
  //
  // Synchronize()
  //
  // Synchronizes any cached data with the underlying storage.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Synchronize ();
}



// ************************
//
// Interface IAAFRandomRawStorage
//
// ************************
//
// This interface is used by the toolkit to access storage in which
// AAF files are to be read and written.  It is typically implemented
// by clients of IAAFFileXXX.  Note that some implementations are
// provided as a convenience to IAAFFileXXX clients.
//
// Assumes that the storage has at least random access capability.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFRandomRawStorage also implement the following interfaces:
//  - IAAFRawStorage

[
    object,
    uuid(B1341782-71FE-11d4-B80D-0000863F2C27),
    helpstring("IAAFRandomRawStorage Interface"),
    pointer_default(unique)
]
interface IAAFRandomRawStorage : IUnknown
{

  //***********************************************************
  //
  // ReadAt()
  //
  // Attempts to read bufsize bytes from this storage.  Places the
  // data into buf, and puts the actual number of bytes read into
  // *pNumRead.  If the end of the storage is encountered before
  // bufSize bytes can be read, the value written into *pNumRead may
  // be smaller than bufSize.
  //
  // This call will advance the current position by *pNumRead bytes.
  //
  // Succeeds if:
  // - The pNumRead pointer is valid.
  // - This storage is open for read or read/write.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - buf or pNumRead arg is NULL.
  //
  // AAFRESULT_NOT_READABLE
  //   - This storage is not open for read or read/write.
  // 
  HRESULT ReadAt (
    // position in this storage from which data is read
    [in] aafUInt64  position,

    // Buffer into which data is read
    [out, size_is(bufSize), length_is(*pNumRead)] aafMemPtr_t  buf,

    // Size of buf in bytes
    [in] aafUInt32  bufSize,

    // Number of bytes read
    [out] aafUInt32 *  pNumRead);


  //***********************************************************
  //
  // WriteAt()
  //
  // Writes bufsize bytes into this storage.  Obtains the data
  // from buf.
  //
  // This call may fail if the capacity of this storage cannot be
  // extended sufficiently to complete the request.  The client can
  // call SetSize() to attempt to reserve capacity for the storage;
  // if the SetSize() call succeeds, subsequent Write() calls
  // within requested that capacty are guaranteed to succeed.
  //
  // This call will advance the current position by bufSize bytes.
  //
  // Succeeds if:
  // - The pNumWritten pointer is valid.
  // - This storage is open for write or read/write.
  // - Sufficient capacity exists in this storage to perform the
  //   write.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumWritten arg is NULL.
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - This storage is not open for write or read/write.
  //
  // AAFRESULT_OFFSET_SIZE
  //   - It is not possible to extend the allocated size of this
  //     storage.
  // 
  HRESULT WriteAt (
    // position in this storage into which data is written
    [in] aafUInt64  position,

    // Buffer from which data is written
    [in, size_is(bufSize)] aafMemConstPtr_t  buf,

    // Number of bytes
    [in] aafUInt32  bufSize,

    // Number of bytes written
    [out] aafUInt32 *  pNumWritten);


  //***********************************************************
  //
  // GetSize()
  //
  // Returns the highest byte position in this storage which has been
  // written so far.
  //
  // Succeeds if:
  // - The pSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  // 
  HRESULT GetSize (
    // Number of bytes currently in this storage
    [out] aafUInt64 *  pSize);


  //***********************************************************
  //
  // IsExtendable()
  //
  // Sets *pResult to true if the memory allocated to this storage can
  // be dynamically extened; sets it to false otherwise.
  //
  // Succeeds if:
  // - The pResult pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  // 
  HRESULT IsExtendable (
    // set to true if extendable
    [out] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // GetExtent()
  //
  // Returns the number of bytes currently allocated storage.
  //
  // Succeeds if:
  // - The pSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pExtent arg is NULL.
  // 
  HRESULT GetExtent (
    // Number of bytes currently allocated for this storage
    [out] aafUInt64 *  pExtent);


  //***********************************************************
  //
  // SetExtent()
  //
  // Requests the given capacity for this storage.  If successful,
  // subsequent calls to WriteAt() and IAAFRawStorage::Write()
  // within that capacity are guaranteed to succeed.
  //
  // Succeeds if:
  // - It is permissible to set the extent of this storage.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_OFFSET_SIZE
  //   - This storage has insufficient capacity to perform the write.
  // 
  HRESULT SetExtent (
    // Number of bytes capacity requested for this storage
    [in] aafUInt64  extent);
}



// ************************
//
// Interface IAAFGetFileBits
//
// ************************
//
// This interface is implemented by the toolkit, and is provided to
// clients of IAAFFile to allow them to obtain the raw bits of a file
// after close.
//
// Note that this and the IAAFSetFileBits interfaces are different
// than the IAAFRawStorage interfaces in that those are implemented by
// clients to provide access to the desired media; these are provided
// by the toolkit to provide read OR write (but not both
// simultaneously) access to the raw bits.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


[
    object,
    uuid(3CC80282-72A8-11D4-B80D-0000863F2C27),
    helpstring("IAAFGetFileBits Interface"),
    pointer_default(unique)
]
interface IAAFGetFileBits : IUnknown
{

  //***********************************************************
  //
  // ReadAt()
  //
  // Attempts to read bufsize bytes from this stream at the given byte
  // offset.  Places the data into buf.  Any attempt to read beyond
  // the size of this file, as reported by GetSize(), will be
  // considered an error.
  //
  // A value of zero for position indicates the beginning of the
  // stream.
  //
  // Succeeds if:
  // - The pNumBytes pointer is valid.
  // - position + buSize is not larger than the size of this file, as
  //   reported by GetSize().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - buf arg is NULL.
  //
  // AAFRESULT_OFFSET_SIZE
  //   - position + size is larger than the size of this file.
  // 
  HRESULT ReadAt (
    // Buffer into which data is read
    [out, size_is(bufSize)] aafMemPtr_t  buf,

    // Size of buf in bytes
    [in] aafUInt32  bufSize,

    // The position in bytes at which to read
    [in] aafUInt64  position);


  //***********************************************************
  //
  // GetSize()
  //
  // Returns the size of this file, in bytes, in *pSize.
  //
  // Succeeds if:
  // - The pSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  // 
  HRESULT GetSize (
    // The size of this file in bytes
    [out] aafUInt64 *  pSize);
}



// ************************
//
// Interface IAAFSetFileBits
//
// ************************
//
// This interface is implemented by the toolkit, and is provided to
// clients of IAAFFile to allow them to supply the raw bits of a file
// before open.
//
// Note that this and the IAAFGetFileBits interfaces are different
// than the IAAFRawStorage interfaces in that those are implemented by
// clients to provide access to the desired media; these are provided
// by the toolkit to provide read OR write (but not both
// simultaneously) access to the raw bits.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


[
    object,
    uuid(6D950762-8DB4-11D4-B80D-0000863F2C27),
    helpstring("IAAFSetFileBits Interface"),
    pointer_default(unique)
]
interface IAAFSetFileBits : IUnknown
{

  //***********************************************************
  //
  // WriteAt()
  //
  // Writes bufsize bytes into this file at the given byte offset.
  // Obtains the data from buf.  A value of zero for position
  // indicates the beginning of the stream.
  //
  // Succeeds if sufficient space is available in the file to write
  // the given number of bytes at the given position.  It's possible
  // to guarantee that this method will succeed if SetSize() is first
  // called to reserve the required space.  If SetSize() is not first
  // called to reserve the space, this method will attempt to request
  // it, but this attempt may fail.
  //
  // Succeeds if:
  // - The buf argument is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - buf arg is NULL.
  //
  // AAFRESULT_DATA_SIZE
  //   - The requested space is not available.
  // 
  HRESULT WriteAt (
    // Buffer from which data is written
    [in, size_is(bufSize)] aafMemPtr_t  buf,

    // Number of bytes
    [in] aafUInt32  bufSize,

    // The position in bytes at which to read
    [in] aafUInt64  position);


  //***********************************************************
  //
  // SetSize()
  //
  // Attempts to reserve size bytes of storage.
  //
  // Succeeds if:
  // - The requested space is available.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DATA_SIZE
  //   - size bytes are not available.
  // 
  HRESULT SetSize (
    // The requested file size
    [in] aafUInt64  size);
}



// ************************
//
// Interface IAAFRandomFile
//
// ************************
//
// Specialized file interface for use with files which exist on
// storage media which has random access capability.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//


//
// Objects that implement IAAFRandomFile also implement the following interfaces:
//  - IAAFFile

[
    object,
    uuid(3CC80284-72A8-11D4-B80D-0000863F2C27),
    helpstring("IAAFRandomFile Interface"),
    pointer_default(unique)
]
interface IAAFRandomFile : IUnknown
{

  //***********************************************************
  //
  // GetFileBits()
  //
  // Since the purpose of this method is to obtain file data after a
  // file has been created, it will only succeed if this file has
  // already been Open()ed and then Close()d, or if it was never
  // opened with write access.
  // 
  // Succeeds if:
  // - The ppGetFileBits argument is valid
  // - This file has been opened for write or modify, and has been
  //   subsequently closed.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppGetFileBits arg is NULL.
  //
  // AAFRESULT_BADOPEN
  // - This file has never been opened
  //
  // AAFRESULT_NOT_WRITEABLE
  // - This file has never been opened for write or modify
  //
  // AAFRESULT_BADCLOSE
  // - This file has not been closed after being opened.
  // 
  HRESULT GetFileBits (
    // The interface to the GetFileBits object
    [out] IAAFGetFileBits ** ppGetFileBits);


  //***********************************************************
  //
  // Revert()
  //
  // Reverts this file to the previously-saved state.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT Revert ();


  //***********************************************************
  //
  // SaveAsFile()
  //
  // Associates this file with the storage specified in pDestFile.
  // Any objects contained in pDestFile will be lost.
  // 
  // Behaves in a manner similar to SaveCopyAs(), except that
  // SaveAs() will change this object to be associated with the new
  // file.
  // 
  // Special case: if f->SaveAs(f) is called, passing this as the
  // save-to argument, the operation will save everything including
  // things which have not changed.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  HRESULT SaveAsFile (
    // The destination file into which the contents of this file are to
    // be written.
    [in] IAAFFile * pDestFile);


  //***********************************************************
  //
  // SetFileBits()
  //
  // Since the purpose of this method is to specify file data with
  // which a file is to be created, it will only succeed if this file
  // has not yet been Open()ed.
  //
  // Succeeds if:
  // - The ppSetFileBits argument is valid
  // - This file has not yet been opened.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSetFileBits arg is NULL.
  //
  // AAFRESULT_BADOPEN
  // - This file has has already been opened
  //
  // AAFRESULT_NOT_READABLE
  // - This read or modify has not been specified for this file
  // 
  HRESULT SetFileBits (
    // The interface to the SetFileBits object
    [out] IAAFSetFileBits ** ppSetFileBits);
}



// ************************
//
// Interface IAAFEndian
//
// ************************
//
// This interface is used to allow the user to determine the byte
// order of this object.  Note that the byte order of the object
// stored in the AAF file may be different from the native byte order
// of this machine.  Note also that both pieces of information are
// available here.
//
// Byte order of newly created AAF files is set upon creation of that
// file.  It is set to the byte order of the creating machine.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFEndian is not a
//     primary interface for a concrete class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//
[
    object,
    uuid(6BACC0C1-6091-11D2-841B-00600832ACB8),
    helpstring("IAAFEndian Interface"),
    pointer_default(unique)
]
interface IAAFEndian : IUnknown
{

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  // Returns the "Endian-ness" in which the current object was or will
  // be stored.  If this is a transient object (i.e., one which has
  // not been persisted) then it will return the native byte order of
  // the platform on which this is running.
  // 
  // Succeeds if all of the following are true:
  // - the pOrder pointer is valid.
  // 
  // If this method fails nothing is written to *pOrder.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOrder is null.
  // 
  HRESULT GetStoredByteOrder (
    // Pointer to place where byte order is to be put
    [out] eAAFByteOrder_t *  pOrder);


  //***********************************************************
  //
  // GetNativeByteOrder()
  //
  // Returns the native "Endian-ness" of the platform on which this is
  // running.
  // 
  // Succeeds if all of the following are true:
  // - the pOrder pointer is valid.
  // 
  // If this method fails nothing is written to *pOrder.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOrder is null.
  // 
  HRESULT GetNativeByteOrder (
    // Pointer to place where byte order is to be put
    [out] eAAFByteOrder_t *  pOrder);
}



// ************************
//
// Interface IAAFSearchSource
//
// ************************
//
// The IAAFSearchSource interface is used to return source information
// for some mob slots.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFSearchSource is
//     not a primary interface for a concrete class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//
[
    object,
    uuid(332CBDD0-5425-11D2-AA7A-10003D000000),
    helpstring("IAAFSearchSource Interface"),
    pointer_default(unique)
]
interface IAAFSearchSource : IUnknown
{

  //***********************************************************
  //
  // SearchSource()
  //
  // This function returns the source information for a slot in a
  // Master Mob or Source Mob.  It follows the Source Clip references
  // in the specified slot until it encounters the kind of Mob
  // specified in the mobKind parameter.  This function cannot be used
  // on a Composition Mob and is not intended to be called
  // iteratively; use the MobOpenSearch, MobGetNextSource,
  // MobGetThisSource, and MobCloseSearch functions for those
  // purposes. 
  //
  // The returned component and find source info are AddRef()ed
  // before they are returned.
  //
  // Succeeds if all of the following are true:
  // - ppSourceInfo is non-NULL
  // - a Mob of the requested kind is found
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppCpnt is null.
  //
  // OM_ERR_INVALID_MOBTYPE
  //	- The enumerator is out of range (bad cast, or writing
  //      toolkit newer than reader)
  //
  // OM_ERR_TRAVERSAL_NOT_POSS
  //	- Can not find a mob of the given kind.
  // 
  HRESULT SearchSource (
    // Slot ID
    [in] aafSlotID_t  slotID,

    // Offset
    [in] aafPosition_t  offset,

    // Mob Kind
    [in] aafMobKind_t  mobKind,

    // Media Criteria
    [in] aafMediaCriteria_t *  pMediaCrit,

    // Operation Choice
    [in] aafOperationChoice_t *  pOperationChoice,

    // Source Information
    [out] IAAFFindSourceInfo ** ppSourceInfo);
}



// ************************
//
// Interface IAAFEssenceMultiAccess
//
// ************************

//
// AAFEssenceMultiAccess is an interace which provides streaming
// access over essence data.  This nterfaces deals with essence data
// which is in an uncompressed form, and handles compression or
// decompression of the data if required.
//
// You should call the CreateMultiEssence or OpenMultiEssence calls on
// AAFMasterMob in order to get an interface pointer to
// AAFEssenceAccess, as there is no public create or open method in
// the interface.
//
// Objects implementing this interface also implement AAFEssenceAccess
// for operations other than read and write.
//
// A number of errors can be returned from most method calls,  These
// are:
//   AAFRESULT_NOMEMORY   -- The system ran out of memory processing
//                           the method. 
//   AAFRESULT_NULL_PARAM -- A NULL parameter was passed in which was
//                           required.


[
    object,
    uuid(D815E2B4-2425-11d3-80AD-006008143E6F),
    helpstring("IAAFEssenceMultiAccess Interface"),
    pointer_default(unique)
]
interface IAAFEssenceMultiAccess : IUnknown
{

  //***********************************************************
  //
  // WriteMultiSamples()
  //
  // Writes multiple channels worth of sample data to an interleaved
  // data stream in the natural order for the CODEC.
  // 
  HRESULT WriteMultiSamples (
    // number of elements in the array of transfer operations
    [in] aafUInt16  arrayElemCount,

    // points to an array of transfer parameters.  All fields in this
    // array except for bytesXferred must be set up before doing the
    // transfer.  Some of the fields in the xferArray structure are
    // status results like bytesXferred and samplesXferred.
    //
    // The multiXfer_t structure has the following fields, which
	// specify one channel of data: 
    //   essenceDef    [IN] -- The essence type definition
    //   physical      [IN] -- The physical input-output channel
    //   numSamples    [IN] -- The number of samples to transfer
    //   buflen        [IN] -- The size of the buffer
    //   buffer        [IN] -- The buffer for this
    [in,size_is(arrayElemCount)] aafmMultiXfer_t *  xferArray,

    // put results into this array.  It has the following fields,
    // which return result for one channel of data:
    //   bytesXfered   [OUT] -- The total number of bytes transferred
    //   samplesXfered [OUT] -- The total number of samples transferred
    [out,size_is(arrayElemCount)] aafmMultiResult_t *  resultArray);


  //***********************************************************
  //
  // ReadMultiSamples()
  //
  // Reads one or more channels from an interleaved data stream.
  // Possible Errors:
  //
  // Standard errors (see top of file).
  //   AAFRESULT_END_OF_ESSENCE -- Hit the end of the essence (like
  //                               EOF) while reading.
  // 
  HRESULT ReadMultiSamples (
    // The size of the array for transfer operations.
    [in] aafUInt16  elemCount,

    // Points to an array of transfer parameters.  All fields in this
    // array except for bytesXferred must be set up before doing the
	// transfer.  Some of the fields in the xferArray structure are
	// status results like bytesXferred and samplesXferred.
    //
    // The multiXfer_t structure has the following fields, which
	// specify one channel of data:
    // essenceDef  [IN] -- The essence type definition
    // physical    [IN] -- The physical input-output channel
    // numSamples  [IN] -- The number of samples to transfer
    // buflen      [IN] -- The size of the buffer
    // buffer      [IN] -- The buffer for this
    [in, size_is(elemCount)] aafmMultiXfer_t *  xferArray,

    // Results go into this array.
    //
    // The aafmMultiResult_t structure has the following fields,
	// which return result for one channel of data: 
    // bytesXfered   [OUT] -- The total number of bytes transferred
    // samplesXfered [OUT] -- The total number of samples transferred
    [out, size_is(elemCount)] aafmMultiResult_t *  resultArray);
}



// ************************
//
// Interface IAAFTypeDefVariableArrayEx
//
// ************************
//
// This interface is an extension to the previously definined TypeDefVariableArray
// interface.  Hence the suffix "Ex" to the name. Additional methods are now included.
//
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.


//
// Objects that implement IAAFTypeDefVariableArrayEx also implement the following interfaces:
//  - IAAFTypeDef
//  - IAAFMetaDefinition

[
    object,
    uuid(7f73d4b3-6f9a-11d4-8e59-009027dfcc26 ),
    helpstring("IAAFTypeDefVariableArrayEx Interface"),
    pointer_default(unique)
]

interface IAAFTypeDefVariableArrayEx : IUnknown
{


  //***********************************************************
  //
  // PrependElement()
  //
  // Prepends an element to the end of the array, setting it to the
  // value given in pMemberPropVal.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pInPropVal pointer is valid.
  // - pMemberPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or pMemberPropVal arg is NULL.
  // 
  HRESULT PrependElement (
    // property value corresponding to array to which element is prepended
    [in] IAAFPropertyValue * pInPropVal,

    // value to be prepended to this array
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // RemoveElement()
  //
  // Remove an element from the Array, given an index.
  // Index is zero-based,
  // and must be less than the value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInPropVal arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - The given index is out of range for this array type def.
  // 
  HRESULT RemoveElement (
    // property value corresponding to array
    [in] IAAFPropertyValue * pInPropVal,

    // zero-based index into elements in this array type
    [in] aafUInt32  index);


  //***********************************************************
  //
  // InsertElement()
  //
  // Inserts the value of the single, indicated element of the fixed
  // array contained in pInPropVal, to the value contained in
  // pMemberPropVal.  Index is zero-based, and must be less than the
  // value returned by GetCount().  Property value must be of the
  // same type as returned by GetType().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - The given index is out of range for this array type def.
  // 
  HRESULT InsertElement (
    // property value corresponding to array
    [in] IAAFPropertyValue * pInPropVal,

    // zero-based index into elements in this array type
    [in] aafUInt32  index,

    // value to be inserted into this array
    [in] IAAFPropertyValue * pMemberPropVal);


}





  //***********************************************************
  //
  // Global functions for AAF files:
  // 
  // In addition to the specific error results listed for each function,
  // all factory functions may also return one of the following
  // values:
  // 
  // AAFRESULT_NOMEMORY
  //   - insufficient system memory is available to perform the
  //     operation.
  //


cpp_quote("  //***********************************************************") 
cpp_quote("  // Functions used to dynamically load and unload the AAF dll") 
cpp_quote("  // without statically linking to the dll's export library.") 
cpp_quote("  // To use these functions link to the stub library aaf.lib") 
cpp_quote("  // (or aafd.lib for the debugging version). ") 
cpp_quote("  // If the client is statically linking to the AAF dll's export") 
cpp_quote("  // library then the following functions will always succeed:") 
cpp_quote("  //***********************************************************") 

  //***********************************************************
  //
  // AAFLoad()
  //
  // Attempts to load the given implementation of AAF into
  // the processes address space. Only one implementation
  // of AAF can be active. Note: once AAFUnload has been
  // called all
  // 
  // STDAPI AAFLoad (
    // Pointer to the name of AAF dll to load.
    // If this pointer is NULL the function will attempt to load the
    // default AAF dll.
    // [in] const char *  dllname);

cpp_quote("STDAPI AAFLoad (const char *  dllname);")
cpp_quote("")


  //***********************************************************
  //
  // AAFUnload()
  //
  // Attempts to unload the current AAF dll loaded with a
  // previous call to AAFLoad.
  //
 
cpp_quote("STDAPI AAFUnload ();")
cpp_quote("")


cpp_quote("  //***********************************************************") 
cpp_quote("  // Factory functions for AAF files:.") 
cpp_quote("  //***********************************************************") 

  //***********************************************************
  //
  // AAFFileOpenExistingRead()
  //
  // Creates an object associated with with an existing filesystem
  // file that contains data which is only to be read.  Does the
  // following:
  // - Opens the existing named file in the filesystem for reading.
  // - Associates an object with that filesystem file.
  // - Places the object into the Open-read-only state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within
  //   the file.
  //
  // Succeeds if:
  // - The pFileName argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file exists in the filesystem.
  // - The named filesystem file is readable.
  // - The named file represents itself as a valid AAF file.  Even if
  //   this succeeds, it is not guaranteed that the named file is in
  //   fact a valid AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pFileName pointer arg is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - The named file does not exist in the filesystem.
  //
  // AAFRESULT_NOT_READABLE
  //   - The named file cannot be read.
  //
  // AAFRESULT_NOT_AAF_FILE
  //   - The named file does not claim to be a valid AAF file.
  // 
  // STDAPI AAFFileOpenExistingRead (
    //  Null-terminated string containing name of filesystem file to be
    // opened for reading.  Filename must be in a form that would be
    // acceptable to StgOpenStorage() for this platform.
    //  [in, string] aafCharacter_constptr  pFileName,
    //
    //  File open mode flags.  May be any of the following ORed
    // together.  All other bits must be set to zero.
    //  - kAAFFileModeUnbuffered - to indicate buffered mode.  Default
    //    is buffered.
    //  [in] aafUInt32  modeFlags,
    //
    //  Pointer to buffer to receive pointer to new file.
    //  [out] IAAFFile ** ppFile);

cpp_quote("STDAPI AAFFileOpenExistingRead (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileOpenExistingModify()
  //
  // Creates an object associated with with an existing
  // filesystem file that contains data which is to be read and
  // written.  Associates the given identification with it.
  // Does the following:
  // - Opens the existing named file in the filesystem for reading and
  //   writing.
  // - Associates an object with that filesystem file.
  // - Places the object into the Open-read-write  state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within
  //   the file.
  //
  // Succeeds if:
  // - This object is currently Closed.
  // - The pFileName argument is valid.
  // - The pIdent argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file exists in the filesystem.
  // - The named filesystem file is readable.
  // - The named filesystem file is writable.
  // - The named file represents itself as a valid AAF file.  Even if
  //   this succeeds, it is not guaranteed that the named file is in
  //   fact a valid AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pFileName or pIdent pointer argument is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - The named file does not exist in the filesystem.
  //
  // AAFRESULT_NOT_READABLE
  //   - The named file cannot be read.
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - The named file cannot be written.
  //
  // AAFRESULT_NOTAAFFILE
  //   - The named file is not a valid AAF file.
  // 
  // STDAPI AAFFileOpenExistingModify (
    //  Null-terminated string containing name of filesystem file to be
    // opened for modification.  Filename must be in a form that would
    // be acceptable to StgOpenStorage() for this platform.
    //  [in, string] aafCharacter_constptr  pFileName,
    //
    //  File open mode flags.  May be any of the following ORed together.
    // All other bits must be set to zero.
    //  - kAAFFileModeUnbuffered - to indicate unbuffered mode.
    //    Default is buffered.
    //  - kAAFFileModeRevertable - to indicate that Revert is possible
    //    on this file (for all changes except those to essence).
    //  [in] aafUInt32  modeFlags,
    //
    //  Identification of the application which is modifying this file.
    //  [in] aafProductIdentification_t *  pIdent,
    //
    //  Pointer to buffer to receive pointer to new file.
    //  [out] IAAFFile ** ppFile);

cpp_quote("STDAPI AAFFileOpenExistingModify (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          aafProductIdentification_t *  pIdent,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileOpenNewModify()
  //
  // Creates an object associated with with a new
  // filesystem file that contains data which is to be read and
  // written.  Associates the given identification with it.
  // Does the following:
  // - Creates a new file in the filesystem with the given name.
  // - Opens the filesystem file for reading and writing.
  // - Associates this object with that filesystem file.
  // - Places this object into the Open state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within
  //   the file.
  //
  // Succeeds if:
  // - The pFileName argument is valid.
  // - The pIdent argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file does not exists in the filesystem.
  // - There is sufficient space in the filesystem to create the file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pFileName or pIdent pointer argument is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_EXISTS
  //   - The named file already exists in the filesystem.
  //
  // AAFRESULT_INSUFFICIENT_SPACE
  //   - There is insufficient space in the filesystem to create this
  //     file.
  // 
  // STDAPI AAFFileOpenNewModify (
    //  Null-terminated string containing name of filesystem file to be
    // opened for modification.  Filename must be in a form that would
    // be acceptable to StgOpenStorage() for this platform.
    //  [in, string] aafCharacter_constptr  pFileName,
    //
    //  File open mode flags.  May be any of the following ORed together.
    // All other bits must be set to zero.
    //  - kAAFFileModeUnbuffered - to indicate unbuffered mode.
    //    Default is buffered.
    //  - kAAFFileModeRevertable - to indicate that Revert is possible
    //    on this file (for all changes except those to essence).
    //  [in] aafUInt32  modeFlags,
    //
    //  Identification of the application which is creating this file.
    //  [in] aafProductIdentification_t *  pIdent,
    //
    //  Pointer to buffer to receive pointer to new file.
    //  [out] IAAFFile ** ppFile);

cpp_quote("STDAPI AAFFileOpenNewModify (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          aafProductIdentification_t *  pIdent,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileOpenTransient()
  //
  // Creates an object associated with with a transient file,
  // meaning that it is not associated with any filesystem file but
  // may still be used to contain AAF objects as if it was associated
  // with a filesystem file.  Associates the given identification with
  // this file.
  //
  // Transient files are never considered Revertable.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - The pIdent argument is valid.
  // - This object is currently closed.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_ALREADY_OPEN
  //   - This object is already open.
  //
  // AAFRESULT_NULL_PARAM
  //   - the pIdent pointer argument is NULL.
  // 
  // STDAPI AAFFileOpenTransient (
    // Identification which is to be associated with this file.
    // [in] aafProductIdentification_t *  pIdent,
    //
    // Pointer to buffer to receive pointer to new file.
    // [out] IAAFFile ** ppFile);

cpp_quote("STDAPI AAFFileOpenTransient (")
cpp_quote("          aafProductIdentification_t *  pIdent,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileIsAAFFile()
  //
  // Is the named file an AAF file ?
  //
  // Note that the function result is returned via the pFileIsAAFFile argument.
  // If this function succeeds it returns AAFRESULT_SUCCESS even if the named
  // file is not an AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - at least one of the pointer arguments is NULL.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - the file named by pFileName cannot be found.
  // 
  // STDAPI AAFFileIsAAFFile (
    //  Null-terminated string containing name of filesystem file.
    //  [in, string] aafCharacter_constptr  pFileName,
    //
    //  Pointer to an AUID indicating the file kind
    //  [out] aafUID_t *  pAAFFileKind,
    //
    //  Returns AAFTrue if the given file is an AAF file, returns AAFFalse otherwise.
    //  [out,retval] aafBool *  pFileIsAAFFile);

cpp_quote("STDAPI AAFFileIsAAFFile (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUID_t *  pAAFFileKind,")
cpp_quote("          aafBool *  pFileIsAAFFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFGetPluginManager()
  //
  // Returns an interface of the plugin manager, which is used to
  // select plugins for exporting.
  // 
  // STDAPI AAFGetPluginManager (
    // Pointer to the interface of the plugin manager.
    // [out] IAAFPluginManager ** ppPluginManager);

cpp_quote("STDAPI AAFGetPluginManager (IAAFPluginManager ** ppPluginManager);")
cpp_quote("")


  //***********************************************************
  //
  // AAFCreateRawStorageMemory()
  //
  // Create a raw storage providing a built-in implementation of
  // IAAFRawStorage on memory.
  //
  // This is considered a value-added function since clients could
  // actually create their own.
  //
  // Succeeds if:
  // - The ppNewRawStorage pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppNewRawStorage arg is NULL.
  // 
  // STDAPI AAFCreateRawStorageMemory (
    // Governs whether stream may be read from and/or written
    // to.
    // [in] aafFileAccess_t  access,
    //
    // Newly created storage
    // [out] IAAFRawStorage ** ppNewRawStorage);

cpp_quote("STDAPI AAFCreateRawStorageMemory (")
cpp_quote("          aafFileAccess_t  access,")
cpp_quote("          IAAFRawStorage ** ppNewRawStorage);")
cpp_quote("")


  //***********************************************************
  //
  // AAFCreateRawStorageDisk()
  //
  // Create a raw storage providing a built-in implementation of
  // IAAFRawStorage on a file on disk.
  //
  // Note that it is illegal to specify existence and access as "New"
  // "Read".
  //
  // This is considered a value-added function since clients could
  // actually create their own.
  //
  // Succeeds if:
  // - The pFilename pointer is valid.
  // - The ppNewRawStorage pointer is valid.
  // - If the open mode is one of read, write, or modify.
  // - If the file existence is one of new or existing.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilename or ppNewRawStorage arg is NULL.
  //
  // AAFRESULT_WRONG_OPENMODE
  // - If none of read, modify, or write are specified as open
  //   mode, or if neither new or existing is specified for the
  //   existence.
  // 
  // STDAPI AAFCreateRawStorageDisk (
    //  Name of file to be associated with this storage
    //  [in] aafCharacter_constptr  pFilename,
    //
    //  Governs whether storage is on pre-existing data, or is
    //  newly created.
    //  [in] aafFileExistence_t  existence,
    //
    //  Governs whether stream may be read from and/or written
    //  to.
    //  [in] aafFileAccess_t  access,
    //
    //  Newly created storage
    //  [out] IAAFRawStorage ** ppNewRawStorage);

cpp_quote("STDAPI AAFCreateRawStorageDisk (")
cpp_quote("          aafCharacter_constptr  pFilename,")
cpp_quote("          aafFileExistence_t  existence,")
cpp_quote("          aafFileAccess_t  access,")
cpp_quote("          IAAFRawStorage ** ppNewRawStorage);")
cpp_quote("")


  //***********************************************************
  //
  // AAFCreateAAFFileOnRawStorage()
  //
  // Given an IAAFRawStorage, create an IAAFFile.  If pRawStorage is
  // actually an IAAFRandomRawStorage, the created file will be an
  // IAAFRandomFile.
  //
  // Note that AAF files based on Binary Structured Storage will
  // require the underlying IAAFRawStorage to be at least readable,
  // even in the case of write-only AAF files.
  //
  // Note also that only the following combinations of access and
  // existence are legal:
  //
  // existence   access   Legal?
  // ---------   ------   ------
  // existing    read     yes
  // existing    write    no
  // existing    modify   yes
  //   new       read     no
  //   new       write    yes
  //   new       modify   yes
  //
  // This method will succeed if the following are true:
  // - The pRawStorage pointer is valid.
  // - The ppNewFile pointer is valid.
  // - The accessibility of the specified raw storage matches that of
  //   the desired AAF File; additionally, if the file kind is
  //   Structured Storage Binary, the raw storage is also required to
  //   be at least readable. 
  // - A legal combination of existence and access flags is given.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pRawStorage or ppNewFile arg is NULL.
  //
  // AAFRESULT_NOT_READABLE
  // - The access parameter specifies readability or if this file is
  //   Binary Structured Storage, but the specified raw storage is
  //   not readable.
  //
  // AAFRESULT_NOT_WRITEABLE
  // - The access parameter specifies writeability but the specified
  //   raw storage is not writeable.
  //
  // AAFRESULT_NULL_PARAM
  // - existence is new, and pFileKind is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  // - The access or existence parameters are not set to a legal
  //   combination of values.
  // 
  // STDAPI AAFCreateAAFFileOnRawStorage (
    //  storage to be associated with this file
    //  [in] IAAFRawStorage *  pRawStorage,
    //
    //  Governs whether storage is on pre-existing data, or is
    //  newly created.
    //  [in] aafFileExistence_t  existence,
    //
    //  Governs whether stream may be read from and/or written
    //  to.
    //  [in] aafFileAccess_t  access,
    //
    //  kind of file to be created; only used for new files
    //  [in] aafUID_constptr  pFileKind,
    //
    //  File mode flags
    //  [in] aafUInt32  modeFlags,
    //
    //  Identification to be associated with this file; only
    //  used for new files
    //  [in] pFileKind  pIdent,
    //
    //  newly-created file
    //  [out] ImodeFlags ** ppNewFile);

cpp_quote("STDAPI AAFCreateAAFFileOnRawStorage (")
cpp_quote("          IAAFRawStorage *  pRawStorage,")
cpp_quote("          aafFileExistence_t  existence,")
cpp_quote("          aafFileAccess_t  access,")
cpp_quote("          aafUID_constptr  pFileKind,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          aafProductIdentification_constptr  pIdent,")
cpp_quote("          IAAFFile ** ppNewFile);")
cpp_quote("")


