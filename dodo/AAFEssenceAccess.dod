#startm .this-module 0
AAFMedia\
#endm
#c
#import ./AAFObject.exp
AD_HEAD
/******************************************\
*                                          *
* Advanced Authoring Format                *
*                                          *
* Copyright (c) 1998 Avid Technology, Inc. *
* Copyright (c) 1998 Microsoft Corporation *
*                                          *
\******************************************/

AD_FORWARD_DECLARATION(AAFDataDef)
AD_FORWARD_DECLARATION(AAFMasterMob)
AD_FORWARD_DECLARATION(AAFSourceMob)
AD_FORWARD_DECLARATION(AAFSourceClip)

AD_CLASS_UUID(aed97eb1, 2bc8, 11D2, bf, aa, 00, 60, 97, 11, 62, 12)

AD_DEFAULT_UUID(aed97eb0, 2bc8, 11D2, bf, aa, 00, 60, 97, 11, 62, 12)

AD_ROOT_CLASS_BEGIN

/****/
AD_XMETHOD7(AudioMediaCreate,
[in],objIn, AAFMasterMob,masterMob,on this master mob,
[in],objPass, aafTrackID_t,masterTrackID,,
[in],objIn, AAFSourceMob,fileMob,and this file mob create audio,
[in],objPass, aafRational_t,samplerate,with this sample rate,
[in],objPass, aafCompressEnable_t,enable,optionally compressing it,
[in],objPass, aafInt16,sampleSize,with this sample size,
[in],objPass, aafInt16,obj,and this many channels,
Creates an audio media stream.)
//@comm Creates either a single stream of audio media, or interleaved
// audio-only data.  A separate call (MediaMultiCreate) exists 
// in order to create interleaved audio and video data.
// 
//@comm The media handle from this call can be used with
// WriteDataSamples or WriteMultiSamples but NOT with 
// or WriteDataLines.
// 
// Argument Notes:
//@comm If you are creating the media, and then attaching it to a master
// mob, then the "masterMob" field may be left NULL.
// 
//@comm The numChannels field refers to the number of interleaved
// channels on a single data stream.  
// 
//@comm The sample rate should be the actual samples per second, not the
// edit rate.
//@comm omfmAudioMediaCreate

/****/
AD_XMETHOD9(VideoMediaCreate,
[in],objIn, AAFMasterMob,masterMob,on this master mob,
[in],objPass, aafTrackID_t,masterTrackID,masterTrackID,
[in],objIn, AAFSourceMob,fileMob,and this file mob create video,
[in],objPass, aafCompressEnable_t,enable,optionally compressing it,
[in],objPass, aafRational_t,editrate,editrate,
[in],objPass, aafUInt32,StoredHeight,with this height,
[in],objPass, aafUInt32,StoredWidth,and this width,
[in],objPass, aafFrameLayout_t,layout,and this frame layout.,
[in],objPass, aafRational_t,ratio,image aspect ratio,
Creates an audio media stream.)
//@comm Creates a single stream of video media.  A separate call
// (MediaMultiCreate) exists to create interleaved audio and
// video data.
//@comm The media handle from this call can be used with
// WriteDataSamples or WriteDataLines, but NOT with
// WriteMultiSamples.
//@comm If you are creating the media, and then attaching it to a master
// mob, then the "masterMob" field may be left NULL.
//@comm The storedHeight and storedWidth are the dimensions of the frame
// as stored on disk (or as it should be restored by the codec.  The
// displayRect and sampledRect are set to:
// 	(0,0 @ sampledWidth, sampledHeight).
//@comm If the displayed rectangle is not the same as the stored rectangle
// (as with the old leadingLines and trailingLines), then you should
// call SetDisplayRect().
//@comm The frame layout contains the number of fields and whether they are
// interlaced, but does not specify field dominance.
//@comm Replaces omfmVideoMediaCreate

/****/
AD_XMETHOD6(Create,
[in],objIn, AAFMasterMob,masterMob,on this master mob,
[in],objPass, aafTrackID_t,masterTrackID,,
[in],objIn, AAFSourceMob,fileMob,and this file mob,
[in],objIn, AAFDataDef,mediaKind,create media of this type,
[in],objPass, aafRational_t,samplerate,with this sample rate,
[in],objPass, aafCompressEnable_t,enable,optionally compressing it,
Creates a single channel stream of media.)
	//@comm Creates a single channel stream of media.  Convenience functions
	// exist to create audio or video media, and a separate call
	// (MultiCreate) exists to create interleaved audio and
	// video data.
	//@comm The media handle from this call can be used with
	// WriteDataSamples  and possibly WriteDataLines, but NOT with
	// WriteMultiSamples.
	//@comm If you are creating the media, and then attaching it to a master
	// mob, then the "masterMob" field may be left NULL.
	// For video, the sampleRate should be the edit rate of the file mob.
	// For audio, the sample rate should be the actual samples per second.
	//@comm Replaces omfmMediaCreate
	
/****/
AD_XMETHOD6(MultiCreate,
[in],objIn, AAFMasterMob,masterMob,on this master mob,
[in],objIn, AAFSourceMob,fileMob,and this file mob create,
[in],objPass, aafInt16,arrayElemCount,this many channels,
[in\,ref\,size_is\(arrayElemCount\)],objPass, aafmMultiCreate_t *,mediaArray,using these definitions,
[in],objPass, aafRational_t ,editRate,,
[in],objPass, aafCompressEnable_t,enable,optionally compressing it,
Creates a multi-channel interleaved stream of media.)
	//@comm The media handle from this call can be used with
	// WriteDataSamples or WriteMultiSamples but NOT with 
	// or WriteDataLines.
	//@comm If you are creating the media, and then attaching it to a master
	// mob, then the "masterMob" field may be left NULL.
	//@comm Replaces omfmMediaMultiCreate
	
/****/
AD_METHOD1(SetBlockingSize,
[in],aafInt32,numBytes,Preallocate this many bytes,
Sets the size of chunks allocated on disk during writes [only].)
	//@comm Allocating the space in this fashion ensures that the data will be
	// contiguous on disk (for at least numBytes bytes) even if other
	// disk operations allocate space on the disk.  If the data written
	// exceeds numBytes, then another disk block of numBytes size will be
	// allocated.
	//@comm Takes a media handle, so the media must have been opened or created.
	// The space is allocated in terms of bytes.
	//@comm Replaces omfmSetBlockingSize

/****/
AD_METHOD2(SetVideoLineMap,
[in],aafInt16,startLine,set this starting video line,
[in],aafFieldTop_t,type,and this top field,
Sets the video line map structure used by the codecs to deinterlace fields.)
	//@comm Takes a media handle, so the media must have been opened or created.
	//@comm Replaces omfmSetVideoLineMap.

/****/
AD_METHOD1(GetVideoTopField,
[out],aafFieldTop_t *,type,and this top field,
Gets the top video field used by the codecs to deinterlace fields.)
	//@comm Takes a media handle, so the media must have been opened or created.
	//@comm Replaces omfmGetVideoTopField
	
/****/
AD_METHOD1(SetDisplayRect,
[in\\\,ref],aafRect_t *,DisplayRect,set display rectangle,
Handles the case where the displayed rectangle is not the same as the stored rectangle [as with the old leadingLines and trailingLines])
	//@comm Handles the case where the displayed rectangle is not the same as
	// the stored rectangle (as with the old leadingLines and trailingLines).
	// A positive "leadingLines" (from 1.5) becomes a positive yOffset, and
	// decreases the display height.
	// A positive "trailingLines" (from 1.5) also decreases the display height.
	//@comm Takes a media handle, so the media must have been opened or created.
	//@comm Replaces  omfmSetDisplayRect

/****/
AD_METHOD1(SetSampledRect,
[in\\\,ref],aafRect_t *,SampledRect,set sampled rectangle,
Handles the case where the sampled rectangle is not the same as the stored rectangle.)
	//@comm Takes a media handle, so the media must have been opened or created
	//@comm Replaces omfmSetSampledRect
	
/****/
AD_METHOD2(WriteMultiSamples,
[in],aafInt16,arrayElemCount,Do this many transfers,
[out\\\,size_is\\\(arrayElemCount\\\)],aafmMultiXfer_t *,xferArray,referencing this array,
Writes multiple channels worth of sample data to an interleaved data stream in the natural order for the CODEC.)
	//@comm arrayElemCount is the size of the array or transfer operations.
	// xferArray points to an array of transfer parameters.  All fields
	// in this array except for bytesXferred must be set up before
	// doing the transfer.
	//@comm Replaces omfmWriteMultiSamples

/****/
AD_METHOD3(WriteDataSamples,
[in],aafInt32,nSamples,write this many samples,
[in\\\,size_is\\\(buflen\\\)],aafDataBuffer_t,buffer,to a buffer,
[in],aafInt32,buflen,of this size,
Writes data to a single-channel media stream.)
	//@comm Takes a media handle, so the media must have been opened or created.
	// A single video frame is ONE sample.
	// Buflen must be large enough to hold nSamples * the maximum sample size.
	//@comm Possible Errors:
	// Standard errors (see top of file).
	// OM_ERR_SINGLE_CHANNEL_OP -- Tried to write to an interleaved stream.
	// OM_ERR_BADDATAADDRESS -- The buffer must not be a NULL pointer.
	//@comm Replaces omfmWriteDataSamples

/****/
AD_METHOD3(WriteRawData,
[in],aafInt32,nSamples,write this many samples,
[in\\\, size_is\\\(nSamples * sampleSize\\\)],aafDataBuffer_t,buffer,to a buffer,
[in],aafInt32, sampleSize,of this size,
Writes pre-interleaved data to a media stream.)
	//@comm A single video frame is ONE sample.
	//@comm Buflen must be large enough to hold
	// nSamples * the maximum sample size.
	//@comm Possible Errors:
	// Standard errors (see top of file).
	// OM_ERR_BADDATAADDRESS -- The buffer must not be a NULL pointer.
	//@comm Replaces omfmWriteRawData
	
/****/
AD_METHOD5(ReadRawData,
[in],aafInt32,nSamples,write this many samples,
[in],aafUInt32,buflen,to a buffer of this size,
[out\\\, size_is\\\(buflen\\\)\\\, length_is\\\(*bytesRead\\\)],aafDataBuffer_t,buffer,here is the buffer,
[out\\\,ref],aafUInt32 *,bytesRead,,
[out\\\,ref],aafUInt32 *,samplesRead,,
Read pre-interleaved data from a media stream.)
	//@comm A single video frame is ONE sample.
	//@comm Buflen must be large enough to hold nSamples * the maximum sample size.
	//@comm Possible Errors:
	// Standard errors (see top of file).
	// OM_ERR_BADDATAADDRESS -- The buffer must not be a NULL pointer.
	//@comm Replaces omfmReadRawData
	
/****/
AD_METHOD4(WriteDataLines,
[in],aafUInt32,nLines,write this many lines on video,
[in], aafUInt32, nBytesPerLine, ,
[in\\\, size_is\\\(nLines * nBytesPerLine\\\)],aafDataBuffer_t,buffer,from a buffer,
[out\\\,ref],aafInt32 *,bytesWritten,of this size,
Writes single lines of video to a file.)
	//@comm Writes single lines of video to a file.  This function allows writing
	// video frames in pieces, for low-memory situations.  When enough lines
	// have been written to constitute a frame, then the number of samples will
	// be incremented by one.
	//@comm This function works only for video media.
	//@comm The buffer must be large enough to hold an entire line of video. 
	//@comm Possible Errors:
	// Standard errors (see top of file).
	// OM_ERR_BADRWLINES -- This function only works for video media.
	//@comm Replaces omfmWriteDataLines
	//@devnote Previous version did not have nBytesPerLine, otherwise the actual size
	// of the buffer cannot be known.
	
/****/
AD_METHOD0(Close,Finish operations on media data and close any external files opened or created to hold the media..)
	//@comm This function should be called whether the media was opened or created.
	//@comm Replaces omfmMediaClose

/****/
AD_METHOD7(SetJPEGTables,
[in],aafJPEGcomponent_t,JPEGcomp,change this component,
[in],aafUInt8 *,QTables,to have these Q-tables,
[in],aafUInt8 *,ACTables,and these AC-tables,
[in],aafUInt8 *,DCTables,and these DC-tables,
[in],aafInt16,QTableSize,size in bytes,
[in],aafInt16,ACTableSize,size in bytes,
[in],aafInt16,DCTableSize,size in bytes,
Sets the Q  AC and DC tables for the next frame to be compressed.)
	//@comm This function needs to be called once for each component of the video.
	//@comm Replaces omfmSetJPEGTables
	
/****/
AD_METHOD1(SetAudioBlockLength,
[in],aafInt16,blockLength,the block length,
Set common audio compression parms.)
	//@comm Replaces omfmSetAudioCompressParms
/****/
AD_METHOD1(GetAudioBlockLength,
[out],aafInt16*,blockLength,the block length,
Get common audio compression parms.)
	//@comm Replaces omfmGetAudioCompressParms
	
/****/
AD_METHOD2(SetPrivateMediaData,
[in],aafUInt32,parmBlockSize,a block of this size,
[in\\\,size_is\\\(parmBlockSize\\\)], aafDataBuffer_t,ParameterBlock,with these values,
Sends a parameter block of private information to the CODEC for this media.)
	//@parm IN -- .
	//@comm The parameter block should be defined in the
	// "h" file of the codec, and must be included by the application in
	// order to use this call.
	//@comm NOTE: All CODECs should default to reasonable parameters,
	// in case the application doesn't know about a given codec.
	//@comm Replaces omfmCodecSendPrivateData*/

/****/
AD_METHOD2(GetPrivateMediaData,
[in],aafUInt32,blocksize,,
[out\\\, size_is\\\(blocksize\\\)], aafDataBuffer_t, buffer,,
Gets a parameter block of private information from the CODEC for this media.)
	//@comm The parameter block should be defined in the
	// "h" file of the codec, and must be included by the application in
	// order to use this call.
	//@comm NOTE: All CODECs should default to reasonable parameters,
	// in case the application doesn't know about a given codec.
	//@comm Replaces omfmGetPrivateMediaData*/
	//@devnote Added bytesRead 

/****/
AD_XMETHOD5(GetNumChannels,
[in],objIn, AAFMasterMob,masterMob,In this master mob,
[in],objPass, aafTrackID_t,trackID,On this track,
[in],objPass, aafMediaCriteria_t*,mediaCrit,using this media criteria,
[in],objIn, AAFDataDef,mediaKind,for this media type,
[out],objPass, aafInt16*,numCh,How many channels?,
Takes an opaque handle  a master mob reference  and a track ID so that it may be called before the media is opened.)
	//@comm Returns the number of interleaved media channels of a given type in the media stream referenced by the given file mob
	//@comm If the data format is not interleaved, then the answer will
	// always be zero or one.  This function correctly returns zero
	// for media types not handled by a given codec, and handles codecs
	// which work with multiple media types.
	//@comm Replaces omfmGetNumChannels*/

/****/
AD_XMETHOD2(GetLargestSampleSize,
[in],objIn, AAFDataDef,mediaKind,and this media type,
[out],objPass, aafInt32*,maxSize,the largest sample size,
Returns the size in bytes of the largest sample for a given media type.)
	//@comm For uncompressed data, or the output of the software codec,
	// the sample size will propably be a constant.
	//@comm The media type parameter exists to support codecs with multiple
	// interleaved media types.
	//@comm Replaces omfmGetLargestSampleSize*/

/****/
AD_XMETHOD3(GetSampleFrameSize,
[in],objIn, AAFDataDef,mediaKind,and this media type,
[in],objPass, aafPosition_t,frameNum,for this [1-based] sample frame number,
[out],objPass, aafLength_t*,frameSize,How big is the sample frame?,
Returns the size in bytes of the given sample for a given media type.)
	//@comm For uncompressed data, or the output of the software codec,
	// the sample size will propably be a constant.
	//@comm The media type parameter exists to support codecs with multiple
	// interleaved media types.
	//@comm Possible Errors:
	// 	Standard errors (see top of file).
	// 	OM_ERR_NULL_PARAM -- A return parameter was NULL.
	//@comm Replaces omfmGetSampleFrameSize*/

/****/
AD_XMETHOD5(Open,
[in],objIn, AAFMasterMob,masterMob,In this master mob,
[in],objPass, aafTrackID_t,trackID,On this track,
[in],objPass, aafMediaCriteria_t*,mediaCrit,using this media criteria,
[in],objPass, aafMediaOpenMode_t,openMode,ReadOnly or Append,
[in],objPass, aafCompressEnable_t,compEnable,optionally decompressing,
Opens a single channel of a file mob.)
	//@comm If the media is interleaved,
	// then it will be di-interleaved when samples are read.  This routine
	// follows the locator, and may call the locator failure callback if
	// the media can not be found.  If the failure callback finds the media,
	// then this routine will return normally.
	//@comm The media handle from this call can be used with
	// ReadDataSamples  and possibly ReadDataLines, but NOT with
	// ReadMultiSamples.
	//@comm Possible Errors:
	// 	Standard errors (see top of file).
	// 	OM_ERR_NOMEMORY -- couldn't allocate memory for the media handle
	//@comm NOTE: If a locator is followed, then mediaPtr may reference ANOTHER file
	// object, which must be closed on file close.
	//@comm Replaces omfmMediaOpen*/
	
/****/
AD_XMETHOD5(MultiOpen,
[in],objIn, AAFMasterMob,masterMob,In this master mob,
[in],objPass, aafTrackID_t,trackID,On this track,
[in],objPass, aafMediaCriteria_t*,mediaCrit,using this media criteria,
[in],objPass, aafMediaOpenMode_t,openMode,ReadOnly or Append,
[in],objPass, aafCompressEnable_t,compEnable,optionally decompressing,
Opens a all channels associated with a file mob.)
	//@comm This routine
	// follows the locator, and may call the locator failure callback if
	// the media can not be found.  If the failure callback finds the media,
	// then this routine will return normally.
	//@comm The media handle from this call can be used with
	// WriteDataSamples or WriteMultiSamples but NOT with 
	//  WriteDataLines.
	//@comm Possible Errors:
	// 	Standard errors (see top of file).
	// 	OM_ERR_NOMEMORY -- couldn't allocate memory for the media handle
	//@comm Replaces omfmMediaMultiOpen*/

/****/
AD_METHOD1(SetVideoMemFormat,
[in],aafVideoMemOp_t*,op,,
Sets the video memory format and layout expected in memory.)
	//@comm This is the format expected on writes and produced on reads.
	//@comm On writes, the data will be written in this format, except
	// where a software codec may be used.
	// On reads, the data will be translated to this format.
	//@comm The current CODECs should support rgb888 and YUV as formats
	// and all of the standard layouts.  A special format of
	// kVmFmtStd says to use the file's native format & layout.
	//@comm Replaces omfmSetVideoMemFormat*/

/****/
AD_METHOD1(SetAudioMemFormat,
[in],aafAudioMemOp_t*,op,,
Sets the audio memory format expected in memory.)
	//@comm This is the format expected on writes and produced on reads.
	//@comm On writes, the data will be written in this format, except
	// where a software codec may be used.
	// On reads, the data will be translated to this format.
	//@comm The current CODECs should support different sample sizes and rates
	// A special format of kAmFmtStd says to use the file's native
	// size and rate.
 	//@comm Replaces omfmSetAudioMemFormat

/****/
AD_METHOD1(GetDisplayRect,
[out],aafRect_t*,result,Get the display rectangle,
Returns the display rectangle for the current video media.)
	//@comm Handles the case where the displayed rectangle is not the same as
	// the stored rectangle (as with the old leadingLines and
	// trailingLines).<nl>
	// A positive "leadingLines" (from 1.5) becomes a positive yOffset, and
	// decreases the display height.<nl>
	// A positive "trailingLines" (from 1.5) also decreases the display
	// height.
	//@comm Takes a media handle, so the media must have been opened or
	// created.
	//@comm Possible Errors:
	// Standard errors (see top of file).
	//   OM_ERR_NULL_PARAM -- A NULL rectangle pointer.
	//   OM_ERR_INVALID_OP_CODEC -- This codec doesn't support display rect
	//								(may not be video media)
 	//@comm Replaces omfmGetDisplayRect

/****/
AD_METHOD1(GetSampledRect,
[out],aafRect_t*,result,Get the sampled rectangle,
Returns the sampled rectangle for the current video media.)
	//@comm Takes a media handle, so the media must have been opened or created.
	//@comm Possible Errors:<nl>
	//   OM_ERR_NULL_PARAM -- A NULL rectangle pointer.<nl>
	//   OM_ERR_INVALID_OP_CODEC -- This codec doesn't support display rect<nl>
	//   							(may not be video media)
 	//@comm Replaces omfmGetSampledRect

/****/
AD_METHOD1(GetSampleCount,
[out],aafLength_t *,result,,
Returns the number of samples on the given media stream.)
	//@comm A video sample is one frame.
	//@comm Replaces omfmGetSampleCount

/****/
AD_METHOD4(ReadDataSamples,
[in],aafInt32,nSamples,,
[in],aafInt32,buflen,,
[out\\\, size_is\\\(buflen\\\)\\\,length_is\\\(*bytesRead\\\)],aafDataBuffer_t,buffer,,
[out\\\,ref],aafUInt32*,bytesRead,,
Read a given number of samples from an opened media stream.)
	//@comm This call will only return a single channel of media from an interleaved
	// stream.
	//@comm A video sample is a frame.
	// Buflen is in bytes, and should be large enough to hold the samples
	// in the requested memory format.
	//@comm Replaces omfmReadDataSamples

/****/
AD_METHOD2(ReadMultiSamples,
[in],aafInt16,elemCount,,
[out\\\, size_is\\\(elemCount\\\)],aafmMultiXfer_t *,xferArray,,
Reads one or more channels from an interleaved data stream)
	//@comm arrayElemCount is the size of the array or transfer operations.
	// xferArray points to an array of transfer parameters.  All fields
	// in this array except for bytesXferred must be set up before
	// doing the transfer.
	//@comm Replaces omfmReadMultiSamples
	
/****/
AD_METHOD4(ReadDataLines,
[in],aafInt32,nLines,,
[in],aafInt32,bufLen,,
[out\\\, size_is\\\(bufLen\\\)\\\,length_is\\\(*bytesRead\\\)],aafDataBuffer_t,buffer,,
[out\\\,ref],aafInt32*,bytesRead,,
Reads single lines of video from a file.)
	//@comm This function allows reading
	// video frames in pieces, for low-memory situations.  When enough lines
	// have been read to constitute a frame, then the number of samples read
	// be incremented by one.
	//@comm The buffer must be large enough to hold an entire line of video.
	//@comm This function works only for video media.
	//@comm Replaces omfmReadDataLines

/****/
AD_METHOD1(GotoFrameNumber,
[in],aafInt64,frameNum,,
The seek function for media.)
	//@comm Useful only on reading, you
	// can't seek aound while writing media.
	//@comm An audio frame is one sample across all open channels.
	//@comm Replaces omfmGotoFrameNumber

/****/
AD_METHOD6(GetVideoInfo,
[out],aafFrameLayout_t *,layout,,
[out],aafInt32 *,fieldWidth,,
[out],aafInt32 *,fieldHeight,,
[out],aafRational_t *,editrate,,
[out],aafInt16 *,bitsPerPixel,,
[out],aafPixelFormat_t *,defaultPixelFmt,,
Get video-related information about a given piece of media data.)
	//@comm Any parameters not required may have the pointers set to NULL.
	//@comm Possible Errors:<nl>
	// Standard errors (see top of file).<nl>
	// OM_ERR_WRONG_MEDIATYPE -- Not video media.<nl>
	//@comm Replaces omfmGetVideoInfo */
			
			
/****/
AD_METHOD1(GetVideoInfoArray,
[out],aafVideoMemOp_t*,ops,,
Given an array of video format blocks  read the opcodes and fill in the operands from the file format.)
	//@comm Replaces omfmGetVideoInfoArray */

/****/
AD_METHOD1(PutVideoInfoArray,
[in],aafVideoMemOp_t*,ops,,
Given an array of video format blocks  read the opcodes and operands and change the file format.)
	//@comm Replaces omfmPutVideoInfoArray */

/****/
AD_XMETHOD3(GetNumRepresentations,
[in],objIn, AAFMasterMob,masterMob,,
[in],objPass, aafTrackID_t,trackID,,
[out],objPass, aafInt32*,numReps,,
Find out how many media representations [high/low res] exist for a particular track on this master mob.)
	//@comm Replaces omfmGetNumRepresentations */

/****/
AD_XMETHOD4(GetRepresentationSourceClip,
[in],objIn, AAFMasterMob,masterMob,,
[in],objPass, aafTrackID_t,trackID,,
[in],objPass, aafInt32,index,,
[out],objOut, AAFSourceClip,sourceClip,,
Get the indexed [1-based] representation for a particular track on this master mob.)
	//@comm Replaces omfmGetRepresentationSourceClip */

/****/
AD_METHOD3(GetAudioInfo,
[out],aafRational_t*,rate,,
[out],aafInt32*,sampleSize,,
[out],aafInt32*,numChannels,,
Get audio-related information about a given piece of media data.)
	//@comm Any parameters not required may have the pointers set to NULL.
	//@comm Possible Errors:<nl>
	//	Standard errors (see top of file).<nl>
	//	OM_ERR_WRONG_MEDIATYPE -- Not video media.
	//@comm Replaces omfmGetAudioInfo */


/****/
AD_METHOD1(GetAudioInfoArray,
[out],aafAudioMemOp_t *,ops,,
Given an array of audio format blocks read the opcodes and fill in the operands from the file format.)
	//@comm Replaces omfmGetAudioInfoArray */

/****/
AD_METHOD1(PutAudioInfoArray,
[in],aafAudioMemOp_t*,ops,,
Given an array of audio format blocks read the opcodes and operands and change the file format.)

/****/
AD_XMETHOD3(IsHardwareAssistedCodec,
[in],objPass, aafCodecID_t,codecID,,
[in],objIn, AAFSourceMob,mob,,
[out],objPass, aafBool*,result,,
Tells if the given codec is hardware-assisted.)
	//@comm That is, does
	// it contain calls to a particular hardware device which speeds
	// up transfer and compression/decompression.
	//@comm If the hardware is not present in the system, this call should
	// return FALSE.
	//@comm If the parameters in the media descriptor are out-of-bounds
	// for the hardware, then this call will return FALSE.
	//@comm Replaces omfmIsHardwareAssistedCodec */

/****/
AD_METHOD3(GetCodecName,
[in],aafCodecID_t,codecID,,
[in],aafInt32,namelen,,
[out\\\,size_is\\\(namelen\\\)],aafUInt8 *,name,,
Returns the full name of the given codec expanded for human consumption.)
	//@comm No other call uses this name, so it may be fully descriptive, esp. of limitations.
	//@comm The name will be truncated to fit within "buflen" bytes.
	//@comm Possible Errors:<nl>
	// 	Standard errors (see top of file).<nl>
	//	OM_ERR_CODEC_INVALID - The given codec ID is not loaded.
	//@comm Replaces omfmCodecGetName */
	//@devnote Shouldn't we use a unicode aafString_t since AAF's public interface for
	// strings is supposed to be unicode?(TomR)

/****/
AD_METHOD1(GetCodecID,
[out],aafCodecID_t*,codecID,,
Returns the codec ID being used to handle the specified media.)
	//@comm This will be required in order to send private data to the codec.
	//@comm The name will be truncated to fit within "buflen" bytes.
	//@comm Replaces omfmMediaGetCodecID */

/****/
AD_METHOD1(AddFrameIndexEntry,
[in],aafInt64,frameOffset,add a frame offset to it's frame index,
Adds a frame index entry for media which was added precompressed.)
	//@comm This function should NOT be called when media is passed to the toolkit
	// in an uncompressed format.
	//@comm Possible Errors:<nl>
	//	Standard errors (see top of file).<nl>
	//	OM_ERR_INVALID_OP_CODEC -- This kind of media doesn't have a frame index<nl>
	//	OM_ERR_MEDIA_OPENMODE -- The media is open for read-only.
	//@comm Replaces omfmAddFrameIndexEntry */

/****/
AD_METHOD1(SetStreamCacheSize,
[in],aafUInt32,cacheSize,make the cache this many bytes long,
Set the size of the cache buffer used for media transfers.)
	//@comm Replaces omfmSetStreamCacheSize */

/****/
AD_METHOD1(SourceGetVideoSignalType,
[out],aafVideoSignalType_t*,signalType,,
Get the video signal type [NTSC/PAL/SECAM].)
	//@comm Replaces omfmSourceGetVideoSignalType */

AD_ROOT_CLASS_END
