#c /******************************************\
#c *                                          *
#c * Advanced Authoring Format                *
#c *                                          *
#c * Copyright (c) 1998 Avid Technology, Inc. *
#c * Copyright (c) 1998 Microsoft Corporation *
#c *                                          *
#c \******************************************/



#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#c
#c AutoDodo macro file for use in generating COM unit test
#c implementation files.
#c
#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


#import macros/base.mac


#ccccccccccccccccccccccccccc
#c
#c Goes at the head of the file.
#c
#c Arguments: none
#c
#startm AD_HEAD 00
// @doc INTERNAL
// @com This file implements the module test for CAAFDefinitionObject
/******************************************\\
*                                          *
* Advanced Authoring Format                *
*                                          *
* Copyright (c) 1998 Avid Technology, Inc. *
* Copyright (c) 1998 Microsoft Corporation *
*                                          *
\\******************************************/
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_BEGIN 00
#include "C.this-module.h"
#include "C.this-module.h"
#ifndef __C.this-module_h__
#error - improperly defined include guard
#endif


#include <iostream.h>

// Temporarily necessary global declarations.
extern "C" const CLSID CLSID_.this-module; // generated


HRESULT C.this-module::test()
{
  HRESULT hr = AAFRESULT_NOT_IMPLEMENTED;
  I.this-module *pObject = NULL;

  try
    {
      // Attempt to create an .this-module.
      hr =  CoCreateInstance(
                             CLSID_.this-module,
                             NULL, 
                             CLSCTX_INPROC_SERVER, 
                             IID_I.this-module, (void **)&pObject);
      if (FAILED(hr))
        {
          cerr << "C.this-module::test...FAILED!";
          cerr << hr;
          cerr << "\\tCoCreateInstance(&CLSID_.this-module, NULL,"
            " CLSCTX_INPROC_SERVER, &IID_I.this-module, ...);" <<
              endl;
          return hr;
        }

      // module-specific tests go here

      if (pObject)
        pObject->Release();
      return AAFRESULT_NOT_IMPLEMENTED;

    }
  catch (...)
    {
      cerr << "C.this-module::test...Caught general C++"
        " exception!" << endl; 
    }

  // Cleanup our object if it exists.
  if (pObject)
    pObject->Release();

  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT_CLASS_BEGIN 01
AD_CLASS_BEGIN\
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition with no parent class
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_BEGIN 00
#include "C.this-module.h"
#include "C.this-module.h"
#ifndef __C.this-module_h__
#error - improperly defined include guard
#endif


#include <iostream.h>

// Temporarily necessary global declarations.
extern "C" const CLSID CLSID_.this-module; // generated


HRESULT C.this-module::test()
{
  HRESULT hr = AAFRESULT_NOT_IMPLEMENTED;
  I.this-module *pObject = NULL;

  try
    {
      // Attempt to create an .this-module.
      hr =  CoCreateInstance(
                             CLSID_.this-module,
                             NULL, 
                             CLSCTX_INPROC_SERVER, 
                             IID_I.this-module, (void **)&pObject);
      if (FAILED(hr))
        {
          cerr << "C.this-module::test...FAILED!";
          cerr << hr; 
          cerr << "\\tCoCreateInstance(&CLSID_.this-module, NULL,"
            " CLSCTX_INPROC_SERVER, &IID_I.this-module, ...);" <<
              endl;
          return hr;
        }

      // module-specific tests go here

      if (pObject)
        pObject->Release();
      return AAFRESULT_NOT_IMPLEMENTED;

    }
  catch (...)
    {
      cerr << "C.this-module::test...Caught general C++"
        " exception!" << endl;
    }

  // Cleanup our object if it exists.
  if (pObject)
    pObject->Release();

  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Note that most macros are are unused, and simply have null bodies!
#c
#startm AD_IDL 01
#endm

#startm AD_INCLUDE 01
#endm

#startm AD_TYPES_BEGIN 11
#endm

#startm AD_TYPES_END 00
#endm

#startm AD_AAFTYPES 01
#endm

#startm AD_DECLARE_FORWARD_AAFTYPES 01
#endm

#startm AD_CPP_QUOTE 01
#endm

#startm AD_FORWARD_DECLARATION 01
#endm

#startm AD_CLASS_UUID 11
#endm

#startm AD_DEFAULT_UUID 11
#endm

#startm AD_TYPES_HEAD 00
#endm

#startm AD_METHOD0 02
#endm

#startm AD_XMETHOD1 07
#endm

#startm AD_XMETHOD2 12
#endm

#startm AD_XMETHOD3 17
#endm

#startm AD_XMETHOD4 22
#endm

#startm AD_XMETHOD5 27
#endm

#startm AD_XMETHOD6 32
#endm

#startm AD_XMETHOD7 37
#endm

#startm AD_XMETHOD8 42
#endm

#startm AD_XMETHOD9 47
#endm

#startm AD_XMETHOD_10 52
#endm

#startm AD_XMETHOD_11 57
#endm

#startm AD_X2METHOD3 20
#endm

#startm AD_X2METHOD4 26
#endm

#startm AD_X2METHOD5 32
#endm

#startm AD_CLASS_END 00
#endm

#startm AD_COM_EXT_CLASS_END 01
#endm

#startm AD_ROOT_CLASS_END 00
#endm

#startm AD_OVERRIDE 01
#endm

#startm AD_COM_METH 01
#endm

#startm AD_XCONSTRUCTOR1 06
#endm

#startm AD_XCONSTRUCTOR2 11
#endm

#startm AD_XCONSTRUCTOR3 16
#endm

#startm AD_XCONSTRUCTOR4 21
#endm

#startm AD_BEGIN_SESSION 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used for a container to create
#c its contained objects in the cpp API.
#c
#startm AD_STATIC_CREATE 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Hack to quote the .this-module macro and keep it out of export
#c files.  Do not define this macro in exp.mac!!!
#c
#startm AD_EXPORT_THIS_MODULE 00
.this-module\
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Argument1: Abstract or Concrete
#c Argument2: Transient or StoredObject
#c            special cases:CommonBase and StoredObjectBase
#c
#c Note: Concrete-StoredObject means Persistent. In other words
#c Concrete-StoredObject objects (and derived objects) are the 
#c only types of objects that should ever be found in an AAF
#c file.
#c
#c Valid combiniations:          examples
#c -----------------------       ---------------
#c   Abstract-CommonBase         AAFRoot 
#c   Abstract-Transient          ????
#c   Abstract-StoredObjectBase   AAFObject
#c   Abstract-StoredObject       AAFSourceReference, AAFComponent, ...
#c   Concrete-Transient          EnumAAFMobs, EnumAAFMobSlots, ...
#c   Concrete-StoredObject       AAFSegment, AAFSourceClip, ...
#c
#startm AD_XCLASS_BEGIN 02
.begin-%01-%02
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Argument1: Abstract or Concrete
#c Argument2: Transient or StoredObject
#c            special cases:CommonBase and StoredObjectBase
#c
#c Note: Concrete-StoredObject means Persistent. In other words
#c Concrete-StoredObject objects (and derived objects) are the 
#c only types of objects that should ever be found in an AAF
#c file.
#c
#c Valid combiniations:          examples
#c -----------------------       ---------------
#c   Abstract-CommonBase         AAFRoot 
#c   Abstract-Transient          ????
#c   Abstract-StoredObjectBase   AAFObject
#c   Abstract-StoredObject       AAFSourceReference, AAFComponent, ...
#c   Concrete-Transient          EnumAAFMobs, EnumAAFMobSlots, ...
#c   Concrete-StoredObject       AAFSegment, AAFSourceClip, ...
#c
#startm AD_XCLASS_END 02
.end-%01-%02
#endm


#ccccccccccccccccccccccccccc
#c
#c The following macros implement all of the allowable
#c combinations of the AD_XCLASS_BEGIN and AD_XCLASS_END
#c


#ccccccccccccccccccccccccccc
#c Abstract-CommonBase
#c Special case for the common base class for all AAF objects,
#c Transient and StoredObject classes.
#c (first version defined backwords compatibility)

#startm .begin-Abstract-CommonBase 00
AD_ROOT_CLASS_BEGIN\
#endm

#startm .end-Abstract-CommonBase 00
AD_ROOT_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-StoredObjectBase
#c Special case for the base class for all AAF stored objects
#c (first version defined backwords compatibility)

#startm .begin-Abstract-StoredObjectBase 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-StoredObjectBase 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-Transient
#c (first version defined backwords compatibility)

#startm .begin-Abstract-Transient 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-Transient 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-StoredObject
#c (first version defined backwords compatibility)

#startm .begin-Abstract-StoredObject 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-StoredObject 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Concrete-Transient
#c (first version defined backwords compatibility)

#startm .begin-Concrete-Transient 00
AD_CLASS_BEGIN\
#endm

#startm .end-Concrete-Transient 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Concrete-StoredObject
#c Note: These are the persistent classes.
#c (first version defined backwords compatibility)

#startm .begin-Concrete-StoredObject 00
AD_CLASS_BEGIN\
#endm

#startm .end-Concrete-StoredObject 00
AD_CLASS_END\
#endm



#ccccccccccccccccccccccccccc
#c
#c COMT 
#c Declaration for the dictionary's factory method.
#c
#startm AD_DICTIONARY_FACTORY 02
#endm


#ccccccccccccccccccccccccccc
#c Begining of the module definitions
#c
#startm AD_MODULE_BEGIN 02
#endm


#ccccccccccccccccccccccccccc
#c End of the module definitions
#c
#startm AD_MODULE_END 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes no arguments.
#c
#c Argument1: function name
#c Argument2: function description
#c
#startm AD_FUNCTION0 02
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes one argument.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt	
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c
#c Macro Arg 07: function description
#c
#startm AD_XFUNCTION1 07
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes two arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c
#c Macro Arg 12: function description
#c
#startm AD_XFUNCTION2 12
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes three arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: function description
#c
#startm AD_XFUNCTION3 17
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes four arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c
#c Macro Arg 22: function description
#c
#startm AD_XFUNCTION4 22
#endm
